This file is a merged representation of the entire codebase, combined into a single document by Repomix.
The content has been processed where security check has been disabled.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Security check has been disabled - content may contain sensitive information
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
Aproximaciones/
  .idea/
    copyright/
      profiles_settings.xml
    .name
    compiler.xml
    misc.xml
    modules.xml
    vcs.xml
  src/
    Data/
      Main.java
      PrincipalPanel.java
      Singleton.java
      UserData.java
    firststage/
      ApproxButton.java
      ApproxComboBox.java
      ApproximationPanel.java
      ApproxRadioButton.java
      CheckBoxChoosePlot.java
      ConfigAmplitudePanel.java
      ConfigBandPassPanel.java
      ConfigBandRejectPanel.java
      ConfigDelayPanel.java
      ConfigHighPassPanel.java
      ConfigLowPassPanel.java
      ConfigPanel.java
      ConfigTemplatePanel.java
      DrawingPanel.java
      FilterList.java
      ListButtonsPanel.java
      ListPanel.java
      PlotPlot.java
      Singleton_S1.java
      SliderDesnorm.java
      StageOnePanel.java
    mathematics/
      Approximation.java
      Stage.java
      StageDisposition.java
    secondstage/
      FilterMode.java
      PlotPoleZeroPanel.java
      PlotStagePanel.java
      PoleZeroListsPanel.java
      PoleZeroPanel.java
      SetPlot.java
      Singleton_S2.java
      StagePanel.java
      StagePlotModePanel.java
      StageProperties.java
      StageTwoPanel.java
      StageVisualizerPanel.java
    tclib/
      templates/
        BandpassTemplate.java
        BandrejectTemplate.java
        DelayTemplate.java
        HighpassTemplate.java
        LowpassTemplate.java
        SuperTemplate.java
        TemplatesInterface.java
      GenericUtils.java
      MathUtils.java
      TransferFunction.java
    thirdstage/
      ComponentsPanel.java
      FilterCircuitPanel.java
      ImageDrawer.java
      PlotPanel.java
      ScaledImageLabel.java
      SensitivitiesPanel.java
      Singleton_S3.java
      StagePanel.java
      StagePropertiesPanel.java
      StagesSelectionPanel.java
      StageThreePanel.java
      TopologyConfigPanel.java
  .gitignore
  Aproximaciones.iml
mv.exe.stackdump
README.md
wc.exe.stackdump
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="Aproximaciones/.idea/copyright/profiles_settings.xml">
<component name="CopyrightManager">
  <settings default="" />
</component>
</file>

<file path="Aproximaciones/.idea/.name">
Aproximaciones
</file>

<file path="Aproximaciones/.idea/compiler.xml">
<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CompilerConfiguration">
    <resourceExtensions />
    <wildcardResourcePatterns>
      <entry name="!?*.java" />
      <entry name="!?*.form" />
      <entry name="!?*.class" />
      <entry name="!?*.groovy" />
      <entry name="!?*.scala" />
      <entry name="!?*.flex" />
      <entry name="!?*.kt" />
      <entry name="!?*.clj" />
      <entry name="!?*.aj" />
    </wildcardResourcePatterns>
    <annotationProcessing>
      <profile default="true" name="Default" enabled="false">
        <processorPath useClasspath="true" />
      </profile>
    </annotationProcessing>
  </component>
</project>
</file>

<file path="Aproximaciones/.idea/misc.xml">
<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="EntryPointsManager">
    <entry_points version="2.0" />
  </component>
  <component name="ProjectLevelVcsManager" settingsEditedManually="false">
    <OptionsSetting value="true" id="Add" />
    <OptionsSetting value="true" id="Remove" />
    <OptionsSetting value="true" id="Checkout" />
    <OptionsSetting value="true" id="Update" />
    <OptionsSetting value="true" id="Status" />
    <OptionsSetting value="true" id="Edit" />
    <ConfirmationsSetting value="0" id="Add" />
    <ConfirmationsSetting value="0" id="Remove" />
  </component>
  <component name="ProjectRootManager" version="2" languageLevel="JDK_1_8" default="false" assert-keyword="true" jdk-15="true" project-jdk-name="1.8" project-jdk-type="JavaSDK">
    <output url="file://$PROJECT_DIR$/out" />
  </component>
</project>
</file>

<file path="Aproximaciones/.idea/modules.xml">
<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ProjectModuleManager">
    <modules>
      <module fileurl="file://$PROJECT_DIR$/Aproximaciones.iml" filepath="$PROJECT_DIR$/Aproximaciones.iml" />
    </modules>
  </component>
</project>
</file>

<file path="Aproximaciones/.idea/vcs.xml">
<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="VcsDirectoryMappings">
    <mapping directory="$PROJECT_DIR$/.." vcs="Git" />
  </component>
</project>
</file>

<file path="Aproximaciones/src/Data/Main.java">
package Data;

import tclib.MathUtils;

import javax.swing.*;
import java.awt.*;

import static javax.swing.SwingUtilities.invokeLater;

public class Main extends JFrame {

    public Main() {
        MathUtils.getAllPermutations(5);
        PrincipalPanel principalPanel = new PrincipalPanel();

        this.add(principalPanel);

        this.setExtendedState(JFrame.MAXIMIZED_BOTH); //Full-Screen at Start

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("TP de Aproximaciones en Java");
        setLocationRelativeTo(null);
        setMinimumSize(new Dimension(1280, 720)); //Minimum Screen Size
    }

    public static void main(String[] args) {

        // Ejemplo de funciones pedidas.
 //       System.out.println(Jacobi.cn(4, 3));
 //       de.jtem.mfc.field.Complex c = new de.jtem.mfc.field.Complex(0.2,0);
 //       System.out.println(Jacobi.K_from_k(c));

        for(int x:new int[]{})
            System.out.println(x);


        // <editor-fold defaultstate="collapsed" desc="Look and Feel">
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException | InstantiationException | IllegalAccessException | javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(Main.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        invokeLater(() -> new Main().setVisible(true));
    }
}
</file>

<file path="Aproximaciones/src/Data/PrincipalPanel.java">
package Data;

import firststage.StageOnePanel;
import secondstage.StageTwoPanel;
import thirdstage.StageThreePanel;

import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

/**
 * Created by NEGU on 31/10/2015.
 */
public class PrincipalPanel extends JPanel {
    private static int currentPanel = 0;        //Registry of the stage I'm in.

    /*The configuration goes like this:
       *           There is a principalPanel with two Panels. One is the bigPanel where it has everything of the stage
       *           The other is a buttonPanel which only has two buttons to go back and forth between panels
        */
    JPanel bigPanel;
    StageOnePanel stageOnePanel;
    StageTwoPanel stageTwoPanel;
    StageThreePanel stageThreePanel;
    CardLayout cardLayout;
    JPanel buttonPanel;
    JButton nextStageButton;
    JButton previousStageButton;

    public PrincipalPanel() {
        Singleton s = Singleton.getInstance();
        JPanel bigPanel = new JPanel();
        StageOnePanel stageOnePanel = s.getStageOnePanel();
        StageTwoPanel stageTwoPanel = s.getStageTwoPanel();
        StageThreePanel stageThreePanel = s.getStageThreePanel();
        CardLayout cardLayout = new CardLayout();
        JPanel buttonPanel = new JPanel();
        JButton nextStageButton = new JButton("Next Stage");
        JButton previousStageButton = new JButton("Previous Stage");

        bigPanel.setLayout(cardLayout);
        bigPanel.add(stageOnePanel, "One");
        bigPanel.add(stageTwoPanel, "Two");
        bigPanel.add(stageThreePanel, "Three");

        previousStageButton.setEnabled(false);

        nextStageButton.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                UserData uData = Singleton.getInstance().getUserData();
                if(currentPanel == 0) {
                    if (uData.getApproximationList().size() == 1)
                        uData.setSelection(0);
                    if (uData.getSelection() == -1) {
                        JInternalFrame frame = new JInternalFrame();
                        JOptionPane.showMessageDialog(frame, "Please select a filter before moving on.", "Input Error", JOptionPane.ERROR_MESSAGE);
                        return;
                    }
                    Singleton.getInstance().getStageTwoPanel().set();
                }
                if ( currentPanel == 1) {
                    if (!s.getUserData().getUnmatchedPoles().isEmpty()) {
                        JInternalFrame frame = new JInternalFrame();
                        JOptionPane.showMessageDialog(frame, "Please match all the poles. You can use the button Automatic Selection", "Unmatched Poles", JOptionPane.ERROR_MESSAGE);
                        return;
                    }
                    else {
                        s.getStageThreePanel().set();
                    }
                }

                cardLayout.next(bigPanel);
                currentPanel++;
                previousStageButton.setEnabled(true);
                if (currentPanel == 2) {
                    nextStageButton.setEnabled(false);
                }
            }
        });
        previousStageButton.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                cardLayout.previous(bigPanel);
                currentPanel--;
                nextStageButton.setEnabled(true);
                if (currentPanel == 0) {
                    previousStageButton.setEnabled(false);
                }
            }
        });

        buttonPanel.setLayout(new BorderLayout());
        buttonPanel.add(nextStageButton, BorderLayout.LINE_END);
        buttonPanel.add(previousStageButton, BorderLayout.LINE_START);
        buttonPanel.setMaximumSize(new Dimension(1920, 400));         //TODO: Revisar este hardcode feo

        this.setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
        this.add(bigPanel);
        this.add(buttonPanel);
    }
}
</file>

<file path="Aproximaciones/src/Data/Singleton.java">
package Data;

import firststage.StageOnePanel;
import secondstage.StageTwoPanel;
import thirdstage.StageThreePanel;

public class Singleton {
    private static final Singleton INSTANCE = new Singleton();
    private Singleton() {}
    public static Singleton getInstance() {
        return INSTANCE;
    }

    private UserData userData = null;
    private StageOnePanel stageOnePanel = null;
    private StageTwoPanel stageTwoPanel = null;
    private StageThreePanel stageThreePanel = null;

    public UserData getUserData() {
        if (userData == null)
            userData = new UserData();
        return userData;
    }
    public StageOnePanel getStageOnePanel() {
        if (stageOnePanel == null)
            stageOnePanel = new StageOnePanel();
        return stageOnePanel;
    }
    public StageTwoPanel getStageTwoPanel() {
        if (stageTwoPanel == null)
            stageTwoPanel = new StageTwoPanel();
        return stageTwoPanel;
    }
    public StageThreePanel getStageThreePanel() {
        if (stageThreePanel == null)
            stageThreePanel = new StageThreePanel();
        return stageThreePanel;
    }
}
</file>

<file path="Aproximaciones/src/Data/UserData.java">
package Data;

import mathematics.Approximation;
import mathematics.Stage;
import mathematics.StageDisposition;
import org.apache.commons.math3.complex.Complex;
import tclib.TransferFunction;
import tclib.templates.LowpassTemplate;
import tclib.templates.SuperTemplate;

import java.util.ArrayList;
import java.util.List;

public class UserData {

    private List<Approximation> ApproximationList = new ArrayList<>();
    private SuperTemplate CurrentTemplate = new LowpassTemplate(3., 13., 6., 100, 120);
    private int selection = -1;
    private TransferFunction transferFunction = new TransferFunction(new double[]{1},new double[]{1});
    private List<Complex> unmatchedPoles = new ArrayList<>();
    private List<Complex> unmatchedZeros = new ArrayList<>();
//    private List<Stage> stageList = new ArrayList<>();
    private StageDisposition stageDisposition = null;

    public List<Approximation> getApproximationList() { return ApproximationList; }
    public SuperTemplate getCurrentTemplate() { return CurrentTemplate; }
    public void setCurrentTemplate(SuperTemplate currentTemplate) { CurrentTemplate = currentTemplate; }
    public int getSelection() { return selection; }
    public void setSelection(int selection) { this.selection = selection; }
    public TransferFunction getTransferFunction() { return transferFunction; }
    public void setTransferFunction(TransferFunction t) { transferFunction = t; }
    public List<Complex> getUnmatchedPoles() { return unmatchedPoles; }
    public List<Complex> getUnmatchedZeros() { return unmatchedZeros; }
    public List<Stage> getStageList() { return getStageDisposition().getStageList(); }
    public StageDisposition getStageDisposition() {
        if(stageDisposition == null)
            stageDisposition = new StageDisposition();
        return stageDisposition;
    }
}
</file>

<file path="Aproximaciones/src/firststage/ApproxButton.java">
package firststage;

import Data.Singleton;
import Data.UserData;
import mathematics.Approximation;

import javax.swing.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

/**
 * Created by NEGU on 7/10/2015.
 */
class ApproxButton extends JPanel {
    JButton approxButton = new JButton("Add Aproximation");

    public ApproxButton() {
        this.add(approxButton);
        approxButton.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                Singleton_S1 s = Singleton_S1.getInstance();
                FilterList filterList = s.getFilterList();
                ApproxComboBox approxComboBox = s.getApproxComboBox();
                ApproxRadioButton approxRadioButton = s.getApproxRadioButton();
                Singleton ss = Singleton.getInstance();
                UserData uData = ss.getUserData();
                double Q = 0;
                int order = 0;
                if (approxRadioButton.isMaxQSelected()) {
                    if (approxRadioButton.isParsable())
                        Q = Double.parseDouble(approxRadioButton.getTextSelectorOrder());
                    else return;
                } else if (approxRadioButton.isSetOrderSelected()) {
                    if (approxRadioButton.isParsable())
                        order = Integer.parseInt(approxRadioButton.getTextSelectorOrder());
                    else return;
                }
                double sliderPercentage = s.getSliderDesnorm().getSliderValue();
                Approximation newApprox = new Approximation(approxComboBox.getIndex(), uData.getCurrentTemplate(), sliderPercentage, order, Q);
                for(Approximation x : uData.getApproximationList())
                    if(x.equals(newApprox)) {
                        s.getPlotPlot().updatePlot();
                        return;
                    }
                uData.getApproximationList().add(newApprox);
                filterList.updateList();
                s.getPlotPlot().updatePlot();
            }
        });
    }
}
</file>

<file path="Aproximaciones/src/firststage/ApproxComboBox.java">
package firststage;

import Data.Singleton;
import Data.UserData;
import mathematics.Approximation;

import javax.swing.*;
import java.util.List;

/**
 * Created by NEGU on 7/10/2015.
 */
class ApproxComboBox extends JPanel{
    private JComboBox approxList = new JComboBox();

    public ApproxComboBox(){
        this.add(approxList);
        updateList();
    }

    public int getIndex() { return approxList.getSelectedIndex(); }

    public void updateList() {
        //Here I update the ComboBox. ex. I don't want the Aproximation list to have Bessel if I have a HighPass template
        UserData uData = Singleton.getInstance().getUserData();
        List<String> approxString = Approximation.getStringsToComboBox(uData.getCurrentTemplate());
        approxList.removeAllItems();
        for (String x : approxString)
            approxList.addItem(x);
    }
}
</file>

<file path="Aproximaciones/src/firststage/ApproximationPanel.java">
package firststage;

import javax.swing.*;

/**
 * Created by NEGU on 7/10/2015.
 */
class ApproximationPanel extends JPanel{
    private ApproxComboBox approxComboBox;
    private ApproxRadioButton approxRadioButton;
    private ApproxButton approxButton;
    private SliderDesnorm sliderDesnorm;

    public ApproximationPanel() {
        Singleton_S1 s = Singleton_S1.getInstance();
        approxComboBox = s.getApproxComboBox();
        approxRadioButton = s.getApproxRadioButton();
        approxButton = s.getApproxButton();
        sliderDesnorm = s.getSliderDesnorm();

        this.setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
        this.setBorder(BorderFactory.createTitledBorder("Aproximation Configuration"));

        this.add(approxComboBox);
        this.add(approxRadioButton);
        this.add(sliderDesnorm);
        this.add(approxButton);
    }

    public ApproxComboBox getApproxComboBox() { return approxComboBox; }
}
</file>

<file path="Aproximaciones/src/firststage/ApproxRadioButton.java">
package firststage;

import javax.swing.*;
import java.awt.*;
import java.awt.event.*;

class ApproxRadioButton extends JPanel {
    private ButtonGroup groupOfRadioButtons = new ButtonGroup();
    private JRadioButton minOrder = new JRadioButton("Min Order");
    private JRadioButton maxQ = new JRadioButton("Max Q");
    private JRadioButton setOrder = new JRadioButton("Set Order");
    private JTextField textField = new JTextField();

    //Hacer que no puedas deseleccionar el check box
    public ApproxRadioButton() {
        //ToDo: Revisar esto para que funcione.
        minOrder.setMnemonic(KeyEvent.VK_M); //Te subraya la letra y apretas y funciona
        maxQ.setMnemonic(KeyEvent.VK_Q);
        setOrder.setMnemonic(KeyEvent.VK_S);

        //Set Default option
        minOrder.setSelected(true);
//        maxQ.setSelected(false);
//        setOrder.setSelected(false);
        textField.setEnabled(false);

        //Hardcode Size of TextField
        textField.setMaximumSize(new Dimension(80, 24));
        textField.setPreferredSize(new Dimension(80, 24));
        textField.setMinimumSize(new Dimension(50, 24));

        //AddListener
        minOrder.addItemListener(new ItemListener() {
            @Override
            public void itemStateChanged(ItemEvent e) {
                if (e.getStateChange() == ItemEvent.SELECTED) { //CheckBox Selected
                    textField.setEnabled(false);
                }
            }
        });
        maxQ.addItemListener(new ItemListener() {
            @Override
            public void itemStateChanged(ItemEvent e) {
                if (e.getStateChange() == ItemEvent.SELECTED) { //CheckBox Selected
                    textField.setEnabled(true);
                    textField.grabFocus();
                }
            }
        });
        setOrder.addItemListener(new ItemListener() {
            @Override
            public void itemStateChanged(ItemEvent e) {
                if (e.getStateChange() == ItemEvent.SELECTED) { //CheckBox Selected
                    textField.setEnabled(true);
                    textField.grabFocus();
                }
            }
        });

        groupOfRadioButtons.add(minOrder);
        groupOfRadioButtons.add(maxQ);
        groupOfRadioButtons.add(setOrder);

        GroupLayout layout = new GroupLayout(this);
        this.setLayout(layout);
        layout.setAutoCreateGaps(true);
        layout.setAutoCreateContainerGaps(true);

        layout.setHorizontalGroup(
                layout.createParallelGroup(GroupLayout.Alignment.CENTER)
                        .addGroup(layout.createSequentialGroup()
                                .addComponent(minOrder)
                                .addComponent(maxQ)
                                .addComponent(setOrder))
                        .addComponent(textField)
        );
        layout.setVerticalGroup(
                layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(GroupLayout.Alignment.BASELINE)
                                .addComponent(minOrder)
                                .addComponent(maxQ)
                                .addComponent(setOrder))
                        .addComponent(textField)
        );
    }

    public boolean isParsable(){
        if (setOrder.isSelected()) {
            try {
                int i = Integer.parseInt(textField.getText());
                return (i > 1);
            } catch (NumberFormatException e) {
                JInternalFrame frame = new JInternalFrame();
                JOptionPane.showMessageDialog(frame, "Specified order must be natural number greater than 1.", "Input Error", JOptionPane.ERROR_MESSAGE);
                return false;
            }
        } else if (maxQ.isSelected()){
            try {
                Double i = Double.parseDouble(textField.getText());
                return (i > 0.5);
            } catch (NumberFormatException e) {
            JInternalFrame frame = new JInternalFrame();
            JOptionPane.showMessageDialog(frame, "Q must be a real number greater than 0.5.", "Input Error", JOptionPane.ERROR_MESSAGE);
            return false;
            }
        } else return true;
    }

    public boolean isMinOrderSelected () { return minOrder.isSelected(); }
    public boolean isMaxQSelected() { return maxQ.isSelected(); }
    public boolean isSetOrderSelected() { return setOrder.isSelected(); }
    public String getTextSelectorOrder() { return textField.getText(); }
}
</file>

<file path="Aproximaciones/src/firststage/CheckBoxChoosePlot.java">
package firststage;

import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

/**
 * Created by NEGU on 7/10/2015.
 */
class CheckBoxChoosePlot extends JPanel{
    private Singleton_S1 s = Singleton_S1.getInstance();
    private ButtonGroup groupOfRadioButtons = new ButtonGroup();
    private JRadioButton atenuacion = new JRadioButton("Attenuation");
    private JRadioButton fase = new JRadioButton("Phase");
    private JRadioButton normalizedTemplate = new JRadioButton("Normalized Template");
    private JRadioButton polosCeros = new JRadioButton("Poles and Zeros");
    private JRadioButton step = new JRadioButton("Step");
    private JRadioButton impulse = new JRadioButton("Impulse");


    public CheckBoxChoosePlot() {
        atenuacion.setSelected(true);

        polosCeros.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                s.getPlotPlot().updatePoleZeroPlot();
            }
        });
        atenuacion.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                s.getPlotPlot().recreateTemplate();
                s.getPlotPlot().updateAttenuationPlot();
            }
        });
        step.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                s.getPlotPlot().updateStep();
            }
        });
        impulse.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                s.getPlotPlot().updateImpulse();
            }
        });
        fase.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                s.getPlotPlot().updatePhase();
            }
        });
        normalizedTemplate.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                s.getPlotPlot().updateNormalizedTemplate();
            }
        });

        groupOfRadioButtons.add(atenuacion);
        groupOfRadioButtons.add(fase);
        groupOfRadioButtons.add(normalizedTemplate);
        groupOfRadioButtons.add(polosCeros);
        groupOfRadioButtons.add(step);
        groupOfRadioButtons.add(impulse);

        this.setMinimumSize(new Dimension(500, 100));
        this.setMaximumSize(new Dimension(1980, 100));
        this.setPreferredSize(new Dimension(1980, 100));

        this.add(atenuacion);
        this.add(fase);
        this.add(normalizedTemplate);
        this.add(polosCeros);
        this.add(impulse);
        this.add(step);
    }

    public JRadioButton getFase() { return fase; }
    public JRadioButton getNormalizedTemplate() { return normalizedTemplate; }
    public JRadioButton getPolosCeros() { return polosCeros; }
    public JRadioButton getAtenuacion() { return atenuacion; }
    public JRadioButton getStep() { return step; }
    public JRadioButton getImpulse() { return impulse; }
    public void setAtenuation() { atenuacion.setSelected(true); }
}
</file>

<file path="Aproximaciones/src/firststage/ConfigAmplitudePanel.java">
package firststage;

import javax.swing.*;
import java.awt.*;

class ConfigAmplitudePanel extends JPanel {
    private final int TEXT_HEIGHT = 34;
    private final int TEXT_WIDTH = 70;
    private JTextField textFilterAp = new JTextField("3.0");
    private JTextField textFilterAa = new JTextField("13.0");
    private JTextField textFilterG = new JTextField("6.0");

    public ConfigAmplitudePanel() {
        textFilterAp.setPreferredSize(new Dimension(TEXT_WIDTH, TEXT_HEIGHT));
        textFilterAa.setPreferredSize(new Dimension(TEXT_WIDTH, TEXT_HEIGHT));
        textFilterG.setPreferredSize(new Dimension(TEXT_WIDTH, TEXT_HEIGHT));
        JLabel labelAp = new JLabel("Ap:");
        JLabel labelAa = new JLabel("Aa:");
        JLabel labelG = new JLabel("Gain:");

        GroupLayout layout = new GroupLayout(this);
        this.setLayout(layout);
        layout.setAutoCreateGaps(true);
        layout.setAutoCreateContainerGaps(true);

        layout.setHorizontalGroup(
            layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(GroupLayout.Alignment.TRAILING)
                        .addComponent(labelAp)
                        .addComponent(labelAa)
                        .addComponent(labelG))
                .addGroup(layout.createParallelGroup(GroupLayout.Alignment.LEADING)
                        .addComponent(textFilterAp, GroupLayout.PREFERRED_SIZE, GroupLayout.DEFAULT_SIZE, GroupLayout.PREFERRED_SIZE)
                        .addComponent(textFilterAa, GroupLayout.PREFERRED_SIZE, GroupLayout.DEFAULT_SIZE, GroupLayout.PREFERRED_SIZE)
                        .addComponent(textFilterG, GroupLayout.PREFERRED_SIZE, GroupLayout.DEFAULT_SIZE, GroupLayout.PREFERRED_SIZE))
        );
        layout.setVerticalGroup(
            layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(GroupLayout.Alignment.BASELINE)
                        .addComponent(labelAp)
                        .addComponent(textFilterAp, GroupLayout.PREFERRED_SIZE, GroupLayout.DEFAULT_SIZE, GroupLayout.PREFERRED_SIZE))
                .addGroup(layout.createParallelGroup(GroupLayout.Alignment.BASELINE)
                        .addComponent(labelAa)
                        .addComponent(textFilterAa, GroupLayout.PREFERRED_SIZE, GroupLayout.DEFAULT_SIZE, GroupLayout.PREFERRED_SIZE))
                .addGroup(layout.createParallelGroup(GroupLayout.Alignment.BASELINE)
                        .addComponent(labelG)
                        .addComponent(textFilterG, GroupLayout.PREFERRED_SIZE, GroupLayout.DEFAULT_SIZE, GroupLayout.PREFERRED_SIZE))
        );
    }
    public boolean isParsable(){
        try {
            double ap = Double.parseDouble(textFilterAp.getText());
            double aa = Double.parseDouble(textFilterAa.getText());
            double g = Double.parseDouble(textFilterG.getText());
            if(ap < aa) return true;
            else {
                JInternalFrame frame = new JInternalFrame();
                JOptionPane.showMessageDialog(frame, "Aa must be grater than Ap.", "Input Error", JOptionPane.ERROR_MESSAGE);
                return false;
            }
        } catch (NumberFormatException e) {
            JInternalFrame frame = new JInternalFrame();
            JOptionPane.showMessageDialog(frame, "G, Ap and Aa must be real positive numbers. (G not necessarily positive)", "Input Error", JOptionPane.ERROR_MESSAGE);
            return false;
        }
    }
    public double getAp() {
        try { return Double.parseDouble(textFilterAp.getText()); }
        catch (NumberFormatException e) { return 0.; }
    }
    public double getAa() {
        try { return Double.parseDouble(textFilterAa.getText()); }
        catch (NumberFormatException e) { return 0.; }
    }
    public double getG() {
        try { return Double.parseDouble(textFilterG.getText()); }
        catch (NumberFormatException e) { return 0.; }
    }
    public void setTextBoxes(double ap, double aa, double g){
        textFilterAp.setText(String.valueOf(ap));
        textFilterAa.setText(String.valueOf(aa));
        textFilterG.setText(String.valueOf(g));
    }
}
</file>

<file path="Aproximaciones/src/firststage/ConfigBandPassPanel.java">
package firststage;

import javax.swing.*;
import java.awt.*;

class ConfigBandPassPanel extends JPanel {
    protected final int TEXT_HEIGHT = 24;
    protected final int TEXT_WIDTH = 70;
    protected JTextField textFilterWpm = new JTextField();
    protected JTextField textFilterWam = new JTextField();
    protected JTextField textFilterWpp = new JTextField();
    protected JTextField textFilterWap = new JTextField();

    public ConfigBandPassPanel() {
        setTextBoxes(1200,1000,4000,4800);
        textFilterWpm.setPreferredSize(new Dimension(TEXT_WIDTH, TEXT_HEIGHT));
        textFilterWam.setPreferredSize(new Dimension(TEXT_WIDTH, TEXT_HEIGHT));
        textFilterWpp.setPreferredSize(new Dimension(TEXT_WIDTH, TEXT_HEIGHT));
        textFilterWap.setPreferredSize(new Dimension(TEXT_WIDTH, TEXT_HEIGHT));
        JLabel labelWpm = new JLabel("Wp-:");
        JLabel labelWam = new JLabel("Wa-:");
        JLabel labelWpp = new JLabel("Wp+:");
        JLabel labelWap = new JLabel("Wa+:");

        GroupLayout layout = new GroupLayout(this);
        this.setLayout(layout);
        layout.setAutoCreateGaps(true);
        layout.setAutoCreateContainerGaps(true);

        layout.setHorizontalGroup(
            layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(GroupLayout.Alignment.TRAILING)
                        .addComponent(labelWpm)
                        .addComponent(labelWam)
                        .addComponent(labelWpp)
                        .addComponent(labelWap))
                .addGroup(layout.createParallelGroup(GroupLayout.Alignment.LEADING)
                        .addComponent(textFilterWpm, GroupLayout.PREFERRED_SIZE, GroupLayout.DEFAULT_SIZE, GroupLayout.PREFERRED_SIZE)
                        .addComponent(textFilterWam, GroupLayout.PREFERRED_SIZE, GroupLayout.DEFAULT_SIZE, GroupLayout.PREFERRED_SIZE)
                        .addComponent(textFilterWpp, GroupLayout.PREFERRED_SIZE, GroupLayout.DEFAULT_SIZE, GroupLayout.PREFERRED_SIZE)
                        .addComponent(textFilterWap, GroupLayout.PREFERRED_SIZE, GroupLayout.DEFAULT_SIZE, GroupLayout.PREFERRED_SIZE))
        );
        layout.setVerticalGroup(
            layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(GroupLayout.Alignment.BASELINE)
                        .addComponent(labelWpm)
                        .addComponent(textFilterWpm, GroupLayout.PREFERRED_SIZE, GroupLayout.DEFAULT_SIZE, GroupLayout.PREFERRED_SIZE))
                .addGroup(layout.createParallelGroup(GroupLayout.Alignment.BASELINE)
                        .addComponent(labelWam)
                        .addComponent(textFilterWam, GroupLayout.PREFERRED_SIZE, GroupLayout.DEFAULT_SIZE, GroupLayout.PREFERRED_SIZE))
                .addGroup(layout.createParallelGroup(GroupLayout.Alignment.BASELINE)
                        .addComponent(labelWpp)
                        .addComponent(textFilterWpp, GroupLayout.PREFERRED_SIZE, GroupLayout.DEFAULT_SIZE, GroupLayout.PREFERRED_SIZE))
                .addGroup(layout.createParallelGroup(GroupLayout.Alignment.BASELINE)
                        .addComponent(labelWap)
                        .addComponent(textFilterWap, GroupLayout.PREFERRED_SIZE, GroupLayout.DEFAULT_SIZE, GroupLayout.PREFERRED_SIZE))
        );
    }

    public boolean isParsable(){
       try {
           double wpm = Double.parseDouble(textFilterWpm.getText());
           double wam = Double.parseDouble(textFilterWam.getText());
           double wpp = Double.parseDouble(textFilterWpp.getText());
           double wap = Double.parseDouble(textFilterWap.getText());
           if( wpp > wpm ) {
               if ( wap > wam ) {
                   if ( (wpp < wap) && (wpm > wam) ) {
                       return true;
                   }
                   else {
                       JInternalFrame frame = new JInternalFrame();
                       JOptionPane.showMessageDialog(frame, "Bp must be contained inside Ba", "Input Error", JOptionPane.ERROR_MESSAGE);
                       return false;
                   }
               }
               else {
                   JInternalFrame frame = new JInternalFrame();
                   JOptionPane.showMessageDialog(frame, "Wa+ must be grater than Wa-.", "Input Error", JOptionPane.ERROR_MESSAGE);
                   return false;
               }
           }
           else {
                JInternalFrame frame = new JInternalFrame();
                JOptionPane.showMessageDialog(frame, "Wp+ must be grater than Wp-.", "Input Error", JOptionPane.ERROR_MESSAGE);
                return false;
            }
       } catch (NumberFormatException e) {
           JInternalFrame frame = new JInternalFrame();
           JOptionPane.showMessageDialog(frame, "Frequencies must be real positive numbers.", "Input Error", JOptionPane.ERROR_MESSAGE);
           return false;
       }
    }

    public Double getWpm() {
        try { return Double.parseDouble(textFilterWpm.getText()); }
        catch (NumberFormatException e) { return 0.; }
    }
    public Double getWam() {
        try { return Double.parseDouble(textFilterWam.getText()); }
        catch (NumberFormatException e) { return 0.; }
    }
    public Double getWpp() {
        try { return Double.parseDouble(textFilterWpp.getText()); }
        catch (NumberFormatException e) { return 0.; }
    }
    public Double getWap() {
        try { return Double.parseDouble(textFilterWap.getText()); }
        catch (NumberFormatException e) { return 0.; }
    }
    public void setTextBoxes(double wpm, double wam, double wpp, double wap){
        textFilterWpm.setText(String.valueOf(wpm));
        textFilterWam.setText(String.valueOf(wam));
        textFilterWpp.setText(String.valueOf(wpp));
        textFilterWap.setText(String.valueOf(wap));
    }
}
</file>

<file path="Aproximaciones/src/firststage/ConfigBandRejectPanel.java">
package firststage;

import javax.swing.*;

class ConfigBandRejectPanel extends ConfigBandPassPanel {
    public ConfigBandRejectPanel() {
        super();
        setTextBoxes(1000,1200,4800,4000);
    }

    @Override
    public boolean isParsable(){
        try {
            double wpm = Double.parseDouble(textFilterWpm.getText());
            double wam = Double.parseDouble(textFilterWam.getText());
            double wpp = Double.parseDouble(textFilterWpp.getText());
            double wap = Double.parseDouble(textFilterWap.getText());
            if( wpp > wpm ) {
                if ( wap > wam ) {
                    if ( (wap < wpp) && (wam > wpm) ) {
                        return true;
                    }
                    else {
                        JInternalFrame frame = new JInternalFrame();
                        JOptionPane.showMessageDialog(frame, "Ba must be contained inside Bp", "Input Error", JOptionPane.ERROR_MESSAGE);
                        return false;
                    }
                }
                else {
                    JInternalFrame frame = new JInternalFrame();
                    JOptionPane.showMessageDialog(frame, "Wa+ must be grater than Wa-.", "Input Error", JOptionPane.ERROR_MESSAGE);
                    return false;
                }
            }
            else {
                JInternalFrame frame = new JInternalFrame();
                JOptionPane.showMessageDialog(frame, "Wp+ must be grater than Wp-.", "Input Error", JOptionPane.ERROR_MESSAGE);
                return false;
            }
        } catch (NumberFormatException e) {
            JInternalFrame frame = new JInternalFrame();
            JOptionPane.showMessageDialog(frame, "Frequencies must be real positive numbers.", "Input Error", JOptionPane.ERROR_MESSAGE);
            return false;
        }
    }
}
</file>

<file path="Aproximaciones/src/firststage/ConfigDelayPanel.java">
package firststage;

import javax.swing.*;
import java.awt.*;

class ConfigDelayPanel extends JPanel {
    protected final int TEXT_HEIGHT = 24;
    protected final int TEXT_WIDTH = 70;
    private JTextField textFilterWp = new JTextField();
    private JTextField textFilterWa = new JTextField();
    private JTextField textFilterDelay = new JTextField();
    private JTextField textFilterPsi = new JTextField();

    //TODO: Todavía no tengo idea como se hace un filtro de Delay, Yo lo dejaría para el final..
    public ConfigDelayPanel() {
        textFilterWp.setPreferredSize(new Dimension(TEXT_WIDTH, TEXT_HEIGHT));
        textFilterWa.setPreferredSize(new Dimension(TEXT_WIDTH, TEXT_HEIGHT));
        textFilterDelay.setPreferredSize(new Dimension(TEXT_WIDTH, TEXT_HEIGHT));
        textFilterPsi.setPreferredSize(new Dimension(TEXT_WIDTH, TEXT_HEIGHT));
        JLabel labelWp = new JLabel("Wp:");
        JLabel labelWa = new JLabel("Wa:");
        JLabel labelDelay = new JLabel("T(ms):");
        JLabel labelPsi = new JLabel("\u03C8:"); //Psi


        GroupLayout layout = new GroupLayout(this);
        this.setLayout(layout);
        layout.setAutoCreateGaps(true);
        layout.setAutoCreateContainerGaps(true);

        layout.setHorizontalGroup(
                layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(GroupLayout.Alignment.TRAILING)
                                .addComponent(labelWp)
                                .addComponent(labelWa)
                                .addComponent(labelDelay)
                                .addComponent(labelPsi))
                        .addGroup(layout.createParallelGroup(GroupLayout.Alignment.LEADING)
                                .addComponent(textFilterWa, GroupLayout.PREFERRED_SIZE, GroupLayout.DEFAULT_SIZE, GroupLayout.PREFERRED_SIZE)
                                .addComponent(textFilterWp, GroupLayout.PREFERRED_SIZE, GroupLayout.DEFAULT_SIZE, GroupLayout.PREFERRED_SIZE)
                                .addComponent(textFilterDelay, GroupLayout.PREFERRED_SIZE, GroupLayout.DEFAULT_SIZE, GroupLayout.PREFERRED_SIZE)
                                .addComponent(textFilterPsi, GroupLayout.PREFERRED_SIZE, GroupLayout.DEFAULT_SIZE, GroupLayout.PREFERRED_SIZE))
        );
        layout.setVerticalGroup(
                layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(GroupLayout.Alignment.BASELINE)
                                .addComponent(labelWp)
                                .addComponent(textFilterWp, GroupLayout.PREFERRED_SIZE, GroupLayout.DEFAULT_SIZE, GroupLayout.PREFERRED_SIZE))
                        .addGroup(layout.createParallelGroup(GroupLayout.Alignment.BASELINE)
                                .addComponent(labelWa)
                                .addComponent(textFilterWa, GroupLayout.PREFERRED_SIZE, GroupLayout.DEFAULT_SIZE, GroupLayout.PREFERRED_SIZE))
                        .addGroup(layout.createParallelGroup(GroupLayout.Alignment.BASELINE)
                                .addComponent(labelDelay)
                                .addComponent(textFilterDelay, GroupLayout.PREFERRED_SIZE, GroupLayout.DEFAULT_SIZE, GroupLayout.PREFERRED_SIZE))
                        .addGroup(layout.createParallelGroup(GroupLayout.Alignment.BASELINE)
                                .addComponent(labelPsi)
                                .addComponent(textFilterPsi, GroupLayout.PREFERRED_SIZE, GroupLayout.DEFAULT_SIZE, GroupLayout.PREFERRED_SIZE))
        );
    }
    public boolean isParsable(){
        try {
            double wp = Double.parseDouble(textFilterWp.getText());
            double wa = Double.parseDouble(textFilterWa.getText());
            double delay = Double.parseDouble(textFilterDelay.getText());
            double psi = Double.parseDouble(textFilterPsi.getText());
            if(wp > 0 && wa > 0 && delay > 0 && psi > 0) {
                if (wp < wa) return true;
                else {
                    JInternalFrame frame = new JInternalFrame();
                    JOptionPane.showMessageDialog(frame, "Wa must be grater than Wp.", "Input Error", JOptionPane.ERROR_MESSAGE);
                    return false;
                }
            } else {
                JInternalFrame frame = new JInternalFrame();
                JOptionPane.showMessageDialog(frame, "Wp, Wa, T and psi must be positive numbers.", "Input Error", JOptionPane.ERROR_MESSAGE);
                return false;
            }
        } catch (NumberFormatException e) {
            JInternalFrame frame = new JInternalFrame();
            JOptionPane.showMessageDialog(frame, "Wp, Wa, T and psi must be real positive numbers.", "Input Error", JOptionPane.ERROR_MESSAGE);
            return false;
        }
    }
    public Double getWp() {
        try { return Double.parseDouble(textFilterWp.getText()); }
        catch (NumberFormatException e) { return 0.; }
    }
    public Double getWa() {
        try { return Double.parseDouble(textFilterWa.getText()); }
        catch (NumberFormatException e) { return 0.; }
    }
    public Double getDelay() {
        try { return Double.parseDouble(textFilterDelay.getText()); }
        catch (NumberFormatException e) { return 0.; }
    }
    public Double getPsi() {
        try { return Double.parseDouble(textFilterPsi.getText()); }
        catch (NumberFormatException e) { return 0.; }
    }
    public void setTextBoxes(double wp, double wa, double delay, double psi){
        textFilterWp.setText(String.valueOf(wp));
        textFilterWa.setText(String.valueOf(wa));
        textFilterDelay.setText(String.valueOf(delay));
        textFilterPsi.setText(String.valueOf(psi));
    }
}
</file>

<file path="Aproximaciones/src/firststage/ConfigHighPassPanel.java">
package firststage;

import javax.swing.*;

class ConfigHighPassPanel extends ConfigLowPassPanel {
    public ConfigHighPassPanel() {
        super();
        setTextBoxes(1200,1000);
    }

    @Override
    public boolean isParsable(){
        try {
            double wp = Double.parseDouble(textFilterWp.getText());
            double wa = Double.parseDouble(textFilterWa.getText());
            if(wa < wp) return true;
            else {
                JInternalFrame frame = new JInternalFrame();
                JOptionPane.showMessageDialog(frame, "Wp must be grater than Wa.", "Input Error", JOptionPane.ERROR_MESSAGE);
                return false;
            }
        } catch (NumberFormatException e) {
            JInternalFrame frame = new JInternalFrame();
            JOptionPane.showMessageDialog(frame, "Wp and Wa must be real positive numbers.", "Input Error", JOptionPane.ERROR_MESSAGE);
            return false;
        }
    }
}
</file>

<file path="Aproximaciones/src/firststage/ConfigLowPassPanel.java">
package firststage;

import javax.swing.*;
import java.awt.*;

class ConfigLowPassPanel extends JPanel {
    protected final int TEXT_HEIGHT = 34;
    protected final int TEXT_WIDTH = 70;
    protected JTextField textFilterWp = new JTextField();
    protected JTextField textFilterWa = new JTextField();

    public ConfigLowPassPanel() {
        setTextBoxes(1000,1200);
        textFilterWp.setPreferredSize(new Dimension(TEXT_WIDTH, TEXT_HEIGHT));
        textFilterWa.setPreferredSize(new Dimension(TEXT_WIDTH, TEXT_HEIGHT));
        JLabel labelWp = new JLabel("Wp:");
        JLabel labelWa = new JLabel("Wa:");
//        JLabel units = new JLabel("rad/seg");

        GroupLayout layout = new GroupLayout(this);
        this.setLayout(layout);
        layout.setAutoCreateGaps(true);
        layout.setAutoCreateContainerGaps(true);

        layout.setHorizontalGroup(
            layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(GroupLayout.Alignment.TRAILING)
                        .addComponent(labelWp)
                        .addComponent(labelWa))
                .addGroup(layout.createParallelGroup(GroupLayout.Alignment.LEADING)
                        .addComponent(textFilterWa, GroupLayout.PREFERRED_SIZE, GroupLayout.DEFAULT_SIZE, GroupLayout.PREFERRED_SIZE)
                        .addComponent(textFilterWp, GroupLayout.PREFERRED_SIZE, GroupLayout.DEFAULT_SIZE, GroupLayout.PREFERRED_SIZE))
        );
        layout.setVerticalGroup(
            layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(GroupLayout.Alignment.BASELINE)
                        .addComponent(labelWp)
                        .addComponent(textFilterWp, GroupLayout.PREFERRED_SIZE, GroupLayout.DEFAULT_SIZE, GroupLayout.PREFERRED_SIZE))
                .addGroup(layout.createParallelGroup(GroupLayout.Alignment.BASELINE)
                        .addComponent(labelWa)
                        .addComponent(textFilterWa, GroupLayout.PREFERRED_SIZE, GroupLayout.DEFAULT_SIZE, GroupLayout.PREFERRED_SIZE))
        );
    }
    public boolean isParsable(){
        try {
            double wp = Double.parseDouble(textFilterWp.getText());
            double wa = Double.parseDouble(textFilterWa.getText());
            if(wp < wa) return true;
            else {
                JInternalFrame frame = new JInternalFrame();
                JOptionPane.showMessageDialog(frame, "Wa must be grater than Wp.", "Input Error", JOptionPane.ERROR_MESSAGE);
                return false;
            }
        } catch (NumberFormatException e) {
            JInternalFrame frame = new JInternalFrame();
            JOptionPane.showMessageDialog(frame, "Wp and Wa must be real positive numbers.", "Input Error", JOptionPane.ERROR_MESSAGE);
            return false;
        }
    }
    public Double getWp() {
        try { return Double.parseDouble(textFilterWp.getText()); }
        catch (NumberFormatException e) { return 0.; }
    }
    public Double getWa() {
        try { return Double.parseDouble(textFilterWa.getText()); }
        catch (NumberFormatException e) { return 0.; }
    }
    public void setTextBoxes(double wp, double wa){
        textFilterWp.setText(String.valueOf(wp));
        textFilterWa.setText(String.valueOf(wa));
    }
}
</file>

<file path="Aproximaciones/src/firststage/ConfigPanel.java">
package firststage;

import javax.swing.*;
import java.awt.*;

class ConfigPanel extends JPanel {
    private ListPanel listPanel;
    private ApproximationPanel approximationPanel;
    private ConfigTemplatePanel configTemplatePanel;

    public ConfigPanel() {
        Singleton_S1 s = Singleton_S1.getInstance();
        listPanel = s.getListPanel();
        approximationPanel = s.getApproximationPanel();
        configTemplatePanel = s.getConfigTemplatePanel();

        //Configuration Panel
        this.setMaximumSize(new Dimension(300, 2080));
        //this.setMinimumSize(new Dimension(300, 768));
        //this.setPreferredSize(new Dimension(300, 768));

        this.setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
        //this.setLayout(new GridLayout(4,1));
        //configPanel.setBorder(BorderFactory.createTitledBorder("Configuration"));

        this.add(configTemplatePanel);
        this.add(approximationPanel);
        this.add(listPanel);
    }
}
</file>

<file path="Aproximaciones/src/firststage/ConfigTemplatePanel.java">
package firststage;

import Data.Singleton;
import Data.UserData;
import tclib.templates.*;

import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.Arrays;
import java.util.List;

class ConfigTemplatePanel extends JPanel implements TemplatesInterface {
    private ApproxComboBox approxComboBox;
    private JComboBox filterTypeList = new JComboBox(templateStrings);
    private ConfigAmplitudePanel configAmplitudePanel;
    private ButtonFilterType buttonFilterType;
    private CardLayout cardLayout = new CardLayout();
    private JPanel freqPanel = new JPanel();
    private int index = 0;
    private final List<String> cardList = Arrays.asList("LP", "HP", "BP", "BR", "DL");

    public ConfigTemplatePanel() {
        Singleton_S1 s = Singleton_S1.getInstance();
        approxComboBox = s.getApproxComboBox();
        configAmplitudePanel = s.getConfigAmplitudePanel();
        freqPanel.setLayout(cardLayout);
        freqPanel.add(s.getConfigLowPassPanel(), cardList.get(0));
        freqPanel.add(s.getConfigHighPassPanel(), cardList.get(1));
        freqPanel.add(s.getConfigBandPassPanel(), cardList.get(2));
        freqPanel.add(s.getConfigBandRejectPanel(), cardList.get(3));
        freqPanel.add(s.getConfigDelayPanel(), cardList.get(4));

        this.setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
        this.setBorder(BorderFactory.createTitledBorder("Template Configurator"));

        buttonFilterType = new ButtonFilterType();

        SuperTemplate t = Singleton.getInstance().getUserData().getCurrentTemplate();
        if (t instanceof LowpassTemplate) {
            index = 0;
            LowpassTemplate temp = (LowpassTemplate) t;
            s.getConfigLowPassPanel().setTextBoxes(temp.getWp(), temp.getWa());
        } else if (t instanceof HighpassTemplate) {
            index = 1;
            HighpassTemplate temp = (HighpassTemplate) t;
            s.getConfigHighPassPanel().setTextBoxes(temp.getWp(),temp.getWa());
        } else if (t instanceof BandpassTemplate) {
            index = 2;
            BandpassTemplate temp = (BandpassTemplate) t;
            s.getConfigBandPassPanel().setTextBoxes(temp.getWpm(), temp.getWam(), temp.getWpp(), temp.getWap());
        } else if (t instanceof BandrejectTemplate) {
            index = 3;
            BandrejectTemplate temp = (BandrejectTemplate) t;
            s.getConfigBandRejectPanel().setTextBoxes(temp.getWpm(), temp.getWam(), temp.getWpp(), temp.getWap());
        }  else { //(t instanceof DelayTemplate)
            index = 4;
            DelayTemplate temp = (DelayTemplate) t;
            s.getConfigDelayPanel().setTextBoxes(temp.getWp(), temp.getWa(), temp.getDelay(), temp.getPsi());
        }
        s.getConfigAmplitudePanel().setTextBoxes(t.getAp(), t.getAa(), t.getG());
        cardLayout.show(freqPanel,cardList.get(index));
        filterTypeList.setSelectedIndex(index);

        filterTypeList.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                index = filterTypeList.getSelectedIndex();
                cardLayout.show(freqPanel, cardList.get(index));
            }
        });

        filterTypeList.setPreferredSize(new Dimension(150, 30));

        GroupLayout layout = new GroupLayout(this);
        this.setLayout(layout);
        layout.setAutoCreateGaps(true);
        layout.setAutoCreateContainerGaps(true);

        layout.setHorizontalGroup(
                layout.createParallelGroup(GroupLayout.Alignment.CENTER)
                        .addComponent(filterTypeList, GroupLayout.PREFERRED_SIZE, GroupLayout.DEFAULT_SIZE, GroupLayout.PREFERRED_SIZE)
                        .addGroup(layout.createSequentialGroup()
                                .addComponent(configAmplitudePanel)
                                .addComponent(freqPanel, GroupLayout.PREFERRED_SIZE, GroupLayout.DEFAULT_SIZE, GroupLayout.PREFERRED_SIZE))
                        .addComponent(buttonFilterType)
        );
        layout.setVerticalGroup(
                layout.createSequentialGroup()
                        .addComponent(filterTypeList, GroupLayout.PREFERRED_SIZE, GroupLayout.DEFAULT_SIZE, GroupLayout.PREFERRED_SIZE)
                        .addGroup(layout.createParallelGroup(GroupLayout.Alignment.LEADING)
                                .addComponent(configAmplitudePanel)
                                .addComponent(freqPanel, GroupLayout.PREFERRED_SIZE, GroupLayout.DEFAULT_SIZE, GroupLayout.PREFERRED_SIZE))
                        .addComponent(buttonFilterType)
        );
    }

    public class ButtonFilterType extends JPanel {
        JButton buttonFilterType = new JButton("Create Template");

        public ButtonFilterType() {
            this.add(buttonFilterType);
            buttonFilterType.addActionListener(new ActionListener() {
                @Override
                public void actionPerformed(ActionEvent e) {
                    //ToDo: IsParsable antes de crear el template
                    Singleton_S1 s = Singleton_S1.getInstance();
                    UserData uData = Singleton.getInstance().getUserData();

                    double ap, aa, g;
                    if (s.getConfigAmplitudePanel().isParsable()) {
                        ap = s.getConfigAmplitudePanel().getAp();
                        aa = s.getConfigAmplitudePanel().getAa();
                        g = s.getConfigAmplitudePanel().getG();
                    } else return;

                    int index = filterTypeList.getSelectedIndex();
                    SuperTemplate newTemplate;
                    switch ( templateType.values()[index] ) {
                        case LOWPASS:
                            if (s.getConfigLowPassPanel().isParsable()) {
                                double wp = s.getConfigLowPassPanel().getWp();
                                double wa = s.getConfigLowPassPanel().getWa();
                                newTemplate = new LowpassTemplate(ap, aa, g, wp, wa);
                            } else return; break;
                        case HIGHPASS:
                            if (s.getConfigHighPassPanel().isParsable()) {
                                double wp = s.getConfigHighPassPanel().getWp();
                                double wa = s.getConfigHighPassPanel().getWa();
                                newTemplate = new HighpassTemplate(ap, aa, g, wp, wa);
                            } else return; break;
                        case BANDPASS:
                            if (s.getConfigBandPassPanel().isParsable()) {
                                double wpm = s.getConfigBandPassPanel().getWpm();
                                double wam = s.getConfigBandPassPanel().getWam();
                                double wpp = s.getConfigBandPassPanel().getWpp();
                                double wap = s.getConfigBandPassPanel().getWap();
                                newTemplate = new BandpassTemplate(ap, aa, g, wpm, wam, wpp, wap);
                            } else return; break;
                        case BANDREJECT:
                            if (s.getConfigBandRejectPanel().isParsable()) {
                                double wpm = s.getConfigBandRejectPanel().getWpm();
                                double wam = s.getConfigBandRejectPanel().getWam();
                                double wpp = s.getConfigBandRejectPanel().getWpp();
                                double wap = s.getConfigBandRejectPanel().getWap();
                                newTemplate = new BandrejectTemplate(ap, aa, g, wpm, wam, wpp, wap);
                            } else return; break;
                        default: //case DELAY:
                            if (s.getConfigDelayPanel().isParsable()) {
                                double wp = s.getConfigDelayPanel().getWp();
                                double wa = s.getConfigDelayPanel().getWa();
                                double delay = s.getConfigDelayPanel().getDelay();
                                double psi = s.getConfigDelayPanel().getPsi();
                                newTemplate = new DelayTemplate(ap, aa, g, wp, wa, delay, psi);
                            } else return; break;
                    }
                    if (newTemplate.equals(uData.getCurrentTemplate()))
                        return;
                    else {
                        uData.setCurrentTemplate(newTemplate);
                        uData.getApproximationList().clear();
                        uData.setSelection(-1);
                        s.getFilterList().updateList();
                        approxComboBox.updateList();
                        s.getPlotPlot().recreateTemplate();
                    }
                }
            });
        }
    }
}
</file>

<file path="Aproximaciones/src/firststage/DrawingPanel.java">
package firststage;

import javax.swing.*;

/**
 * Created by NEGU on 7/10/2015.
 */
class DrawingPanel extends JPanel {

    public DrawingPanel() {
        Singleton_S1 s = Singleton_S1.getInstance();
        PlotPlot plotPanel = s.getPlotPlot();
        CheckBoxChoosePlot choosePlotPanel = s.getCheckBoxChoosePlot();

        this.setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));

        this.add(plotPanel);
        this.add(choosePlotPanel);
    }
}
</file>

<file path="Aproximaciones/src/firststage/FilterList.java">
package firststage;

import Data.Singleton;
import Data.UserData;
import mathematics.Approximation;

import javax.swing.*;
import java.awt.*;

class FilterList extends JPanel{
    private DefaultListModel<String> listModel = new DefaultListModel<String>();
    private JList<String> approxList = new JList<String>(listModel);

    public FilterList() {
        approxList.setCellRenderer(new MyCellRenderer());
        approxList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);  //You can only choose one option.
        approxList.setLayoutOrientation(JList.VERTICAL);
        approxList.setVisibleRowCount(4); //Acá va la máxima cantidad de nombres que tira sin el scroller. Si se pone -1 trata de poner todas las que entren.
        JScrollPane listScroller = new JScrollPane(approxList);

        this.add(listScroller);
    }

    public void updateList() {
        int lastIndex = approxList.getSelectedIndex();              //Save selected index and erase the list.
        listModel.removeAllElements();

        UserData uData = Singleton.getInstance().getUserData();
        for(Approximation x : uData.getApproximationList())         //Get the list from the userData List.
            listModel.addElement(x.getDetails());

        if(lastIndex < approxList.getModel().getSize())             //Reset the last index.
            approxList.setSelectedIndex(lastIndex);
        else approxList.setSelectedIndex(approxList.getModel().getSize()-1);    //Or select the last element on list.
        approxList.ensureIndexIsVisible(approxList.getSelectedIndex());         //Make sure it is visible.
    }

    public int getIndex() {return approxList.getSelectedIndex();}
    public boolean isAnItemSelected() { return !approxList.isSelectionEmpty(); }

    private class MyCellRenderer extends DefaultListCellRenderer {  //Sets the selected filter on Bold.
        public Component getListCellRendererComponent(JList list, Object value, int index, boolean isSelected, boolean cellHasFocus) {
            Component c = super.getListCellRendererComponent(list, value, index, isSelected, cellHasFocus);

            if (index == Singleton.getInstance().getUserData().getSelection())
                c.setFont(c.getFont().deriveFont(Font.BOLD));
            else
                c.setFont(c.getFont().deriveFont(Font.PLAIN));
            return c;
        }
    }
}
</file>

<file path="Aproximaciones/src/firststage/ListButtonsPanel.java">
package firststage;

import Data.Singleton;
import Data.UserData;

import javax.swing.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

/**
 * Created by NEGU on 5/11/2015.
 */
class ListButtonsPanel extends JPanel{
    private JButton deleteItem;
    private JButton deleteAllItems;
    private JButton selectFilter;


    ListButtonsPanel () {
        deleteItem = new JButton("Delete Item");
        deleteAllItems = new JButton("Delete All Items");
        selectFilter = new JButton("Select Filter");

        deleteItem.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                FilterList filterList = Singleton_S1.getInstance().getFilterList();

                if (filterList.isAnItemSelected()){
                    int index = filterList.getIndex();
                    UserData uData = Singleton.getInstance().getUserData();
                    uData.getApproximationList().remove(index);

                    if (index < uData.getSelection())
                        uData.setSelection(uData.getSelection()-1);
                    else if (index == uData.getSelection())
                        uData.setSelection(-1);

                    filterList.updateList();
                    Singleton_S1.getInstance().getPlotPlot().updatePlot();
                }
            }
        });
        deleteAllItems.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                Singleton.getInstance().getUserData().getApproximationList().clear();
                Singleton.getInstance().getUserData().setSelection(-1);
                Singleton_S1.getInstance().getFilterList().updateList();
                Singleton_S1.getInstance().getPlotPlot().updatePlot();
            }
        });
        selectFilter.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                Singleton_S1 s = Singleton_S1.getInstance();
                FilterList filterList = s.getFilterList();

                if (filterList.isAnItemSelected()) {
                    int index = filterList.getIndex();
                    Singleton.getInstance().getUserData().setSelection(index);
                    filterList.updateList();
                    //TODO: Guardar el TF selccionado para pasar al StageTwoPanel
                }
                else {
                    JInternalFrame frame = new JInternalFrame();
                    JOptionPane.showMessageDialog(frame, "There is no filter selected.", "Input Error", JOptionPane.ERROR_MESSAGE);
                }
            }
        });

        GroupLayout layout = new GroupLayout(this);
        this.setLayout(layout);
        layout.setAutoCreateGaps(true);
        layout.setAutoCreateContainerGaps(true);

        layout.setHorizontalGroup(
                layout.createParallelGroup(GroupLayout.Alignment.CENTER)
                        .addGroup(layout.createSequentialGroup()
                                .addComponent(deleteItem)
                                .addComponent(deleteAllItems))
                        .addComponent(selectFilter)
        );
        layout.setVerticalGroup(
                layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(GroupLayout.Alignment.BASELINE)
                                .addComponent(deleteItem)
                                .addComponent(deleteAllItems))
                        .addComponent(selectFilter)
        );
    }
}
</file>

<file path="Aproximaciones/src/firststage/ListPanel.java">
package firststage;

import javax.swing.*;

/*
 * Created by NEGU on 7/10/2015.
 */
class ListPanel extends JPanel{
    private FilterList filterList;
    private ListButtonsPanel listButtonsPanel;

    public ListPanel() {
        Singleton_S1 s = Singleton_S1.getInstance();
        filterList = s.getFilterList();
        listButtonsPanel = s.getListButtonsPanel();

        this.setBorder(BorderFactory.createTitledBorder("Aproximation List"));

        GroupLayout layout = new GroupLayout(this);
        this.setLayout(layout);
        layout.setAutoCreateGaps(true);
        layout.setAutoCreateContainerGaps(true);

        layout.setHorizontalGroup(
                layout.createParallelGroup(GroupLayout.Alignment.CENTER)
                        .addComponent(filterList, 0, GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(listButtonsPanel)
        );
        layout.setVerticalGroup(
                layout.createSequentialGroup()
                        .addComponent(filterList, 0, GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(listButtonsPanel)
        );
    }

    //public void addItemToList(String aproximationToAdd) { filterList.AddToList(aproximationToAdd); }
    public FilterList getFilterList() { return filterList; }
}
</file>

<file path="Aproximaciones/src/firststage/PlotPlot.java">
package firststage;

import Data.Singleton;
import Data.UserData;
import mathematics.Approximation;
import org.apache.commons.math3.complex.Complex;
import org.jfree.chart.ChartFactory;
import org.jfree.chart.ChartPanel;
import org.jfree.chart.JFreeChart;
import org.jfree.chart.annotations.XYShapeAnnotation;
import org.jfree.chart.axis.LogarithmicAxis;
import org.jfree.chart.axis.NumberAxis;
import org.jfree.chart.axis.ValueAxis;
import org.jfree.chart.plot.XYPlot;
import org.jfree.chart.renderer.xy.StandardXYItemRenderer;
import org.jfree.chart.renderer.xy.XYItemRenderer;
import org.jfree.chart.renderer.xy.XYLineAndShapeRenderer;
import org.jfree.data.xy.XYDataset;
import org.jfree.data.xy.XYSeries;
import org.jfree.data.xy.XYSeriesCollection;
import org.jfree.util.ShapeUtilities;
import tclib.GenericUtils;
import tclib.TransferFunction;
import tclib.templates.*;

import javax.swing.*;
import java.awt.*;
import java.awt.geom.Ellipse2D;

/**
 * Created by NEGU on 7/10/2015.
 */
class PlotPlot extends JPanel{
    private Singleton s = Singleton.getInstance();
    private UserData userData = s.getUserData();
    private Singleton_S1 s1 = Singleton_S1.getInstance();
    private SuperTemplate currentTemplate;
    private double wmin;
    private double wmax;
    XYPlot plotA;
    XYPlot plotPZ;
    XYPlot plotStepOrImpulse;
    CardLayout cardLayout = new CardLayout();
    Shape cross = ShapeUtilities.createDiagonalCross(3,(float)0.3);

    public PlotPlot() {
        JPanel plotPanel = createAttenuationPanel();
        JPanel poleZeroPanel = createPoleZeroPanel();
        JPanel stepPanel = createStepPanel();

        this.setLayout(cardLayout);

        this.setBorder(BorderFactory.createTitledBorder("Plot"));
        this.add(poleZeroPanel, "PoleZero");
        this.add(plotPanel, "Atenuation");
        this.add(stepPanel, "StepOrImpulse");
        cardLayout.show(this, "Atenuation");
    }

    public void recreateTemplate() {
        plotA.setDataset(0, createDatasetTemplate());
        updateAttenuationPlot();

        //Used to set default Axis
        double Aa = currentTemplate.getAa();
        double Ap = currentTemplate.getAp();

        XYItemRenderer renderer = plotA.getRenderer();
        renderer.setSeriesVisibleInLegend(0, false);
        renderer.setSeriesPaint(0, Color.RED);
        renderer.setSeriesPaint(1, Color.RED);
        renderer.setSeriesVisibleInLegend(1, false);
        currentTemplate = s.getUserData().getCurrentTemplate();
        if ( currentTemplate instanceof BandrejectTemplate || currentTemplate instanceof BandpassTemplate) {
            renderer.setSeriesVisibleInLegend(2, false);
            renderer.setSeriesPaint(2, Color.RED);
        }

        //Set Logarithmic axis
        ValueAxis xAxis = plotA.getDomainAxis();
        xAxis.setRange(wmin * 0.1, wmax * 10);
        ValueAxis yAxis = plotA.getRangeAxis();
        yAxis.setRange(-userData.getCurrentTemplate().getG(), 2*Aa - userData.getCurrentTemplate().getG());

        //Set 'y' default Axis
        plotA.setDomainAxis(xAxis);
        plotA.setRangeAxis(yAxis);

        cardLayout.show(this, "Atenuation");
        s1.getCheckBoxChoosePlot().setAtenuation();
    }

    public void updatePlot() {
        if (s1.getCheckBoxChoosePlot().getPolosCeros().isSelected()) {
            updatePoleZeroPlot();
        }
        else if (s1.getCheckBoxChoosePlot().getFase().isSelected()) {
            updatePhase();
        }
        else if (s1.getCheckBoxChoosePlot().getImpulse().isSelected()) {
            updateImpulse();
        }
        else if (s1.getCheckBoxChoosePlot().getStep().isSelected()) {
            updateStep();
        }
        else if (s1.getCheckBoxChoosePlot().getNormalizedTemplate().isSelected()) {
            updateNormalizedTemplate();
        }
        else {
            updateAttenuationPlot();
            cardLayout.show(this, "Atenuation");
        }
    }

    public void updateStep() {
        XYSeriesCollection dataset = new XYSeriesCollection();
        double[] temp = GenericUtils.linspace(0, 100 / wmin, 10000); //TODO: ese 100/wmin es mágico, habría que poner un tiempo significativo
        java.util.List<Approximation> approximationList = userData.getApproximationList();
        Approximation currentAprox;
        for (int i = 0; i < approximationList.size(); i++) {
            currentAprox = approximationList.get(i);
            TransferFunction TF = currentAprox.getTF();
            double[] step = TF.getStepResponse(temp);
            dataset = addStepOrImpulseSeriesToDataset(temp, step, currentAprox.getDetails(), dataset);
        }
        plotStepOrImpulse.setDataset(0, dataset);
        plotStepOrImpulse.setRenderer(0, new StandardXYItemRenderer());

        plotStepOrImpulse.setDataset(0, dataset);
        ValueAxis xAxis = plotStepOrImpulse.getDomainAxis();
        xAxis.setAutoRange(true);
        ValueAxis yAxis = plotStepOrImpulse.getRangeAxis();
        yAxis.setAutoRange(true);

        plotStepOrImpulse.setDomainAxis(xAxis);
        plotStepOrImpulse.setRangeAxis(yAxis);

        cardLayout.show(this, "StepOrImpulse");
    }
    public void updateImpulse(){
        XYSeriesCollection dataset = new XYSeriesCollection();
        double[] temp = GenericUtils.linspace(0, 100/wmin, 10000); //TODO: ese 100/wmin es mágico, habría que poner un tiempo significativo
        java.util.List<Approximation> approximationList = userData.getApproximationList();
        Approximation currentAprox;

        for (int i = 0; i < approximationList.size(); i++) {
            currentAprox = approximationList.get(i);
            TransferFunction TF = currentAprox.getTF();
            double[] step = TF.getImpulseResponse(temp);
            dataset = addStepOrImpulseSeriesToDataset(temp, step, currentAprox.getDetails(), dataset);
        }
        plotStepOrImpulse.setDataset(0, dataset);
        plotStepOrImpulse.setRenderer(0, new StandardXYItemRenderer());

        plotStepOrImpulse.setDataset(0, dataset);
        ValueAxis xAxis = plotStepOrImpulse.getDomainAxis();
        xAxis.setAutoRange(true);
        ValueAxis yAxis = plotStepOrImpulse.getRangeAxis();
        yAxis.setAutoRange(true);

        plotStepOrImpulse.setDomainAxis(xAxis);
        plotStepOrImpulse.setRangeAxis(yAxis);

        cardLayout.show(this, "StepOrImpulse");
    }
    public void updateAttenuationPlot() {
        XYSeriesCollection dataset = new XYSeriesCollection();
        double[] freq = GenericUtils.logspace(wmin * (0.1), wmax * 10, 10000);
        java.util.List<Approximation> approximationList = userData.getApproximationList();
        Approximation currentAprox;
        for (int i = 0; i < approximationList.size(); i++) {
            currentAprox = approximationList.get(i);
            TransferFunction TF = currentAprox.getTF();
            double[] modulo = TF.getModuleDB(freq);
            dataset = addAttenuationSeriesToDataset(freq, modulo, currentAprox.getDetails(), dataset);
        }
        plotA.setDataset(1, dataset);
        plotA.setRenderer(1, new StandardXYItemRenderer());
        //cardLayout.show(this, "Atenuation");
    }
    public void updatePhase() {
        plotA.setDataset(0, null);
        XYSeriesCollection dataset = new XYSeriesCollection();
        double[] freq = GenericUtils.logspace(wmin * (0.1), wmax * 10, 10000);
        java.util.List<Approximation> approximationList = userData.getApproximationList();
        Approximation currentAprox;
        for (int i = 0; i < approximationList.size(); i++) {
            currentAprox = approximationList.get(i);
            TransferFunction TF = currentAprox.getTF();
            double[] phase = TF.getPhase(freq);
            dataset = addPhaseSeriesToDataset(freq, phase, currentAprox.getDetails(), dataset);
        }
        plotA.setDataset(1, dataset);
        plotA.setRenderer(1, new StandardXYItemRenderer());

        //Set Logarithmic axis
        LogarithmicAxis xAxis = new LogarithmicAxis("Frequency");
        xAxis.setRange(wmin * 0.1, wmax * 10);
        ValueAxis yAxis = plotA.getRangeAxis();
        yAxis.setRange(-190, 190);   //TODO: 0 debe ser cambiado por ganancia

        //Set 'y' default Axis
        plotA.setDomainAxis(xAxis);
        plotA.setRangeAxis(yAxis);

        cardLayout.show(this, "Atenuation");
    }
    public void updatePoleZeroPlot() {
        XYSeriesCollection dataset = new XYSeriesCollection();

        for ( Approximation x : userData.getApproximationList()) {
            dataset = addPoleZeroSeriesToDataset(x, dataset);
        }
        plotPZ.setDataset(0, dataset);

        ValueAxis xAxis = plotPZ.getDomainAxis();
        xAxis.setAutoRange(true);
        ValueAxis yAxis = plotPZ.getRangeAxis();
        yAxis.setAutoRange(true);

        plotPZ.setDomainAxis(xAxis);
        plotPZ.setRangeAxis(yAxis);

        for (int i = 0; i < plotPZ.getSeriesCount(); i++) {
            if ( i % 2 == 1 ) {
                //plotPZ.getRenderer().setSeriesPaint(i, plotPZ.getRenderer().getSeriesPaint(i - 1));
                plotPZ.getRenderer().setSeriesShape(i, new Ellipse2D.Double(-3, -3, 6, 6));
            }
            else {
                plotPZ.getRenderer().setSeriesPaint(i+1, plotPZ.getRenderer().getSeriesPaint(i));
                plotPZ.getRenderer().setSeriesShape(i, cross);
            }
        }

        cardLayout.show(this, "PoleZero");
    }
    public void updateNormalizedTemplate() {
        plotA.setDataset(0, null);
        plotA.setDataset(1, null);

        plotA.setDataset(0, createDatasetNormalizedTemplate());

        XYSeriesCollection dataset = new XYSeriesCollection();
        double[] freq = GenericUtils.logspace(0.1, userData.getCurrentTemplate().getWan()*10, 10000);
        java.util.List<Approximation> approximationList = userData.getApproximationList();
        Approximation currentAprox;

        XYItemRenderer renderer = plotA.getRenderer();
        renderer.setSeriesVisibleInLegend(0, false);
        renderer.setSeriesPaint(0, Color.RED);
        renderer.setSeriesPaint(1, Color.RED);
        renderer.setSeriesVisibleInLegend(1, false);

        for (int i = 0; i < approximationList.size(); i++) {
            currentAprox = approximationList.get(i);
            TransferFunction TF = currentAprox.getNTF();
            double[] modulo = TF.getModuleDB(freq);
            dataset = addAttenuationSeriesToDataset(freq, modulo, currentAprox.getDetails(), dataset);
        }
        plotA.setDataset(1, dataset);
        plotA.setRenderer(1, new StandardXYItemRenderer());

        plotA.setDataset(1, dataset);
        //Set Logarithmic axis
        LogarithmicAxis xAxis = new LogarithmicAxis("Frequency");
        xAxis.setRange(0.1, userData.getCurrentTemplate().getWan()*10);
        double Aa = currentTemplate.getAa();
        ValueAxis yAxis = plotA.getRangeAxis();
        yAxis.setRange( 0, 2*Aa);

        //Set 'y' default Axis
        plotA.setDomainAxis(xAxis);
        plotA.setRangeAxis(yAxis);

        cardLayout.show(this, "Atenuation");
    }

    // This methods create the panel where the plot is... this runs only once (the cunstractor calls them)
    private JPanel createPoleZeroPanel() {
        XYSeriesCollection poleZeroDataset = createPoleZeroDataset();
        JFreeChart chart = ChartFactory.createScatterPlot("Poles/Zeros", "Real", "Imaginary", poleZeroDataset);

        //TODO: Falta agregar la configuración de los ejes y esas cosas
        plotPZ = chart.getXYPlot();

        return new ChartPanel(chart);
    }
    private JPanel createAttenuationPanel() {
        XYDataset datasetTemplate = createDatasetTemplate();
        JFreeChart chart = ChartFactory.createXYLineChart("", "Frequency [rad/seg]", "Atenuation [dB]", datasetTemplate);

        //Setup Color Background and grid
        plotA = chart.getXYPlot();
        plotA.setBackgroundPaint(Color.LIGHT_GRAY);
        plotA.setRangeGridlinePaint(Color.BLACK);
        plotA.setDomainGridlinePaint(Color.BLACK);

        updateAttenuationPlot();     //Agrego los filtros

        //Used to set default Axis
        double Aa = currentTemplate.getAa();
        double Ap = currentTemplate.getAp();

        //Set Logarithmic axis
        LogarithmicAxis xAxis = new LogarithmicAxis("Frequency");
        xAxis.setRange(wmin * 0.1, wmax * 10);
        ValueAxis yAxis = plotA.getRangeAxis();
        yAxis.setRange(-userData.getCurrentTemplate().getG(), 2*(Aa-currentTemplate.getG()));

        XYLineAndShapeRenderer renderer = (XYLineAndShapeRenderer) plotA.getRenderer();
        renderer.setSeriesVisibleInLegend(0, false);
        renderer.setSeriesPaint(0, Color.RED);
        //renderer.setSeriesPaint(1, Color.RED);
        renderer.setSeriesVisibleInLegend(1, false);
        //currentTemplate = s.getUserData().getCurrentTemplate();
        if ( currentTemplate instanceof BandrejectTemplate || currentTemplate instanceof BandpassTemplate) {
            renderer.setSeriesVisibleInLegend(2, false);
            renderer.setSeriesPaint(2, Color.RED);
        }

        //Set 'y' default Axis
        plotA.setDomainAxis(xAxis);
        plotA.setRangeAxis(yAxis);

        return new ChartPanel(chart);
    }
    private JPanel createStepPanel() {
        XYSeriesCollection stepDataset = createStepDataset();
        JFreeChart chart = ChartFactory.createXYLineChart("Step/Impulse Response", "Time", "Amplitude", stepDataset);

        plotStepOrImpulse = chart.getXYPlot();

        return new ChartPanel(chart);
    }

    // This methods creates (and updates) the right dataset with the userData information
    private XYDataset createDatasetTemplate() {
        currentTemplate = userData.getCurrentTemplate();
        XYSeriesCollection dataset = new XYSeriesCollection();
        double Aa = currentTemplate.getAa();
        double Ap = currentTemplate.getAp();
        double G = currentTemplate.getG();
        //Ap -= G;
        //Aa -= G;
        XYSeries series1 = new XYSeries("First");
        XYSeries series2 = new XYSeries("Second");
        XYSeries series3 = new XYSeries("Third");
        if (currentTemplate instanceof LowpassTemplate) {
            double wa = ((LowpassTemplate) currentTemplate).getWa();
            double wp = ((LowpassTemplate) currentTemplate).getWp();
            series1.add(wp*0.1, Ap-G);
            series1.add(wp, Ap-G);
            series1.add(wp, 2*Aa-G);
            series2.add(wa, -G);
            series2.add(wa, Aa-G);
            series2.add(wa*10, Aa-G);

            wmin = wp;
            wmax = wa;
        } else if (currentTemplate instanceof HighpassTemplate) {
            double wa = ((HighpassTemplate) currentTemplate).getWa();
            double wp = ((HighpassTemplate) currentTemplate).getWp();
            series1.add(wa*0.1, Aa-G);
            series1.add(wa, Aa-G);
            series1.add(wa, -G);
            series2.add(wp, 2*Aa-G);
            series2.add(wp, Ap-G);
            series2.add(wp*10, Ap-G);

            wmin = wa;
            wmax = wp;
        } else if (currentTemplate instanceof BandpassTemplate) {
            double wpp = ((BandpassTemplate) currentTemplate).getWpp();
            double wpm = ((BandpassTemplate) currentTemplate).getWpm();
            double wap = ((BandpassTemplate) currentTemplate).getWap();
            double wam = ((BandpassTemplate) currentTemplate).getWam();
            series1.add(wam*0.1, Aa-G);
            series1.add(wam, Aa-G);
            series1.add(wam, -G);
            series2.add(wpm, 2*Aa-G);
            series2.add(wpm, Ap-G);
            series2.add(wpp, Ap-G);
            series2.add(wpp, 2*Aa-G);
            series3.add(wap, -G);
            series3.add(wap, Aa-G);
            series3.add(wap*10, Aa-G);

            wmin = wam;
            wmax = wap;

            dataset.addSeries(series3);
        } else if (currentTemplate instanceof BandrejectTemplate) {
            double wpp = ((BandrejectTemplate) currentTemplate).getWpp();
            double wpm = ((BandrejectTemplate) currentTemplate).getWpm();
            double wap = ((BandrejectTemplate) currentTemplate).getWap();
            double wam = ((BandrejectTemplate) currentTemplate).getWam();

            series1.add(wpm*0.1, Ap-G);
            series1.add(wpm, Ap-G);
            series1.add(wpm, 2*Aa-G);
            series2.add(wam, -G);
            series2.add(wam, Aa-G);
            series2.add(wap, Aa-G);
            series2.add(wap, -G);
            series3.add(wpp, 2*Aa-G);
            series3.add(wpp, Ap-G);
            series3.add(wpp*10, Ap-G);

            wmin = wpm;
            wmax = wpp;

            dataset.addSeries(series3);
        }
        dataset.addSeries(series1);
        dataset.addSeries(series2);

        return dataset;
    }
    private XYDataset createDatasetNormalizedTemplate() {
        currentTemplate = userData.getCurrentTemplate();
        XYSeriesCollection dataset = new XYSeriesCollection();
        double Aa = currentTemplate.getAa();
        double Ap = currentTemplate.getAp();
        double wan = currentTemplate.getWan();
        XYSeries series1 = new XYSeries("First");
        XYSeries series2 = new XYSeries("Second");
        series1.add(0.1, Ap);
        series1.add(1, Ap);
        series1.add(1, 2*Aa);
        series2.add(wan, 0);
        series2.add(wan, Aa);
        series2.add(wan*10, Aa);

        dataset.addSeries(series1);
        dataset.addSeries(series2);

        return dataset;
    }
    private XYSeriesCollection createPoleZeroDataset() {
        XYSeriesCollection dataset = new XYSeriesCollection();

        for ( Approximation x : userData.getApproximationList()) {
            dataset = addPoleZeroSeriesToDataset(x, dataset);
        }
        return dataset;
    }
    private XYSeriesCollection createStepDataset() {
        XYSeriesCollection dataset = new XYSeriesCollection();
        return dataset;
    }

    private XYSeriesCollection addAttenuationSeriesToDataset(double[] freq, double[] modulo, String seriesName, XYSeriesCollection dataset) {
        XYSeries series = new XYSeries(seriesName);
        for (int i = 0; i < freq.length; i++) {
            series.add(freq[i], -modulo[i]);
        }
        dataset.addSeries(series);
        return dataset;
    }
    private XYSeriesCollection addPoleZeroSeriesToDataset(Approximation x, XYSeriesCollection dataset) {
        XYSeries zerosSeries = new XYSeries(x.getDetails() + " Zeros");
        Complex[] zerosArray = x.getTF().getZeros();
        for (int i = 0; i < zerosArray.length; i++) {
            zerosSeries.add(zerosArray[i].getReal(), zerosArray[i].getImaginary());
        }
        XYSeries polesSeries = new XYSeries(x.getDetails() + " Poles");
        Complex[] polesArray = x.getTF().getPoles();
        for (int i = 0; i < polesArray.length; i++) {
            polesSeries.add(polesArray[i].getReal(), polesArray[i].getImaginary());
//            double mod = Math.sqrt(Math.pow(polesArray[i].getReal(),2) + Math.pow(polesArray[i].getImaginary(),2));
//            XYShapeAnnotation unitCircle = new XYShapeAnnotation(new Ellipse2D.Double(-1, -1, 2*mod, 2*mod), new BasicStroke(1.0f, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER, 10.0f), Color.black);
//            plotPZ.addAnnotation(unitCircle);
        }
        dataset.addSeries(polesSeries);
        dataset.addSeries(zerosSeries);

        return dataset;
    }
    private XYSeriesCollection addStepOrImpulseSeriesToDataset(double[] temp, double[] step, String seriesName, XYSeriesCollection dataset) {
        XYSeries series = new XYSeries(seriesName);
        for (int i = 0; i < temp.length; i++) {
            series.add(temp[i], step[i]);
        }
        dataset.addSeries(series);
        return dataset;
    }
    private XYSeriesCollection addPhaseSeriesToDataset(double[] freq, double[] phase, String seriesName, XYSeriesCollection dataset) {
        XYSeries series = new XYSeries(seriesName);
        for (int i = 0; i < freq.length; i++) {
            series.add(freq[i], phase[i]*180/Math.PI);
        }
        dataset.addSeries(series);
        return dataset;
    }
}
</file>

<file path="Aproximaciones/src/firststage/Singleton_S1.java">
package firststage;

class Singleton_S1 {
    private static final Singleton_S1 INSTANCE = new Singleton_S1();
    private Singleton_S1() {}
    public static Singleton_S1 getInstance() {
        return INSTANCE;
    }

    private ApproxButton approxButton = null;
    private ApproxComboBox approxComboBox = null;
    private ApproximationPanel approximationPanel = null;
    private ApproxRadioButton approxRadioButton = null;
    private CheckBoxChoosePlot checkBoxChoosePlot = null;
    private ConfigAmplitudePanel configAmplitudePanel = null;
    private ConfigBandPassPanel configBandPassPanel = null;
    private ConfigBandRejectPanel configBandRejectPanel = null;
    private ConfigDelayPanel configDelayPanel = null;
    private ConfigHighPassPanel configHighPassPanel = null;
    private ConfigLowPassPanel configLowPassPanel = null;
    private ConfigPanel configPanel = null;
    private ConfigTemplatePanel configTemplatePanel = null;
    private DrawingPanel drawingPanel = null;
    private FilterList filterList = null;
    private ListButtonsPanel listButtonsPanel = null;
    private ListPanel listPanel = null;
    private PlotPlot plotPlot = null;
    private SliderDesnorm sliderDesnorm = null;

    public ApproxButton getApproxButton() {
        if (approxButton == null)
            approxButton = new ApproxButton();
        return approxButton;
    }
    public ApproxComboBox getApproxComboBox() {
        if (approxComboBox == null)
            approxComboBox = new ApproxComboBox();
        return approxComboBox;
    }
    public ApproximationPanel getApproximationPanel() {
        if (approximationPanel == null)
            approximationPanel = new ApproximationPanel();
        return approximationPanel;
    }
    public ApproxRadioButton getApproxRadioButton() {
        if (approxRadioButton == null)
            approxRadioButton = new ApproxRadioButton();
        return approxRadioButton;
    }
    public CheckBoxChoosePlot getCheckBoxChoosePlot() {
        if (checkBoxChoosePlot == null)
            checkBoxChoosePlot = new CheckBoxChoosePlot();
        return checkBoxChoosePlot;
    }
    public ConfigAmplitudePanel getConfigAmplitudePanel() {
        if (configAmplitudePanel == null)
            configAmplitudePanel = new ConfigAmplitudePanel();
        return configAmplitudePanel;
    }
    public ConfigBandPassPanel getConfigBandPassPanel() {
        if (configBandPassPanel == null)
            configBandPassPanel = new ConfigBandPassPanel();
        return configBandPassPanel;
    }
    public ConfigBandRejectPanel getConfigBandRejectPanel() {
        if (configBandRejectPanel == null)
            configBandRejectPanel = new ConfigBandRejectPanel();
        return configBandRejectPanel;
    }
    public ConfigDelayPanel getConfigDelayPanel() {
        if (configDelayPanel == null)
            configDelayPanel = new ConfigDelayPanel();
        return configDelayPanel;
    }
    public ConfigHighPassPanel getConfigHighPassPanel() {
        if (configHighPassPanel == null)
            configHighPassPanel = new ConfigHighPassPanel();
        return configHighPassPanel;
    }
    public ConfigLowPassPanel getConfigLowPassPanel() {
        if (configLowPassPanel == null)
            configLowPassPanel = new ConfigLowPassPanel();
        return configLowPassPanel;
    }
    public ConfigPanel getConfigPanel() {
        if (configPanel == null)
            configPanel = new ConfigPanel();
        return configPanel;
    }
    public ConfigTemplatePanel getConfigTemplatePanel() {
        if (configTemplatePanel == null)
            configTemplatePanel = new ConfigTemplatePanel();
        return configTemplatePanel;
    }
    public DrawingPanel getDrawingPanel() {
        if (drawingPanel == null)
            drawingPanel = new DrawingPanel();
        return drawingPanel;
    }
    public FilterList getFilterList() {
        if (filterList == null)
            filterList = new FilterList();
        return filterList;
    }
    public ListButtonsPanel getListButtonsPanel() {
        if (listButtonsPanel == null)
            listButtonsPanel = new ListButtonsPanel();
        return listButtonsPanel;
    }
    public ListPanel getListPanel() {
        if (listPanel == null)
            listPanel = new ListPanel();
        return listPanel;
    }
    public PlotPlot getPlotPlot() {
        if (plotPlot == null)
            plotPlot = new PlotPlot();
        return plotPlot;
    }
    public SliderDesnorm getSliderDesnorm() {
        if (sliderDesnorm == null)
            sliderDesnorm = new SliderDesnorm();
        return sliderDesnorm;
    }
}
</file>

<file path="Aproximaciones/src/firststage/SliderDesnorm.java">
package firststage;

import javax.swing.*;
import javax.swing.text.NumberFormatter;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.geom.Arc2D;
import java.text.ParseException;
import java.util.Hashtable;

class SliderDesnorm extends JPanel{
    private JSlider sliderDesnorm = new JSlider(JSlider.HORIZONTAL, 0, 20, 0);
    //private NumberFormatter formatter = new NumberFormatter();
//    JFormattedTextField textField;
    Hashtable labelTable = new Hashtable();

    public SliderDesnorm(){
        sliderDesnorm.setPaintTicks(true);
        sliderDesnorm.setMajorTickSpacing(2);
        sliderDesnorm.setMinorTickSpacing(1);

        //Sets the numbers displayed
        labelTable.put(0, new JLabel("0%"));
        labelTable.put(10, new JLabel("50%"));
        labelTable.put(20, new JLabel("100%"));
        sliderDesnorm.setLabelTable(labelTable);
        sliderDesnorm.setPaintLabels(true);

//        formatter.setMaximum(100);  //Formats the max and min value of the TextField
//        formatter.setMinimum(0);

        /*textField = new JFormattedTextField(formatter); //Makes an editable Text Field
        textField.setValue(0);
        textField.setColumns(5);    //Get some space*/
/*
        textField.addPropertyChangeListener(this);

       /* //Here I create a KeyBinding
        textField.getInputMap().put(KeyStroke.getKeyStroke(KeyEvent.VK_ENTER, 0), "check");
        textField.getActionMap().put("check", AbstractAction);
*/
        this.setLayout(new BoxLayout(this,BoxLayout.Y_AXIS));
        this.add(sliderDesnorm);
//        this.add(textField);
    }

    public double getSliderValue() {
        return ((double)sliderDesnorm.getValue())/20;
    }

    //TODO: QUE MIERDA ES ESTO?
/*    abstract class AbstractAction extends SliderDesnorm{

        public void acionPerformed(ActionEvent e) {
            if (!textField.isEditValid()) {     //The text is invalid
                Toolkit.getDefaultToolkit().beep();
                textField.selectAll();
            }
            else {
                try {
                    textField.commitEdit();
                } catch (ParseException exc) {}
            }
        }
    }*/
}
</file>

<file path="Aproximaciones/src/firststage/StageOnePanel.java">
package firststage;

import javax.swing.*;
import java.awt.*;

/*
*   Stage One is divided into two different big panels. One with all the configuration buttons and panels and another with the plotA
*/

public class StageOnePanel extends JPanel {
    private ConfigPanel configPanel;
    private DrawingPanel drawingPanel;

    public StageOnePanel() {
        this.setLayout(new BoxLayout(this, BoxLayout.X_AXIS));
        this.setBackground(Color.ORANGE);   //No se debería ver. Lo hago para darme cuenta si me queda corto algún panel o siempre lo cubro

        //Configuration Panel
        configPanel = new ConfigPanel();
        this.add(configPanel);

        //Plot Panel
        drawingPanel = new DrawingPanel();
        this.add(drawingPanel);
    }
}
</file>

<file path="Aproximaciones/src/mathematics/Approximation.java">
package mathematics;

import de.jtem.ellipticFunctions.Jacobi;
import org.apache.commons.math3.analysis.polynomials.PolynomialFunction;
import org.apache.commons.math3.complex.Complex;
import tclib.MathUtils;
import tclib.TransferFunction;
import tclib.templates.*;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class Approximation {
    private static final List<String> lowpassList = Arrays.asList("Butterworth", "Chebyshev I", "Chebyshev II", "Legendre", "Cauer", "Bessel");
    private static final List<String> highpassList = Arrays.asList("Butterworth", "Chebyshev I", "Chebyshev II", "Legendre", "Cauer");
    private static final List<String> bandpassList = Arrays.asList("Butterworth", "Chebyshev I", "Chebyshev II", "Legendre", "Cauer");
    private static final List<String> bandrejectList = Arrays.asList("Butterworth", "Chebyshev I", "Chebyshev II", "Legendre", "Cauer");
    private static final List<String> delayList = Arrays.asList("Bessel", "Gauss");

    //Este método lo llama el botón SetTemplate, y el constructor de esta clase.
    public static List<String> getStringsToComboBox(SuperTemplate template) {
        if (template instanceof LowpassTemplate)
            return lowpassList;
        else if (template instanceof HighpassTemplate)
            return highpassList;
        else if (template instanceof BandpassTemplate)
            return bandpassList;
        else if (template instanceof BandrejectTemplate)
            return bandrejectList;
        else if (template instanceof DelayTemplate)
            return delayList;
        else return lowpassList;
    }

//////////////////////////////////////////////////////////////////////////////////////////////////////

    private TransferFunction NTF;   //Normalized Transfer Function
    private TransferFunction TF;    //Denormalized Transfer Function
    private double maxQobtained;
    private int Order;
    private String Details;
    private String ApproxName;

    public String getDetails() { return Details; }
    public TransferFunction getNTF() { return NTF; }
    public TransferFunction getTF() { return TF; }
    public double getMaxQobtained() { return maxQobtained; }
    public int getOrder() { return Order; }
    public boolean equals(Approximation that) { return this.TF.equals(that.TF); }

    public Approximation(int index, SuperTemplate temp) { this(index, temp, 0, 0, 0); }
    public Approximation(int index, SuperTemplate temp, double denormPerc) { this(index, temp, denormPerc, 0, 0); }
    public Approximation(int index, SuperTemplate temp, double denormPerc, int setOrder) { this(index, temp, denormPerc, setOrder, 0); }
    public Approximation(int index, SuperTemplate temp, double denormPerc, int setOrder, double maxQ) {
        List<String> approxList = getStringsToComboBox(temp);
        boolean inverseDenormalization = false;
        int denormPrint = (int) (denormPerc * 100);
        if (approxList.get(index).equals("Butterworth")) {
            Butter(temp, setOrder, maxQ);
            ApproxName = "Butterworth";
        } else if (approxList.get(index).equals("Chebyshev I")) {
            Cheby1(temp, setOrder, maxQ);
            ApproxName = "Cheby 1";
        } else if (approxList.get(index).equals("Bessel")) {
            Bessel(temp, setOrder, maxQ);
            ApproxName = "Bessel";
        } else /*if (approxList.get(index).equals("Chebyshev II"))*/ {
            Cheby2(temp, setOrder, maxQ);
            ApproxName = "Cheby 2";
            inverseDenormalization = true;
            denormPerc = 1. - denormPerc;
        }
        double range = getDenormalizationRange(temp, inverseDenormalization);
        double denorm = Math.pow(range, denormPerc);
        TF = NTF.denormalize(temp, denorm);
        TF.multiply(Math.pow(10, temp.getG() / 20));
        Details = ApproxName + " / Order " + Order + " / Max Q: " + String.format("%.2f", maxQobtained) + " / " + denormPrint + "%";
    }

    private double NTFminusAp(double x, double Aa) {
        return -20 * Math.log10(NTF.evaluateApproximationAtOmega(x).abs()) - Aa;
    }

    private double getDenormalizationRange(SuperTemplate temp, boolean inverseDenormalization) {
        //By using the Bisection Method, it gets the frequency at which the approximation equals Aa.
        double Aa = temp.getAa() * 0.99999;    //Para evitar errores en los valles de Cauer y Cheby II.
        if (inverseDenormalization == true) Aa = temp.getAp() * 0.99999;
        double a = 1;   // 1 rad/s    Wp Normalizado.
        double b = temp.getWan();
        int sa = (int) Math.signum(NTFminusAp(a, Aa));
        int sb = (int) Math.signum(NTFminusAp(b, Aa));
        if (sa == sb)
            return 1;  //La función no cumple plantilla, por lo cual no acepta un corrimiento de desnormalización.
        double maxIter = 100000;
        double tol = Math.pow((b / a), 1. / 10000);
        for (int i = 0; i < maxIter; i++) {
            double c = Math.sqrt(a * b);
            int sc = (int) Math.signum(NTFminusAp(c, Aa));
            if (sc == sa)
                a = c;  //b = b;
            else
                b = c;  //a = a;
            if (b / a < tol)
                break;
        }
        if (inverseDenormalization == true) return 1. / Math.sqrt(a * b);
        else return temp.getWan() / Math.sqrt(a * b);
    }

    ////////////////////////////////////APPROXIMATIONS//////////////////////////////////////////////

    private void Butter(SuperTemplate temp, int setOrder, double maxQ) {
        double Ap = temp.getAp();
        double Aa = temp.getAa();
        double wan = temp.getWan();
        double eps = Math.sqrt(Math.pow(10, Ap / 10) - 1);

        this.Order = setOrder;
        if (maxQ > 0.5) {
            //<editor-fold defaultstate="collapsed" desc="Deduction of maxOrder given maxQ">
        /* MaxQobtained = 1 / 2sin(pi/2n) < MaxQ
           2sin(pi/2n) > 1/MaxQ
           sin(pi/2n) > 1/2MaxQ
           pi/2n > asin(1/2MaxQ)
           n < pi/2asin(1/2Q)
         */
            //</editor-fold>
            int maxOrder = (int) Math.floor(Math.PI / (2 * Math.asin(1. / (2 * maxQ))));
            if (setOrder == 0)
                this.Order = maxOrder;
            else this.Order = Math.min(setOrder, maxOrder);
        } else if (setOrder == 0)
            this.Order = (int) Math.ceil(Math.log10((Math.pow(10, Aa / 10) - 1) / (Math.pow(eps, 2))) / (2 * Math.log10(wan)));

        List<Complex> Poles = new ArrayList<>();

        double arg = Math.PI / 2 + Math.PI / (2 * this.Order);
        double module = Math.pow(1. / eps, 1. / this.Order);
        for (int i = 0; i < this.Order; i++) {
            double real = module * Math.cos(arg);
            double imag = module * Math.sin(arg);
            if (Math.abs(imag) < 10e-3) imag = 0;    //Floating point error correction.
            Poles.add(new Complex(real, imag));
            arg += Math.PI / this.Order;
        }
        Complex[] PolesArray = Poles.toArray(new Complex[Poles.size()]);
        Complex[] ZerosArray = new Complex[0];
        this.NTF = new TransferFunction(ZerosArray, PolesArray);
        this.maxQobtained = 1. / (2 * Math.sin(Math.PI / (2 * this.Order)));
    }

    private void Cheby1(SuperTemplate temp, int setOrder, double maxQ) {
        double Ap = temp.getAp();
        double Aa = temp.getAa();
        double wan = temp.getWan();

        double eps = Math.sqrt(Math.pow(10, Ap / 10) - 1);
        this.Order = setOrder;
        if (this.Order == 0)
            this.Order = (int) Math.ceil(MathUtils.acosh(Math.sqrt(Math.pow(10, Aa / 10) - 1) / eps) / MathUtils.acosh(wan));

        List<Complex> Poles = new ArrayList<>();
        double beta = (1. / this.Order) * MathUtils.asinh(1. / eps);

        for (int i = 0; i < this.Order; i++) {
            double alpha = Math.PI * ((2. * i + 1) / (2 * this.Order));
            double imag = Math.cos(alpha) * Math.cosh(beta);
            double real = -Math.sin(alpha) * Math.sinh(beta);
            if (Math.abs(imag) < 10e-3) imag = 0;   //Floating point error correction.
            Poles.add(new Complex(real, imag));
        }
        Complex[] PolesArray = Poles.toArray(new Complex[Poles.size()]);
        Complex[] ZerosArray = new Complex[0];
        this.NTF = new TransferFunction(ZerosArray, PolesArray);
        double origin = this.NTF.getModuleAtOrigin();
        if (this.Order % 2 == 0) origin /= Math.pow(10, -Ap / 20);
        this.NTF.multiply(1. / origin);

        this.maxQobtained = Math.abs(1. / (2. * Math.sin(PolesArray[0].getArgument() - Math.PI / 2)));
        if (maxQ > 0.5 && this.maxQobtained > maxQ)
            Cheby1(temp, this.Order - 1, maxQ);        //If maxQ is overflowed, retry with a minor order.
    }

    private void Cheby2(SuperTemplate temp, int setOrder, double maxQ) {
        double Ap = temp.getAp();
        double Aa = temp.getAa();
        double wan = temp.getWan();

        double eps = 1. / Math.sqrt(Math.pow(10, Aa / 10) - 1);
        this.Order = setOrder;
        if (this.Order == 0)
            this.Order = (int) Math.ceil(MathUtils.acosh(1. / (Math.sqrt(Math.pow(10, Ap / 10) - 1) * eps)) / MathUtils.acosh(wan));

        List<Complex> Poles = new ArrayList<>();
        List<Complex> Zeros = new ArrayList<>();
        double beta = Math.abs((1. / this.Order) * MathUtils.asinh(1. / eps));

        for (int i = 0; i < this.Order; i++) {
            double alpha = Math.PI * ((2. * i + 1) / (2 * this.Order));
            double imag = Math.cos(alpha) * Math.cosh(beta);
            double real = -Math.sin(alpha) * Math.sinh(beta);
            if (Math.abs(imag) < 10e-3) imag = 0;   //Floating point error correction.
            Poles.add(new Complex(real, imag).reciprocal().multiply(wan));
            if (2 * i + 1 != this.Order) //alpha != pi/2
                Zeros.add(new Complex(0, wan / Math.cos(alpha)));
        }
        Complex[] PolesArray = Poles.toArray(new Complex[Poles.size()]);
        Complex[] ZerosArray = Zeros.toArray(new Complex[Zeros.size()]);
        this.NTF = new TransferFunction(ZerosArray, PolesArray);
        double origin = this.NTF.getModuleAtOrigin();
        this.NTF.multiply(1. / origin);

        this.maxQobtained = Math.abs(1. / (2. * Math.sin(PolesArray[0].getArgument() - Math.PI / 2)));
        if (maxQ > 0.5 && this.maxQobtained > maxQ)
            Cheby2(temp, this.Order - 1, maxQ);        //If maxQ is overflowed, retry with a minor order.
    }

    private void Cauer(SuperTemplate temp, int setOrder, double maxQ){
        int i=0; //para el while, que sería el k del filtro
        double L=0;

        double Aa = temp.getAa();
        double Ap = temp.getAp();
        double Wan = temp.getWan();
        double OrdenImpuesto = 3;

        de.jtem.mfc.field.Complex zero = new de.jtem.mfc.field.Complex(0,0);
        de.jtem.mfc.field.Complex pole = new de.jtem.mfc.field.Complex(0,0);
        de.jtem.mfc.field.Complex j = new de.jtem.mfc.field.Complex(0,1);
        ArrayList zeros = new ArrayList<>();
        ArrayList poles = new ArrayList<>();

        double k1 = Math.sqrt((Math.pow(10, Ap/10)-1)/(Math.pow(10,Aa/10)-1));
        double k = 1/Wan;

        de.jtem.mfc.field.Complex a = new de.jtem.mfc.field.Complex(Math.sqrt(1-k1*k1),0);
        a = Jacobi.K_from_k(a);

        de.jtem.mfc.field.Complex b = new de.jtem.mfc.field.Complex(k,0);
        b = Jacobi.K_from_k(b);

        de.jtem.mfc.field.Complex c = new de.jtem.mfc.field.Complex(k1,0);
        c = Jacobi.K_from_k(c);

        de.jtem.mfc.field.Complex d = new de.jtem.mfc.field.Complex(Math.sqrt(1-k*k),0);
        d = Jacobi.K_from_k(d);

        double aRe = a.getRe();
        double bRe = b.getRe();
        double cRe = c.getRe();
        double dRe = d.getRe();
        double minOrder = Math.ceil((aRe/cRe)*(bRe/dRe));

        double gain = Math.pow(10,-Ap/20);

        //Dado un orden n
        i = 0;
        b.assign(i,0);
        d.assign(Math.sqrt(1-i*i),0);
        while((i < 1) && (OrdenImpuesto > ((a.getRe()/c.getRe())*(b.getRe()/d.getRe())))){
            b.assign(i,0);
            d.assign(Math.sqrt(1-i*i),0);
        }

        L=Math.ceil(OrdenImpuesto/2);   //ojo esto!!
        de.jtem.mfc.field.Complex u = new de.jtem.mfc.field.Complex((2*i-1)/OrdenImpuesto,0);

        for(i=1; i<L; i++) {
            u.assign((2 * i - 1) / OrdenImpuesto);      //Calculo ceros elipticos
            zero.assign(Jacobi.cn(u, b));
            zero.assignTimes(k);                        //Cuentas encesarias para llegar al cero desde los ceros elipticos
            zero.assignDivide(j, zero);
            zeros.add(i-1,zero);                        //Agrego al array
        }
    }


    private void Legendre(SuperTemplate temp, int setOrder, double maxQ) {}

    private void Bessel(SuperTemplate temp, int setOrder, double maxQ) {
        double Ap = temp.getAp();
        double Aa = temp.getAa();
        double wan = temp.getWan();

        TransferFunction finalTf = new TransferFunction(new double[]{1}, new double[]{1});
        PolynomialFunction besselNum;
        PolynomialFunction besselDen;
        double[] testArray = {0};
        int i = 0;
        if(setOrder>15){
            this.Order=15;
        } else {
            this.Order = setOrder;
        }

        if (this.Order == 0) {            //If the order is not specified,
            final int MAX_ORDER = 15;            //Setting maximum order at 15
            for (i = 1; i <= MAX_ORDER; i++) {
                besselDen = GetNOrderBesselTF(i);
                testArray[0] = besselDen.getCoefficients()[0];
                besselNum = new PolynomialFunction(testArray);
                finalTf = new TransferFunction(besselNum, besselDen);

                // 20*(Math.log10(finalTf.evaluateApproximationAtOmega(1).abs())) < Ap  esto se fija si cumple plantilla para fp
                // 20*(Math.log10(finalTf.evaluateApproximationAtOmega(wan).abs())) > Aa esto, si cumple en fa

                if ((20 * (Math.log10(finalTf.evaluateApproximationAtOmega(1).abs())) < Ap)
                        && (20 * (Math.log10(finalTf.evaluateApproximationAtOmega(wan).abs())) > Aa)) break;
            }
            if(i==MAX_ORDER+1){i=15;}
            this.Order = i;
            this.NTF = finalTf;
        } else {        //If the order is specified,
            besselDen = GetNOrderBesselTF(this.Order);
            testArray[0] = besselDen.getCoefficients()[0];
            besselNum = new PolynomialFunction(testArray);
            finalTf = new TransferFunction(besselNum, besselDen);
            this.NTF = finalTf;
        }

        Complex[] polos = this.NTF.getPoles();  //Esto puede causar problemas si el orden es 1.
        double midQ;
        for (i = 0; i < polos.length; i++) {
            midQ = Math.abs(1. / (2. * Math.cos(polos[i].getArgument())));
            this.maxQobtained = Math.max(this.maxQobtained, midQ);
        }

        if (maxQ > 0.5 && this.maxQobtained > maxQ)
            Bessel(temp, this.Order - 1, maxQ);        //If maxQ is overflowed, retry with a minor order.
    }

    private void Bessel(SuperTemplate temp, int setOrder, double maxQ, double delay, double psi) {/*
        //This Bessel aproximation function is the one that denormalizes using the group delay parameters

        //NAHUEL/AGUSTIN FALTA PEDIR UN W donde se quiere que finalize la tolerancia psi
        double Wgd = 20;
        double Wgdnorm = Wgd * delay;

        double[] relleno = {1};
        TransferFunction finalTf = new TransferFunction(relleno, relleno);
        PolynomialFunction besselNum;
        PolynomialFunction besselDen;
        double[] testArray = {0};
        this.Order = setOrder;
        if (this.Order == 0) {
            for (int i = 1; i <= 15; i++) {
                besselDen = GetNOrderBesselTF(i);
                testArray[0] = besselDen.getCoefficients()[0];
                besselNum = new PolynomialFunction(testArray);
                finalTf = new TransferFunction(besselNum, besselDen);
                //IF DEL RETARDO DE GRUPO
            }
        } else {
            besselDen = GetNOrderBesselTF(this.Order);
            testArray[0] = besselDen.getCoefficients()[0];
            besselNum = new PolynomialFunction(testArray);
            finalTf = new TransferFunction(besselNum, besselDen);
            this.NTF = finalTf;
        }*/
    }

    private PolynomialFunction GetNOrderBesselTF(int order) {
        if (order == 0) return new PolynomialFunction(new double[] {1});
        else if (order == 1) return new PolynomialFunction(new double[] {1, 1});
        else {
            double[] array = {2 * order - 1};
            double[] array2 = {0, 0, 1};
            /*Polinomios verdaderos de Bessel
            PolynomialFunction poly1 = (GetNOrderBesselTF(order - 1).multiply(new PolynomialFunction(array))).multiply(new PolynomialFunction(array2));
            PolynomialFunction poly2 = GetNOrderBesselTF(order - 2);
            */
            /*Polinomios inversos de Bessel*/
            PolynomialFunction poly1 = GetNOrderBesselTF(order - 1).multiply(new PolynomialFunction(array));
            PolynomialFunction poly2 = GetNOrderBesselTF(order - 2).multiply(new PolynomialFunction(array2));


            //La forumla es (2n-1)*x*Bn-1+Bn-2

            // o la otra que hay dando vueltas es (2*n-1)Bn-1+s^2*Bn-2
            return poly1.add(poly2);
        }
    }

    private void Gauss(SuperTemplate temp, int setOrder, double maxQ, double delay, double psi) {
/*        double[] testArray = {1};
        PolynomialFunction gaussDen;
        PolynomialFunction gaussNom = new PolynomialFunction(testArray);
        TransferFunction prueba;
        Complex[] polosPrueba;
        List<Complex> polosTransfer = new ArrayList<>();
        //Complex[] polosTrans, zerosTranf;
        this.Order = setOrder;
        int i = 0;
        int j = 0;
        if (this.Order == 0) {
            for (i = 1; i <= 10; i++) {
                int denOrder = 2 * i;
                double[] denominador = new double[denOrder + 1];
                denominador[0] = 1;
                for (j = 1; j <= denOrder; j++) {
                    if ((j % 2) == 1) {   //valores impares los coeficientes dan 0
                        denominador[j] = 0;
                        continue;
                    } else        // los valores pares dan (s^i)/(i/2)!
                        denominador[j] = Math.pow(delay, j) * (1. / (double) MathUtils.factorial((j / 2)));
                }
                //////////////barro todos los polos obtenidos y veo simplemente los de el semiplano izquierdo///////////////
                prueba = new TransferFunction(testArray, denominador);
                polosPrueba = prueba.getPoles();
                for (j = 0; j < polosPrueba.length; j++) {
                    if (polosPrueba[j].getReal() >= 0) continue;
                    else polosTransfer.add(polosPrueba[j]);
                }
                Complex[] PolesArray = polosTransfer.toArray(new Complex[polosTransfer.size()]);
                Complex[] ZerosArray = new Complex[0];
                this.NTF = new TransferFunction(ZerosArray, PolesArray); //Acá tengo la transferFunction

                if (CUMPLERETARDODEGRUPO) break;
            }
            this.Order = i;

        } else { // Si no me pasan el orden
            int denOrder = 2 * this.Order;
            double[] denominador = new double[denOrder + 1];
            denominador[0] = 1;
            for (i = 1; i <= denOrder; i++) {
                if ((i % 2) == 1) {   //valores impares los coeficientes dan 0
                    denominador[i] = 0;
                    continue;
                } else        // los valores pares dan (s^i)/(i/2)!
                    denominador[i] = Math.pow(delay, i) * (1. / (double) MathUtils.factorial((i / 2)));
            }
            //////////////barro todos los polos obtenidos y veo simplemente los de el semiplano izquierdo///////////////
            prueba = new TransferFunction(testArray, denominador);
            polosPrueba = prueba.getPoles();
            for (j = 0; j < polosPrueba.length; j++) {
                if (polosPrueba[j].getReal() >= 0) continue;
                else polosTransfer.add(polosPrueba[j]);
            }
            //Acá ya sacó los polos de la transferencia

            Complex[] PolesArray = polosTransfer.toArray(new Complex[polosTransfer.size()]);
            Complex[] ZerosArray = new Complex[0];
            this.NTF = new TransferFunction(ZerosArray, PolesArray);
            //Lo pase recien a TF
        }
*/    }
}
</file>

<file path="Aproximaciones/src/mathematics/Stage.java">
package mathematics;

import org.apache.commons.math3.complex.Complex;
import tclib.GenericUtils;
import tclib.TransferFunction;

import java.util.Arrays;
import java.util.List;

public class Stage {
    public static enum filterType {LOWPASS2, HIGHPASS2, BANDPASS, BANDREJ, LOWPASS1, HIGHPASS1 }
    private static final List<String> lowpass2List = Arrays.asList("LPAckerberg Mossberg", "LPFleischer Tow", "LPKerwin Huelsman Newcomb", "LPRauch", "LPSallen", "LPTow Thomas");
    private static final List<String> highpass2List = Arrays.asList("HPFleischer Tow", "HPKerwin Huelsman Newcomb", "HPRauch", "HPSallen");
    private static final List<String> bandpassList = Arrays.asList("BPAckerberg Mossberg", "BPFleischer Tow", "BPKerwin Huelsman Newcomb", "BPRauch", "BPSallen", "BPTow Thomas");
    private static final List<String> bandrejectList = Arrays.asList("BSAckerberg Mossberg", "BSFleischer Tow", "BSKerwin Huelsman Newcomb");
    private static final List<String> lowpass1List = Arrays.asList("LPRC");
    private static final List<String> highpass1List = Arrays.asList("HPRC");

    private filterType type;
    private Complex[] poles;
    private Complex[] zeros;
    private double gain;
    private TransferFunction TF;
    private String details;
    public Stage(TransferFunction TF) {
        this.TF = new TransferFunction(TF);
        this.poles = TF.getPoles();
        this.zeros = TF.getZeros();
        for ( int i = 0; i < poles.length; i++ ) {
            if ( i != 0 ) details = details + " + ";
            details = details + GenericUtils.getPZString(poles[i], true);
        }
        for ( Complex x : zeros ) {
            details = details + " + " + GenericUtils.getPZString(x, false);
        }
    }
    public Stage(Complex p1) { this(p1, Complex.INF, Complex.INF, Complex.INF, 1); }
    public Stage(Complex p1, Complex z1) { this(p1, z1, Complex.INF, Complex.INF, 1); }
    public Stage(Complex p1, Complex z1, Complex p2) { this(p1, z1, p2, Complex.INF, 1); }
    public Stage(Complex p1, Complex z1, Complex p2, Complex z2) { this(p1, z1, p2, z2, 1); }
    public Stage(Complex p1, Complex z1, Complex p2, Complex z2, double g) {
        boolean twoPoles = false, noZeros = false, singleZero = false, doubleOriginZeros = false;
        if(p2.isInfinite()) {
            if (p1.isInfinite())
                poles = new Complex[]{};
            else {
                if (p1.getImaginary() == 0)
                    poles = new Complex[]{p1};
                else {
                    poles = new Complex[]{p1, p1.conjugate()};
                    twoPoles = true;
                }
                details = GenericUtils.getPZString(p1, true);
            }
        }
        else if (p1.isInfinite()) {
            if (p2.getImaginary() == 0)
                poles = new Complex[]{p2};
            else {
                poles = new Complex[]{p2, p2.conjugate()};
                twoPoles = true;
            }
            details = GenericUtils.getPZString(p2, true);
        }
        else {
            poles = new Complex[]{p1, p2};
            details = GenericUtils.getPZString(p1, true) + " + " + GenericUtils.getPZString(p2, true);
            twoPoles = true;
        }

        if(z2.isInfinite()) {
            if (z1.isInfinite()) {
                zeros = new Complex[]{};
                noZeros = true;
            } else {
                if (z1.getImaginary() == 0) {
                    zeros = new Complex[]{z1};
                    singleZero = true;
                }
                else zeros = new Complex[]{z1, z1.conjugate()};
                details = details + " + " + GenericUtils.getPZString(z1, false);
                System.out.println(details);
            }
        }
        else if (z1.isInfinite()) {
            if (z2.getImaginary() == 0) {
                zeros = new Complex[]{z2};
                singleZero = true;
            }
            else zeros = new Complex[]{z2, z2.conjugate()};
            details = details + " + " + GenericUtils.getPZString(z2, false);
        }
        else if (z1.abs() == 0 && z2.abs() == 0) {
            zeros = new Complex[]{z1, z2};
            doubleOriginZeros = true;
            details = details + " + " + GenericUtils.getPZString(z1, false) + " + " + GenericUtils.getPZString(z1.conjugate(), false);
        } else {
            zeros = new Complex[]{z1, z1.conjugate()};
            details = details + " + " + GenericUtils.getPZString(z1, false) + " + " + GenericUtils.getPZString(z1.conjugate(), false);
        }
        TF = new TransferFunction(zeros, poles);
        setG(g);

        if(twoPoles) {
            if(noZeros) type = filterType.LOWPASS2;
            else if(singleZero) type = filterType.BANDPASS;
            else if(doubleOriginZeros) type = filterType.HIGHPASS2;
            else type = filterType.BANDREJ;
        } else {
            if(noZeros) type = filterType.LOWPASS1;
            else type = filterType.HIGHPASS1;
        }
    }

    private double getG() {
        double wp;
        double[] denom = TF.getDenominatorCopy().getCoefficients();
        if(denom.length == 3)
            wp = Math.sqrt(denom[0]/denom[2]);
        else if(denom.length == 2)
            wp = denom[0] / denom[1];
        else return 0;

        double[] numer = TF.getNumeratorCopy().getCoefficients();
        if(numer.length == 1)
            return numer[0] / (denom[denom.length-1]) / Math.pow(wp,denom.length-1);
        else if(numer.length == 2) {
            System.out.println(numer[1] / (wp * denom[denom.length - 1]));
            return numer[1] / (denom[denom.length-1])/Math.pow(wp,denom.length-2);
        }
        else if(numer.length == 3)
            return numer[2]/denom[denom.length-1];
        else return 0;
    }

    public void setG(double newG) {
        double g = getG();
        TF.multiply(newG/g);
    }
    public double getQ() { return GenericUtils.getQ(poles[0]); }
    public double getGdB() { return 20.*Math.log10(getG()); }
    public TransferFunction getTF() { return TF; }
    public String getDetails() { return details; }
    public Complex[] getZeros() { return zeros; }
    public Complex[] getPoles() { return poles; }
    public filterType getType() { return type; }
    public List<String> getList() {
        if(type == filterType.LOWPASS2) return lowpass2List;
        else if(type == filterType.HIGHPASS2) return highpass2List;
        else if(type == filterType.BANDPASS) return bandpassList;
        else if(type == filterType.BANDREJ) return bandrejectList;
        else if(type == filterType.LOWPASS1) return lowpass1List;
        else return highpass1List;
    }
}
</file>

<file path="Aproximaciones/src/mathematics/StageDisposition.java">
package mathematics;

import Data.Singleton;
import tclib.GenericUtils;
import tclib.MathUtils;
import tclib.TransferFunction;
import tclib.templates.*;

import java.util.ArrayList;
import java.util.List;

public class StageDisposition {
    private List<Stage> stageList;
    private double DRL = 0;
    public List<Stage> getStageList() { return stageList; };

    public StageDisposition() { this(new ArrayList<>()); }
    public StageDisposition(List<Stage> stages) { stageList = stages; }

    public void gainCorrection() {
        if(stageList.size() == 0) return;
        SuperTemplate temp = Singleton.getInstance().getUserData().getCurrentTemplate();
        double wEval = temp.getBand()[0];

        TransferFunction finalTF = new TransferFunction(Singleton.getInstance().getUserData().getTransferFunction());
        TransferFunction acumTF = new TransferFunction(stageList.get(0).getTF());
        for(int i = 1; i < stageList.size(); i++)
            acumTF.multiply(stageList.get(i).getTF());

        double correction = finalTF.evaluateApproximationAtOmega(wEval).abs()
                / acumTF.evaluateApproximationAtOmega(wEval).abs();
 //       System.out.println("WEval: " + wEval + "  finalTF: " + finalTF.evaluateApproximationAtOmega(wEval).abs()
 //       + "  acumTF: " + acumTF.evaluateApproximationAtOmega(wEval).abs());
        stageList.get(0).getTF().multiply(correction);
    }

    public void minimizeDRL(){
        if(stageList.size() == 0) return;

        double lowestDRL = 1000;
        double bandRange[] = Singleton.getInstance().getUserData().getCurrentTemplate().getBand();
        List<TransferFunction> bestTFList =  new ArrayList<>();
        List<TransferFunction> sortedTFList = new ArrayList<>();
        List<TransferFunction> acumTFList =  new ArrayList<>();

        int permutations[][] = MathUtils.getAllPermutations(stageList.size());
        for(int[] x : permutations) {
            for(int i : x) sortedTFList.add(new TransferFunction(stageList.get(i).getTF()));
//            for(int i = 0; i<stageList.size(); i++) sortedTFList.add(new TransferFunction(stageList.get(i).getTF()));////////////////Debuging

            acumTFList.add(new TransferFunction(sortedTFList.get(0)));
            for(int i = 1; i < sortedTFList.size(); i++){
                TransferFunction nextTF = new TransferFunction(acumTFList.get(i-1));
                nextTF.multiply(sortedTFList.get(i));
                acumTFList.add(nextTF);
            }
            SuperTemplate temp = Singleton.getInstance().getUserData().getCurrentTemplate();
            double wMax = temp.getWmax();
            double wMin = temp.getWmin();
//        System.out.println("wMin: " + wMin + "  wMax: " + wMax);
            double auxW = getMaxGainFreq(sortedTFList.get(0), wMin / 100, wMax * 100);
//        System.out.println("maxGainFreq: " + auxW);
            double prevAcumStageMax = sortedTFList.get(0).evaluateApproximationAtOmega(auxW).abs();
            for (int k = 1; k < sortedTFList.size(); k++) {
                auxW = getMaxGainFreq(acumTFList.get(k), wMin/100, wMax*100);
//            System.out.println("maxGainFreq: " + auxW);
                double nextAcumStageMax = acumTFList.get(k).evaluateApproximationAtOmega(auxW).abs();
                double correction = prevAcumStageMax/nextAcumStageMax;
                sortedTFList.get(k).multiply(correction);
                sortedTFList.get(0).multiply(1./correction);
//            System.out.println("prevAcumStageMax: " + prevAcumStageMax);
//            System.out.println("nextAcumStageMax: " + nextAcumStageMax);
                prevAcumStageMax = nextAcumStageMax;
            }

            double newDRL = GenericUtils.dynamicRangeLoss(sortedTFList, bandRange[0], bandRange[1], 12345);
            if(bandRange.length == 4)
                newDRL = Math.max(auxW,GenericUtils.dynamicRangeLoss(sortedTFList, bandRange[2], bandRange[3], 12345));

//            System.out.println("newDRL: " + 20.*Math.log10(newDRL) + "  " + newDRL);
            if(newDRL < lowestDRL){
                lowestDRL = newDRL;
                bestTFList = new ArrayList<>(sortedTFList);
            }
            sortedTFList.clear();
            acumTFList.clear();
        }
        this.DRL = lowestDRL;
        this.stageList.clear();
        for(TransferFunction x : bestTFList)
            this.stageList.add(new Stage(x));
    }

    public double getDRL() { return this.DRL; }
    private double getMaxGainFreq(TransferFunction TF, double wMin, double wMax){
        int pointsQuantity = (int)(Math.log10(wMax/wMin)*100);  //Evalúo 100 puntos por década.
        double freq[] = GenericUtils.logspace(wMin,wMax,pointsQuantity);
        double module[] = TF.getModule(freq);

        double min = module[0];
        int minFreqIndex = 0;
        for (int i = 1; i < module.length; i++) {
            if (module[i] < min) {
                min = module[i];
                minFreqIndex = i;
            }
        }
//        System.out.println("getMaxGainFreq. wMin: " + wMin + " wMax: " + wMax + " Points: " + pointsQuantity);
//        System.out.println("getMaxGainFreq. module.length: " + module.length + " module[0]: " + module[0]
//        + " module[fin]: " + module[module.length-1] + " module[mid]: " + module[module.length/2] + " min: " + min + " index: " + minFreqIndex);

        if (minFreqIndex == 0)
            return wMin*1e-6;
        else if (minFreqIndex == freq.length-1)
            return wMax*1e6;
        else return MathUtils.gss(TF, freq[minFreqIndex - 1], freq[minFreqIndex + 1], 1e-2);
    }
}
</file>

<file path="Aproximaciones/src/secondstage/FilterMode.java">
package secondstage;

import Data.Singleton;

import javax.swing.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

/**
 * Created by NEGU on 10/11/2015.
 */
public class FilterMode extends JPanel{
    JButton showHoleFilterButton;
    JLabel lossDynamicRange = new JLabel("Loss Dynamic Range (LDR): ");

    FilterMode() {
        Singleton s = Singleton.getInstance();
        Singleton_S2 s2 = Singleton_S2.getInstance();

        showHoleFilterButton = new JButton("Show Accumulated Stages");

        this.setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
        this.setBorder(BorderFactory.createTitledBorder("Accumulated Stages"));

        showHoleFilterButton.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                s2.getPlotStagePanel().updatePlot();
            }
        });

        // Lo de Nahuel
        JButton b = new JButton("Minimize DRL");
        this.add(b);
        b.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                Singleton.getInstance().getUserData().getStageDisposition().gainCorrection();
                Singleton.getInstance().getUserData().getStageDisposition().minimizeDRL();
                Singleton_S2.getInstance().getPlotStagePanel().updatePlot();
                updateLDR();
                //                System.out.println(GenericUtils.dynamicRangeLoss(Singleton.getInstance().getUserData().getStageList(),100,1000));
            }
        });
        /////////////////////////////////////////////////////////////////////////

        //this.add(showHoleFilterButton);
        this.add(lossDynamicRange);
    }

    public void updateLDR() {
        lossDynamicRange.setText("Loss Dynamic Range (LDR): " + Singleton.getInstance().getUserData().getStageDisposition().getDRL());     //Luewgo agregarle + lo que me pase nahuel
    }
}
</file>

<file path="Aproximaciones/src/secondstage/PlotPoleZeroPanel.java">
package secondstage;

import Data.Singleton;
import org.apache.commons.math3.complex.Complex;
import org.jfree.chart.ChartFactory;
import org.jfree.chart.ChartPanel;
import org.jfree.chart.JFreeChart;
import org.jfree.chart.axis.ValueAxis;
import org.jfree.chart.plot.XYPlot;
import org.jfree.chart.renderer.xy.XYItemRenderer;
import org.jfree.chart.renderer.xy.XYLineAndShapeRenderer;
import org.jfree.data.xy.XYSeries;
import org.jfree.data.xy.XYSeriesCollection;
import mathematics.Stage;
import org.jfree.util.ShapeUtilities;

import java.awt.geom.Ellipse2D;
import java.lang.reflect.Array;
import java.util.Arrays;
import java.util.List;
import java.util.List.*;
import javax.swing.*;
import java.awt.*;

/**
 * Created by NEGU on 8/11/2015.
 */
public class PlotPoleZeroPanel extends JPanel {
    Singleton s = Singleton.getInstance();
    XYPlot plotPZ;

    public PlotPoleZeroPanel() {
        this.setMaximumSize(new Dimension(400, 400));
        this.setMinimumSize(new Dimension(400, 400));
        this.setPreferredSize(new Dimension(400, 400));

        XYSeriesCollection poleZeroDataset = createPoleZeroDataset();
        JFreeChart chart = ChartFactory.createScatterPlot("Poles/Zeros", "Real", "Imaginary", poleZeroDataset);

        //TODO: Falta agregar la configuración de los ejes y esas cosas
        plotPZ = chart.getXYPlot();
        JPanel chartPanel = new ChartPanel(chart);

        //Setup layout
        this.setBorder(BorderFactory.createTitledBorder("PoleZeroPlot"));
        GroupLayout layout = new GroupLayout(this);
        this.setLayout(layout);
        layout.setAutoCreateGaps(true);
        layout.setAutoCreateContainerGaps(true);

        layout.setHorizontalGroup(
                layout.createParallelGroup(GroupLayout.Alignment.CENTER)
                        .addComponent(chartPanel)
        );
        layout.setVerticalGroup(
                layout.createSequentialGroup()
                        .addComponent(chartPanel)
        );

        updatePoleZeroPlot();
        updatePoleZeroColour();
    }

    public void updatePoleZeroPlot() { plotPZ.setDataset(0, createPoleZeroDataset()); }
    public void updatePoleZeroColour() {
        XYLineAndShapeRenderer renderer = (XYLineAndShapeRenderer)plotPZ.getRenderer();
        renderer.setSeriesPaint(0, Color.BLACK);
        renderer.setSeriesPaint(1, Color.BLACK);

        Shape cross = ShapeUtilities.createDiagonalCross(3, (float) 0.3);
        for (int i = 0; i < plotPZ.getSeriesCount(); i++) {
            if ( i % 2 == 1 ) {
                //plotPZ.getRenderer().setSeriesPaint(i, plotPZ.getRenderer().getSeriesPaint(i - 1));
                plotPZ.getRenderer().setSeriesShape(i, new Ellipse2D.Double(-3, -3, 6, 6));
            }
            else {
                plotPZ.getRenderer().setSeriesPaint(i+1, plotPZ.getRenderer().getSeriesPaint(i));
                plotPZ.getRenderer().setSeriesShape(i, cross);
            }
        }

        if ( maxDoubleHigh() != 0 && maxDoubleWidth() != 0 ) {
            ValueAxis xAxis = plotPZ.getDomainAxis();
            xAxis.setRange(maxDoubleWidth()*1.1, -maxDoubleWidth()*0.1);
            ValueAxis yAxis = plotPZ.getRangeAxis();
            yAxis.setRange(-maxDoubleHigh()*1.1, maxDoubleHigh()*1.1);
            plotPZ.setDomainAxis(xAxis);
            plotPZ.setRenderer(renderer);
        }
    }

    private XYSeriesCollection createPoleZeroDataset() {
        XYSeriesCollection dataset = new XYSeriesCollection();
        String stringName;

        stringName = "Unmatched Poles";
        dataset = addPointsSeriesToDataset(s.getUserData().getUnmatchedPoles(), dataset, stringName);
        stringName = "Unmatched Zeros";
        dataset = addPointsSeriesToDataset(s.getUserData().getUnmatchedZeros(), dataset, stringName);
        stringName = "Stage ";
        List<Stage> myStageList = s.getUserData().getStageList();
        for (int i = 0; i < myStageList.size(); i++) {
            dataset = addPointsSeriesToDataset(Arrays.asList(myStageList.get(i).getPoles()), dataset, stringName + i +" Poles");
            dataset = addPointsSeriesToDataset(Arrays.asList(myStageList.get(i).getZeros()), dataset, stringName + i + " Zeros");
        }
        return dataset;
    }

    private XYSeriesCollection addPointsSeriesToDataset(List<Complex> complexList, XYSeriesCollection dataset, String stringName) {
        XYSeries series = new XYSeries(stringName);
        if (!complexList.isEmpty() ) {
            for (Complex x : complexList) {
                series.add(x.getReal(), x.getImaginary());
                series.add(x.getReal(), -x.getImaginary());
            }
        }
        dataset.addSeries(series);

        return dataset;
    }

    double maxDoubleHigh() {
        double max = 0;
        List<Complex> currentPolesList = s.getUserData().getUnmatchedPoles();
        for ( int i = 0; i < currentPolesList.size(); i++) {
            if ( currentPolesList.get(i).getImaginary() > max ) {
                max = currentPolesList.get(i).getImaginary();
            }
        }
        List<Complex> currentZeroList = s.getUserData().getUnmatchedPoles();
        for ( int i = 0; i < currentZeroList.size(); i++) {
            if ( currentZeroList.get(i).getImaginary() > max ) {
                max = currentZeroList.get(i).getImaginary();
            }
        }
        List<Stage> selectedPolesList = s.getUserData().getStageList();
        for ( Stage x : selectedPolesList) {
            for ( Complex c : x.getPoles()) {
                if ( c.getImaginary() > max) {
                    max = c.getImaginary();
                }
            }
        }
        return max;
    }
    double maxDoubleWidth() {
        double max = 0;
        List<Complex> currentPolesList = s.getUserData().getUnmatchedPoles();
        for ( int i = 0; i < currentPolesList.size(); i++) {
            if ( currentPolesList.get(i).getReal() < max ) {
                max = currentPolesList.get(i).getReal();
            }
        }
        List<Stage> selectedPolesList = s.getUserData().getStageList();
        for ( Stage x : selectedPolesList) {
            for ( Complex c : x.getPoles()) {
                if ( c.getReal() < max) {
                    max = c.getReal();
                }
            }
        }
        return max;
    }
}
</file>

<file path="Aproximaciones/src/secondstage/PlotStagePanel.java">
package secondstage;

import Data.Singleton;
import mathematics.Stage;
import org.jfree.chart.ChartFactory;
import org.jfree.chart.ChartPanel;
import org.jfree.chart.JFreeChart;
import org.jfree.chart.axis.LogarithmicAxis;
import org.jfree.chart.axis.ValueAxis;
import org.jfree.chart.plot.XYPlot;
import org.jfree.data.xy.XYSeries;
import org.jfree.data.xy.XYSeriesCollection;
import tclib.GenericUtils;
import tclib.TransferFunction;
import tclib.templates.*;

import java.util.ArrayList;
import java.util.List;
import javax.swing.*;
import java.awt.*;

/**
 * Created by NEGU on 10/11/2015.
 */
public class PlotStagePanel extends JPanel {
    XYPlot plot;
    JPanel plotPanel;

    PlotStagePanel() {
        this.setBorder(BorderFactory.createTitledBorder("Stages Visualizer"));
        plotPanel = createPanel();

        //Setup layout
        GroupLayout layout = new GroupLayout(this);
        this.setLayout(layout);
        layout.setAutoCreateGaps(true);
        layout.setAutoCreateContainerGaps(true);

        layout.setHorizontalGroup(
                layout.createParallelGroup(GroupLayout.Alignment.CENTER)
                        .addComponent(plotPanel)
        );
        layout.setVerticalGroup(
                layout.createSequentialGroup()
                        .addComponent(plotPanel)
        );
    }

    private JPanel createPanel() {
        Singleton s = Singleton.getInstance();
        SuperTemplate currentTemplate = s.getUserData().getCurrentTemplate();
        XYSeriesCollection dataset = new XYSeriesCollection();
        JFreeChart chart = ChartFactory.createXYLineChart("", "Frequency [rad/seg]", "Atenuation [dB]", dataset);

        //Setup Color Background and grid
        plot = chart.getXYPlot();
        plot.setBackgroundPaint(Color.LIGHT_GRAY);
        plot.setRangeGridlinePaint(Color.BLACK);
        plot.setDomainGridlinePaint(Color.BLACK);

        //Used to set default Axis
        double Aa = currentTemplate.getAa();
        double Ap = currentTemplate.getAp();

        double wmin = currentTemplate.getWmin();
        double wmax = currentTemplate.getWmax();
        //Set Logarithmic axis
        LogarithmicAxis xAxis = new LogarithmicAxis("Frequency");
        xAxis.setRange(wmin * 0.1, wmax * 10);
        ValueAxis yAxis = plot.getRangeAxis();
        yAxis.setRange(-currentTemplate.getG(), 2*(Aa-currentTemplate.getG()));

        //Set 'y' default Axis
        plot.setDomainAxis(xAxis);
        plot.setRangeAxis(yAxis);

        return new ChartPanel(chart);
    }

    public void updatePlot() {
        Singleton_S2 s2 = Singleton_S2.getInstance();
        Singleton s = Singleton.getInstance();
        plot.setDataset(0, null);

        if (!s.getUserData().getStageList().isEmpty()) {
            List<TransferFunction> myTFList = new ArrayList<>();
            for (Stage x : s.getUserData().getStageList()) {
                myTFList.add( new TransferFunction(x.getTF()));
            }
            if ( s2.getstagePlotModePanel().getSingleModeRadioButton().isSelected() ) {
                s2.getPlotStagePanel().updatePlot(myTFList, s2.getPoleZeroListsPanel().getStagesListIndex());
            }
            else if ( s2.getstagePlotModePanel().getMultipleModeRadioButton().isSelected() ) {
                s2.getPlotStagePanel().updatePlot(myTFList, -1);
            }
            else if ( s2.getstagePlotModePanel().getCumModeRadioButton().isSelected() ){
                //myTFList.clear();
                List<TransferFunction> acumTFList =  new ArrayList<>();
                acumTFList.add(new TransferFunction(myTFList.get(0)));
                for(int i = 1; i < myTFList.size(); i++){
                    TransferFunction nextTF = new TransferFunction(acumTFList.get(i-1));
                    nextTF.multiply(myTFList.get(i));
                    acumTFList.add(nextTF);
                }
                s2.getPlotStagePanel().updatePlot(acumTFList, -1);
            }
            else {
                List<TransferFunction> acumTFList =  new ArrayList<>();
                acumTFList.add(new TransferFunction(myTFList.get(0)));
                for(int i = 1; i < myTFList.size(); i++){
                    TransferFunction nextTF = new TransferFunction(acumTFList.get(i-1));
                    nextTF.multiply(myTFList.get(i));
                    acumTFList.add(nextTF);
                }
                s2.getPlotStagePanel().updatePlot(acumTFList, acumTFList.size()-1);
            }
        }
    }
    private void updatePlot(List<TransferFunction> myTFList, int Index) {
        plot.setDataset(0, null);
        if (!myTFList.isEmpty()) {
            Singleton s = Singleton.getInstance();
            SuperTemplate currentTemplate = s.getUserData().getCurrentTemplate();
            XYSeriesCollection dataset = new XYSeriesCollection();
            if ( Index == -1) {
                dataset = createDataset(myTFList);
            }
            else {
                dataset = createDataset(myTFList, Index, dataset);
            }

            plot.setDataset(0, dataset);

            //Used to set default Axis
            double Aa = currentTemplate.getAa();
            double Ap = currentTemplate.getAp();

            double wmin = currentTemplate.getWmin();
            double wmax = currentTemplate.getWmax();
            //Set Logarithmic axis
            LogarithmicAxis xAxis = new LogarithmicAxis("Frequency");
            xAxis.setRange(wmin * 0.1, wmax * 10);
            //ValueAxis yAxis = plot.getRangeAxis();
            //yAxis.setRange(-currentTemplate.getG(), 2*Aa-currentTemplate.getG());

            //Set 'y' default Axis
            plot.setDomainAxis(xAxis);
            //plot.setRangeAxis(yAxis);
        }
    }

    private XYSeriesCollection createDataset(List < TransferFunction > myTFList) {
        XYSeriesCollection dataset = new XYSeriesCollection();
        for (int i = 0; i < myTFList.size(); i++) {
            dataset = createDataset(myTFList, i, dataset);
        }
        return dataset;
    }
    private XYSeriesCollection createDataset(List < TransferFunction > myTFList, int index, XYSeriesCollection dataset) {
        Singleton s = Singleton.getInstance();
        SuperTemplate currentTemplate = s.getUserData().getCurrentTemplate();
        double wmin = currentTemplate.getWmin();
        double wmax = currentTemplate.getWmax();

        double[] freq = GenericUtils.logspace(wmin*0.1, wmax*10, 10000);
        double[] module = myTFList.get(index).getModuleDB(freq);

        XYSeries series = new XYSeries("Stage" + index);
        for (int i = 0; i < freq.length; i++) {
            series.add(freq[i], -module[i]);
        }
        dataset.addSeries(series);
        return dataset;
    }
}
</file>

<file path="Aproximaciones/src/secondstage/PoleZeroListsPanel.java">
package secondstage;

import Data.Singleton;
import mathematics.Stage;
import org.apache.commons.math3.complex.Complex;
import tclib.GenericUtils;

import javax.swing.*;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.List;

/**
 * Created by NEGU on 8/11/2015.
 */
public class PoleZeroListsPanel extends JPanel {
    Singleton s = Singleton.getInstance();
    GenericUtils genericUtils = new GenericUtils();
    //Lists and Models
    private DefaultListModel<String> polesListModel = new DefaultListModel<>();
    private JList<String> unmatchedPolesList = new JList<>(polesListModel);
    private DefaultListModel<String> zerosListModel = new DefaultListModel<>();
    private JList<String> unmatchedZeroList = new JList<>(zerosListModel);
    private DefaultListModel<String> stagesListModel = new DefaultListModel<>();
    private JList<String> stagesList = new JList<>(stagesListModel);
    //Buttons
    private JButton selectGroupButton = new JButton("Create Stage");
    private JButton automaticSelectionButton = new JButton("Automatic Selection");
    private JButton deleteStageButton = new JButton("Delete Stage");
    private JButton deleteAllStagesButton = new JButton("Delete All Stages");

    int joker;      //This is used to know if I have to use all zeros twice or not

    public PoleZeroListsPanel() {
        Singleton_S2 s2 = Singleton_S2.getInstance();
        //Only one string can be selected at the same time
        unmatchedPolesList.setSelectionModel(new MySelectionModel(unmatchedZeroList, 2));
        unmatchedZeroList.setSelectionModel(new MySelectionModel(unmatchedZeroList, 2));
        stagesList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
        //List Layout Orientation
        unmatchedPolesList.setLayoutOrientation(JList.VERTICAL);
        unmatchedZeroList.setLayoutOrientation(JList.VERTICAL);
        stagesList.setLayoutOrientation(JList.VERTICAL);
        //Maximum Row Count
        unmatchedPolesList.setVisibleRowCount(5);
        unmatchedZeroList.setVisibleRowCount(5);
        stagesList.setVisibleRowCount(5);
        //Create Scrollers
        JScrollPane unmatchedPolesListScroller = new JScrollPane(unmatchedPolesList);
        JScrollPane unmatchedZeroListScroller = new JScrollPane(unmatchedZeroList);
        JScrollPane stagesListScroller = new JScrollPane(stagesList);

        selectGroupButton.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                matchPolesZeros();
                s2.getPlotStagePanel().updatePlot();
                s2.getPlotPoleZeroPanel().updatePoleZeroPlot();
                s2.getPlotPoleZeroPanel().updatePoleZeroColour();
                s2.getPlotPoleZeroPanel().updatePoleZeroColour();
            }
        });
        automaticSelectionButton.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                automaticSelection();
                s2.getPlotStagePanel().updatePlot();
                s2.getPlotPoleZeroPanel().updatePoleZeroPlot();
                s2.getPlotPoleZeroPanel().updatePoleZeroColour();
                s2.getPlotPoleZeroPanel().updatePoleZeroColour();
            }
        });
        deleteStageButton.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                deleteStage(stagesList.getSelectedIndex());
            }
        });
        deleteAllStagesButton.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                deleteAllStages();
            }
        });

        stagesList.getSelectionModel().addListSelectionListener(new ListSelectionListener() {
            @Override
            public void valueChanged(ListSelectionEvent e) {
                s2.getPlotStagePanel().updatePlot();
                s2.getStageProperties().updateLabels(s2.getPoleZeroListsPanel().getStagesListIndex());
            }
        });

        //Setup layout
        GroupLayout layout = new GroupLayout(this);
        this.setLayout(layout);
        layout.setAutoCreateGaps(true);
        layout.setAutoCreateContainerGaps(true);

        layout.setHorizontalGroup(
                layout.createParallelGroup(GroupLayout.Alignment.CENTER)
                        .addGroup(layout.createSequentialGroup()
                                .addComponent(unmatchedPolesListScroller)
                                .addComponent(unmatchedZeroListScroller))
                        .addGroup(layout.createSequentialGroup()
                                .addComponent(selectGroupButton)
                                .addComponent(automaticSelectionButton))
                        .addComponent(stagesListScroller)
                        .addGroup(layout.createSequentialGroup()
                                .addComponent(deleteStageButton)
                                .addComponent(deleteAllStagesButton))
        );
        layout.setVerticalGroup(
                layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(GroupLayout.Alignment.CENTER)
                                .addComponent(unmatchedPolesListScroller)
                                .addComponent(unmatchedZeroListScroller))
                        .addGroup(layout.createParallelGroup(GroupLayout.Alignment.CENTER)
                                .addComponent(selectGroupButton)
                                .addComponent(automaticSelectionButton))
                        .addComponent(stagesListScroller)
                        .addGroup(layout.createParallelGroup()
                                .addComponent(deleteStageButton)
                                .addComponent(deleteAllStagesButton))
        );
        layout.linkSize(SwingConstants.HORIZONTAL, unmatchedPolesListScroller, unmatchedZeroListScroller);
    }

    public void updateLists() {
        //First delete everything from the listPanels
        polesListModel.removeAllElements();
        zerosListModel.removeAllElements();
        stagesListModel.removeAllElements();

        //Get UserData information
        List<Complex> currentUnmatchedPoles = s.getUserData().getUnmatchedPoles();
        List<Complex> currentUnmatchedZeros = s.getUserData().getUnmatchedZeros();

        //Update Lists with the userData information
        joker = 0;
        for ( Complex x : currentUnmatchedPoles) {
            polesListModel.addElement(genericUtils.getPZString(x, true));
            if ( x.getImaginary() == 0 ) { joker += 1; }
            else { joker += 2; }
        }
        int originZeroCount = 0;
        for (Complex x : currentUnmatchedZeros) {
            zerosListModel.addElement(genericUtils.getPZString(x, false));
            if ( x.getImaginary() == 0 ) {
                joker -= 1;
                originZeroCount++;
            }
            else { joker -= 2; }
        }
        if ( originZeroCount % 2 == 0) {
            if ( joker > 0  ) { zerosListModel.addElement("<None>"); }
        }
        else {
            if ( joker > 1  ) { zerosListModel.addElement("<None>"); }
        }

        for (Stage x : s.getUserData().getStageList()) {
            stagesListModel.addElement( x.getDetails() );
        }
    }

    private void automaticSelection() {
        List<Complex> unmatchedPoles = s.getUserData().getUnmatchedPoles();
        List<Complex> unmatchedZeros = s.getUserData().getUnmatchedZeros();
        int tempPoloIndex1;
        int tempPoloIndex2;
        int tempZeroIndex1;
        int tempZeroIndex2;
        while ( unmatchedPoles.size() > 0) {
            tempPoloIndex1 = findMaxQIndex(unmatchedPoles);
            //System.out.println("tempPoloIndex1: " + tempPoloIndex1);

            //This is used to asign the second index in case there are two real poles
            if ( (unmatchedPoles.get(tempPoloIndex1).getImaginary() == 0) && (unmatchedPoles.size() > 1) ) {
                if (tempPoloIndex1 == 0) { tempPoloIndex2 = 1; }
                else { tempPoloIndex2 = 0; }
            }
            else { tempPoloIndex2 = tempPoloIndex1; }

            //System.out.println("tempPoloIndex2: " + tempPoloIndex2);

            //Now I get the closest Zero Index number 1
            tempZeroIndex1 = findClosestZero(unmatchedZeros, unmatchedPoles.get(tempPoloIndex1), unmatchedPoles.get(tempPoloIndex2));
            //System.out.println("tempZeroIndex1: " + tempZeroIndex1);
            tempZeroIndex2 = tempZeroIndex1;

            if (!unmatchedZeros.isEmpty()) {
                if (unmatchedZeros.get(tempZeroIndex1).getImaginary() == 0) { //If and only if the zero has no imaginary part.
                    boolean onlyOnePole = (unmatchedPoles.get(tempPoloIndex1) == unmatchedPoles.get(tempPoloIndex2)) && (unmatchedPoles.get(tempPoloIndex1).getImaginary() == 0);
                    if (!onlyOnePole && unmatchedZeros.size() > 1) { //Only one Pole
                        for (int i = 0; i < unmatchedZeros.size(); i++) {
                            if (unmatchedZeros.get(i).getImaginary() == 0 && i != tempZeroIndex1) {
                                tempZeroIndex2 = i;
                            }
                        }
                    }
                }
            }
            //System.out.println("tempZeroIndex2: " + tempZeroIndex2);

            if ( tempPoloIndex1 == tempPoloIndex2 ) {
                //System.out.println("Only one polo");
                matchWithSingleSelection(tempZeroIndex1, tempZeroIndex2, tempPoloIndex1);
            } else {
                //System.out.println("Two poles");
                matchWithDoubleSelection(tempZeroIndex1, tempZeroIndex2, tempPoloIndex1, tempPoloIndex2);
            }
            updateLists();
        }
    }

    private void deleteStage(int index) {
        Singleton_S2 s2 = Singleton_S2.getInstance();
        List<Stage> currentStageList = s.getUserData().getStageList();
        List<Complex> currentPoleList = s.getUserData().getUnmatchedPoles();
        List<Complex> currentZeroList = s.getUserData().getUnmatchedZeros();

        for ( Complex x : currentStageList.get(index).getPoles()) {
            if (x.getImaginary() >= 0) { currentPoleList.add(x); }
        }
        for ( Complex x : currentStageList.get(index).getZeros()) {
            if (x.getImaginary() >= 0) { currentZeroList.add(x); }
        }
        currentStageList.remove(index);
        updateLists();
        s2.getPlotPoleZeroPanel().updatePoleZeroPlot();
        s2.getPlotPoleZeroPanel().updatePoleZeroColour();
    }

    private void deleteAllStages() {
        List<Stage> currentStageList = s.getUserData().getStageList();
        for (int i = currentStageList.size()-1; i >= 0 ; i--) {
            deleteStage(i);
        }
    }

    private int findMaxQIndex(List<Complex> unmatchedPoles) {
        int tempPoloIndex1 = 0;
        Complex higherPoleQ = unmatchedPoles.get(0);
        for ( int i = 0; i < unmatchedPoles.size(); i++) {
            if ( GenericUtils.getQ(unmatchedPoles.get(i)) > GenericUtils.getQ(higherPoleQ) ) {
                higherPoleQ = unmatchedPoles.get(i);
                tempPoloIndex1 = i;
            }
        }
        return tempPoloIndex1;
    }
    private int findClosestZero (List<Complex> unmatchedZeros, Complex Polo1, Complex Polo2) {
        int tempZeroIndex1 = 0;

        if (unmatchedZeros.isEmpty()) {
            return 0;
        }

        double distance = findComplexDistance(unmatchedZeros.get(0), Polo2);
        if ( Polo1 == Polo2 && Polo1.getImaginary() == 0 ) {    //Only one Pole
            for ( int i = 0; i < unmatchedZeros.size(); i++) {
                if ( unmatchedZeros.get(i).getImaginary() == 0 ) { tempZeroIndex1 = i; }
            }
        }
        else {      //Two poles
            for ( int i = 0; i < unmatchedZeros.size(); i++) {
                if ( findComplexDistance(unmatchedZeros.get(i), Polo1) < distance ) {
                    distance = findComplexDistance(unmatchedZeros.get(i), Polo1);
                    tempZeroIndex1 = i;
                }
            }
        }
        return tempZeroIndex1;
    }
    private double findComplexDistance ( Complex c1, Complex c2 ) {
        return Math.sqrt( Math.pow(c1.getReal()-c2.getReal(), 2) + Math.pow(c1.getImaginary()-c2.getImaginary(), 2) );
    }

    private boolean checkIndexes( int firstZeroIndex, int secondZeroIndex, int firstPoleIndex, int secondPoleIndex) {
        List<Complex> unmatchedPoles = s.getUserData().getUnmatchedPoles();
        List<Complex> unmatchedZeros = s.getUserData().getUnmatchedZeros();

        if ( unmatchedPolesList.isSelectionEmpty() || unmatchedZeroList.isSelectionEmpty()) {   //If there is no Selection
            return false;     //And error frame is annoying... maybe is better just to do nothing. The user will realize
            //JInternalFrame frame = new JInternalFrame();
            //JOptionPane.showMessageDialog(frame, "There must be selected a pole and at least one zero", "No pole or zero found", JOptionPane.ERROR_MESSAGE);
        }
        else if ( firstPoleIndex != secondPoleIndex ) { //Selected two poles
            return checkTwoPoles(firstZeroIndex, secondZeroIndex, firstPoleIndex, secondPoleIndex);
        }
        else {
            return checkOnePole(firstZeroIndex, secondZeroIndex, firstPoleIndex);
        }

    }
    private boolean checkTwoPoles(int firstZeroIndex, int secondZeroIndex, int firstPoleIndex, int secondPoleIndex) {
        List<Complex> unmatchedPoles = s.getUserData().getUnmatchedPoles();
        List<Complex> unmatchedZeros = s.getUserData().getUnmatchedZeros();

        if ( unmatchedPoles.get(firstPoleIndex).getImaginary() != 0 || unmatchedPoles.get(secondPoleIndex).getImaginary() != 0  ) {
            //They are not in the real axis
            return false;
        }
        else if ( firstZeroIndex != secondZeroIndex) {   //If there are two different zeros
            if (((unmatchedZeros.get(firstZeroIndex).getImaginary() != 0) && (firstZeroIndex != unmatchedZeros.size())) || (unmatchedZeros.get(secondZeroIndex).getImaginary() != 0) && (secondZeroIndex != unmatchedZeros.size())) {
                //If one of them is a conjugate complex then you can't select both
                return false;
            }
            return true;
        }
        else {  //If there is only one zero
            if ( firstZeroIndex < unmatchedZeros.size() ) {     //If its not none
                if ( unmatchedZeros.get(firstZeroIndex).getImaginary() != 0 ) {
                    return true;
                }
                else {
                    return (joker > 0);
                }
            }
            else { return (joker > 1); }
        }
    }
    private boolean checkOnePole(int firstZeroIndex, int secondZeroIndex, int selectedPoleIndex) {
        List<Complex> unmatchedPoles = s.getUserData().getUnmatchedPoles();
        List<Complex> unmatchedZeros = s.getUserData().getUnmatchedZeros();

        if ( firstZeroIndex != secondZeroIndex) {   //If there are two different zeros
            if (((unmatchedZeros.get(firstZeroIndex).getImaginary() != 0) && (firstZeroIndex !=  unmatchedZeros.size())) || (unmatchedZeros.get(secondZeroIndex).getImaginary() != 0) && (secondZeroIndex !=  unmatchedZeros.size())) {
                //If one of them is a conjugate complex then you can't select both
                return false;
            }
            if ( (unmatchedPoles.get(unmatchedPolesList.getSelectedIndex()).getImaginary() == 0) ) {    //If the pole is simple then you cant selecto two zeros
                return false;
            }
            return true;
        }
        else {  //If there is only one zero
            if ( firstZeroIndex < unmatchedZeros.size() ) {     //If its not none
                if  ( (unmatchedPoles.get(unmatchedPolesList.getSelectedIndex()).getImaginary() == 0) ) { //If its a single pole
                    if (unmatchedZeros.get(firstZeroIndex).getImaginary() != 0) {   //And I chose a conjugate complex
                        return false;                                           //Then I cant choose it
                    }
                    else { return true; }                                                //If is a single pole but a single zero then OK.
                }
                else {  //If it wasn't a single pole
                    if ( unmatchedZeros.get(firstZeroIndex).getImaginary() == 0 ) { return (joker > 0); } //And I choose a simple zero (none never reach this if)
                    else { return true; }   //Then its a conjugate pole with a conjugate zero!
                }
            }
            else {      //I choose none
                if (unmatchedPoles.get(unmatchedPolesList.getSelectedIndex()).getImaginary() == 0) {        //And I have a single pole
                    return true;
                }
                else { return (joker > 1); }  //Othewise only possible if I have joker left
            }
        }
    }

    private void matchPolesZeros() {
        List<Complex> unmatchedPoles = s.getUserData().getUnmatchedPoles();
        List<Complex> unmatchedZeros = s.getUserData().getUnmatchedZeros();
        List<Stage> stageList = s.getUserData().getStageList();

        int firstZeroIndex = unmatchedZeroList.getMinSelectionIndex();
        int secondZeroIndex = unmatchedZeroList.getMaxSelectionIndex();
        int firstPoleIndex = unmatchedPolesList.getMinSelectionIndex();
        int secondPoleIndex = unmatchedPolesList.getMaxSelectionIndex();

        if (checkIndexes(firstZeroIndex, secondZeroIndex, firstPoleIndex, secondPoleIndex)) {
            if ( firstPoleIndex == secondPoleIndex ) {
                matchWithSingleSelection(firstZeroIndex, secondZeroIndex, firstPoleIndex);
            }
            else {
                matchWithDoubleSelection(firstZeroIndex, secondZeroIndex, firstPoleIndex, secondPoleIndex);
            }
            updateLists();
        }
    }
    private void matchWithSingleSelection(int firstZeroIndex, int secondZeroIndex, int selectedPoleIndex) {
        List<Complex> unmatchedPoles = s.getUserData().getUnmatchedPoles();
        List<Complex> unmatchedZeros = s.getUserData().getUnmatchedZeros();
        List<Stage> stageList = s.getUserData().getStageList();

        if ( firstZeroIndex == secondZeroIndex ) {  //Only One Zero Selected
            if (firstZeroIndex == unmatchedZeros.size()) {  //If its None
                stageList.add(new Stage(unmatchedPoles.get(selectedPoleIndex)));
                unmatchedPoles.remove(selectedPoleIndex);
            } else {
                System.out.println("Got here ^^");
                stageList.add(new Stage(unmatchedPoles.get(selectedPoleIndex), unmatchedZeros.get(firstZeroIndex)));
                unmatchedPoles.remove(selectedPoleIndex);
                unmatchedZeros.remove(firstZeroIndex);
            }
        }
        else {  //There are two Zero Selections
            if (firstZeroIndex == unmatchedZeros.size()) {
                stageList.add(new Stage(unmatchedPoles.get(selectedPoleIndex), unmatchedZeros.get(secondZeroIndex)));
                unmatchedPoles.remove(selectedPoleIndex);
                unmatchedZeros.remove(secondZeroIndex);
            }
            else if (secondZeroIndex == unmatchedZeros.size()) {
                stageList.add(new Stage(unmatchedPoles.get(selectedPoleIndex), unmatchedZeros.get(firstZeroIndex)));
                unmatchedPoles.remove(selectedPoleIndex);
                unmatchedZeros.remove(firstZeroIndex);
            }
            else {
                stageList.add(new Stage(unmatchedPoles.get(selectedPoleIndex), unmatchedZeros.get(firstZeroIndex), Complex.INF, unmatchedZeros.get(secondZeroIndex)));
                unmatchedPoles.remove(selectedPoleIndex);
                unmatchedZeros.remove(secondZeroIndex);             //First remove the bigger index so that pointed zero by firstZeroIndex is not changed
                unmatchedZeros.remove(firstZeroIndex);
            }
        }
    }
    private void matchWithDoubleSelection(int firstZeroIndex, int secondZeroIndex, int firstPoleIndex, int secondPoleIndex) {
        List<Complex> unmatchedPoles = s.getUserData().getUnmatchedPoles();
        List<Complex> unmatchedZeros = s.getUserData().getUnmatchedZeros();
        List<Stage> stageList = s.getUserData().getStageList();
        int maxPoleIndex = Math.max(firstPoleIndex, secondPoleIndex);
        int minPoleIndex = Math.min(firstPoleIndex, secondPoleIndex);
        int maxZeroIndex = Math.max(firstZeroIndex, secondZeroIndex);
        int minZeroIndex = Math.min(firstZeroIndex, secondZeroIndex);

        if ( firstZeroIndex == secondZeroIndex ) {  //Only One Selected
            if (firstZeroIndex == unmatchedZeros.size()) {  //If its None
                stageList.add(new Stage(unmatchedPoles.get(firstPoleIndex), Complex.INF, unmatchedPoles.get(secondPoleIndex)));
                unmatchedPoles.remove(maxPoleIndex);     //I have to remove first the bigger one
                unmatchedPoles.remove(minPoleIndex);
            } else {
                stageList.add(new Stage(unmatchedPoles.get(firstPoleIndex), unmatchedZeros.get(firstZeroIndex), unmatchedPoles.get(secondPoleIndex)));
                unmatchedPoles.remove(maxPoleIndex);     //I have to remove first the bigger one
                unmatchedPoles.remove(minPoleIndex);
                unmatchedZeros.remove(maxZeroIndex);
            }
        }
        else {  //There are two Selections
            if (firstZeroIndex == unmatchedZeros.size()) {
                stageList.add(new Stage(unmatchedPoles.get(firstPoleIndex), unmatchedZeros.get(secondZeroIndex), unmatchedPoles.get(secondPoleIndex)));
                unmatchedPoles.remove(maxPoleIndex);     //I have to remove first the bigger one
                unmatchedPoles.remove(minPoleIndex);
                unmatchedZeros.remove(maxZeroIndex);
            }
            else if (secondZeroIndex == unmatchedZeros.size()) {
                stageList.add(new Stage(unmatchedPoles.get(firstPoleIndex), unmatchedZeros.get(firstZeroIndex), unmatchedPoles.get(secondPoleIndex)));
                unmatchedPoles.remove(maxPoleIndex);     //I have to remove first the bigger one
                unmatchedPoles.remove(minPoleIndex);
                unmatchedZeros.remove(maxZeroIndex);
            }
            else {
                stageList.add(new Stage(unmatchedPoles.get(secondPoleIndex), unmatchedZeros.get(firstZeroIndex), unmatchedPoles.get(secondPoleIndex), unmatchedZeros.get(secondZeroIndex)));
                unmatchedPoles.remove(maxPoleIndex);     //I have to remove firts the bigger one
                unmatchedPoles.remove(minPoleIndex);
                unmatchedZeros.remove(maxZeroIndex);     //First remove the bigger index so that pointed zero by firstZeroIndex is not changed
                unmatchedZeros.remove(minZeroIndex);
            }
        }

    }

    public int getStagesListIndex() {
        if ( stagesList.isSelectionEmpty() ) {
            return -1;
        }
        else {
            return stagesList.getSelectedIndex();
        }
    }

    private static class MySelectionModel extends DefaultListSelectionModel {
        private JList list;
        private int maxCount;

        private MySelectionModel(JList list,int maxCount) {
            this.list = list;

            this.maxCount = maxCount;
        }

        @Override
        public void setSelectionInterval(int index0, int index1) {
            if (index1 - index0 >= maxCount)
            {
                index1 = index0 + maxCount - 1;
            }
            super.setSelectionInterval(index0, index1);
        }

        @Override
        public void addSelectionInterval(int index0, int index1) {
            int selectionLength = list.getSelectedIndices().length;
            if (selectionLength >= maxCount)
                return;

            if (index1 - index0 >= maxCount - selectionLength)
            {
                index1 = index0 + maxCount - 1 - selectionLength;
            }
            if (index1 < index0)
                return;
            super.addSelectionInterval(index0, index1);
        }
    }
}
</file>

<file path="Aproximaciones/src/secondstage/PoleZeroPanel.java">
package secondstage;

import javax.swing.*;
import java.awt.*;

/**
 * Created by NEGU on 8/11/2015.
 */
public class PoleZeroPanel extends JPanel {
    private PlotPoleZeroPanel plotPoleZeroPanel;
    private PoleZeroListsPanel poleZeroListsPanel;

    public PoleZeroPanel() {
        Singleton_S2 s = Singleton_S2.getInstance();

        plotPoleZeroPanel = s.getPlotPoleZeroPanel();
        poleZeroListsPanel = s.getPoleZeroListsPanel();

        this.setMaximumSize(new Dimension(500, 2080));
        this.setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
        this.setBorder(BorderFactory.createTitledBorder("PoleZeroStages"));

        this.add(plotPoleZeroPanel);
        this.add(poleZeroListsPanel);
    }

}
</file>

<file path="Aproximaciones/src/secondstage/SetPlot.java">
package secondstage;

import javax.swing.*;

/**
 * Created by NEGU on 10/11/2015.
 */
public class SetPlot extends JPanel{
    private StagePlotModePanel stagePlotModePanel;
    private FilterMode filterMode;
    private StageProperties stageProperties;

    SetPlot() {
        Singleton_S2 s = Singleton_S2.getInstance();
        this.setLayout(new BoxLayout(this, BoxLayout.X_AXIS));

        stagePlotModePanel = s.getstagePlotModePanel();
        filterMode = s.getFilterMode();
        stageProperties = s.getStageProperties();

        this.add(stagePlotModePanel);
        this.add(filterMode);
        this.add(stageProperties);
    }
}
</file>

<file path="Aproximaciones/src/secondstage/Singleton_S2.java">
package secondstage;

import mathematics.Stage;
import org.apache.commons.math3.complex.Complex;

import java.util.ArrayList;
import java.util.List;
import java.util.Set;

class Singleton_S2 {
    private static final Singleton_S2 INSTANCE = new Singleton_S2();
    private Singleton_S2() {}
    public static Singleton_S2 getInstance() {
        return INSTANCE;
    }

    private List<Complex> poleArray = new ArrayList<>();
    private List<Complex> zeroArray = new ArrayList<>();
    private StagePanel stagePanel = null;
    private PoleZeroPanel poleZeroPanel = null;
    private PlotPoleZeroPanel plotPoleZeroPanel = null;
    private PoleZeroListsPanel poleZeroListsPanel = null;
    private PlotStagePanel plotStagePanel = null;
    private StagePlotModePanel stagePlotModePanel = null;
    private StageVisualizerPanel stageVisualizerPanel = null;
    private StageProperties stageProperties = null;
    private FilterMode filterMode = null;
    private SetPlot setPlot = null;

    public SetPlot getSetPlot() {
        if (setPlot == null)
            setPlot = new SetPlot();
        return setPlot;
    }
    public FilterMode getFilterMode () {
        if (filterMode == null)
            filterMode = new FilterMode();
        return filterMode;
    }
    public StageVisualizerPanel getStageVisualizerPanel() {
        if (stageVisualizerPanel == null)
            stageVisualizerPanel = new StageVisualizerPanel();
        return stageVisualizerPanel;
    }
    public StageProperties getStageProperties() {
        if (stageProperties == null)
            stageProperties = new StageProperties();
        return stageProperties;
    }
    public StagePlotModePanel getstagePlotModePanel() {
        if (stagePlotModePanel == null)
            stagePlotModePanel = new StagePlotModePanel();
        return stagePlotModePanel;
    }
    public PlotStagePanel getPlotStagePanel() {
        if (plotStagePanel == null)
            plotStagePanel = new PlotStagePanel();
        return plotStagePanel;
    }
    public StagePanel getStagePanel() {
        if (stagePanel == null)
            stagePanel = new StagePanel();
        return stagePanel;
    }
    public PoleZeroPanel getPoleZeroPanel() {
        if (poleZeroPanel == null)
            poleZeroPanel = new PoleZeroPanel();
        return poleZeroPanel;
    }
    public PlotPoleZeroPanel getPlotPoleZeroPanel() {
        if (plotPoleZeroPanel == null)
            plotPoleZeroPanel = new PlotPoleZeroPanel();
        return plotPoleZeroPanel;
    }
    public PoleZeroListsPanel getPoleZeroListsPanel() {
        if (poleZeroListsPanel == null)
            poleZeroListsPanel = new PoleZeroListsPanel();
        return poleZeroListsPanel;
    }
    public List<Complex> getPoleArray() {
        if (poleArray == null)
            poleArray = new ArrayList<>();
        return poleArray;
    }
    public List<Complex> getZeroArray() {
        if (zeroArray == null)
            zeroArray = new ArrayList<>();
        return zeroArray;
    }
}
</file>

<file path="Aproximaciones/src/secondstage/StagePanel.java">
package secondstage;

import Data.Singleton;

import javax.swing.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

/**
 * Created by NEGU on 8/11/2015.
 */
public class StagePanel extends JPanel {
    StageVisualizerPanel stageVisualizerPanel;
    SetPlot setPlot;


    public StagePanel() {
        Singleton_S2 s = Singleton_S2.getInstance();
        //this.setBorder(BorderFactory.createTitledBorder("Stages Visualizer"));
        this.setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));

        stageVisualizerPanel = s.getStageVisualizerPanel();
        setPlot = s.getSetPlot();

        this.add(stageVisualizerPanel);
        this.add(setPlot);
    }
}
</file>

<file path="Aproximaciones/src/secondstage/StagePlotModePanel.java">
package secondstage;

import Data.Singleton;
import mathematics.Stage;
import tclib.TransferFunction;

import javax.swing.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.ArrayList;
import java.util.List;

/**
 * Created by NEGU on 10/11/2015.
 */
public class StagePlotModePanel extends JPanel{
    private Singleton_S2 s2 = Singleton_S2.getInstance();
    private Singleton s = Singleton.getInstance();
    private ButtonGroup groupOfPlotMode = new ButtonGroup();
    private JRadioButton singleModeRadioButton = new JRadioButton("Plot Selected Stage");
    private JRadioButton multipleModeRadioButton = new JRadioButton("Plot All Stages");
    private JRadioButton cumModeRadioButton = new JRadioButton("Plot Acumulative Stages");
    private JRadioButton showAllAcumulativeRadioButton = new JRadioButton("Plot Final Acumulative Stages");

    StagePlotModePanel() {
        multipleModeRadioButton.setSelected(true);

        this.setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));

        multipleModeRadioButton.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                if (!s.getUserData().getStageList().isEmpty()) {
                    s2.getPlotStagePanel().updatePlot();
                }
            }
        });
        singleModeRadioButton.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                if (!s.getUserData().getStageList().isEmpty()) {
                    s2.getPlotStagePanel().updatePlot();
                }
            }
        });
        cumModeRadioButton.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                if (!s.getUserData().getStageList().isEmpty()) {
                    s2.getPlotStagePanel().updatePlot();
                }
            }
        });
        showAllAcumulativeRadioButton.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                s2.getPlotStagePanel().updatePlot();
            }
        });

        groupOfPlotMode.add(singleModeRadioButton);
        groupOfPlotMode.add(multipleModeRadioButton);
        groupOfPlotMode.add(cumModeRadioButton);
        groupOfPlotMode.add(showAllAcumulativeRadioButton);

        this.setBorder(BorderFactory.createTitledBorder("Plot Mode"));
        this.add(singleModeRadioButton);
        this.add(multipleModeRadioButton);
        this.add(cumModeRadioButton);
        this.add(showAllAcumulativeRadioButton);
    }

    public JRadioButton getSingleModeRadioButton() { return singleModeRadioButton; }
    public JRadioButton getMultipleModeRadioButton() { return multipleModeRadioButton; }
    public JRadioButton getCumModeRadioButton() { return cumModeRadioButton; }
}
</file>

<file path="Aproximaciones/src/secondstage/StageProperties.java">
package secondstage;

import Data.Singleton;
import mathematics.Stage;
import org.apache.commons.math3.complex.Complex;
import tclib.GenericUtils;

import javax.swing.*;
import java.util.List;

/**
 * Created by NEGU on 10/11/2015.
 */
public class StageProperties extends JPanel{
    Singleton s = Singleton.getInstance();
    Singleton_S2 s2 = Singleton_S2.getInstance();

    JLabel qLabel = new JLabel("Quality Factor (Q): ");
    JLabel qValue = new JLabel("");
    JLabel dinamicRangeLabel = new JLabel("Dinamic Range (DR): ");
    JLabel dinamicRangeValue = new JLabel("");
    JLabel wpLabel = new JLabel("Pole Frequency (wp): ");
    JLabel wpValue = new JLabel("");
    JLabel wzLabel = new JLabel("Zero Frequency (wz): ");
    JLabel wzValue = new JLabel("");

    public StageProperties() {
        //TODO: agergar todo lo que uno quiera aca de info
        this.setBorder(BorderFactory.createTitledBorder("Stage Properties"));

        //Setup layout
        GroupLayout layout = new GroupLayout(this);
        this.setLayout(layout);
        layout.setAutoCreateGaps(true);
        layout.setAutoCreateContainerGaps(true);

        layout.setHorizontalGroup(
                layout.createParallelGroup(GroupLayout.Alignment.LEADING)
                        .addGroup(layout.createSequentialGroup()
                                .addComponent(qLabel)
                                .addComponent(qValue)
                                .addComponent(wpLabel)
                                .addComponent(wpValue))
                        .addGroup(layout.createSequentialGroup()
                                .addComponent(dinamicRangeLabel)
                                .addComponent(dinamicRangeValue)
                                .addComponent(wzLabel)
                                .addComponent(wzValue))
                );
        layout.setVerticalGroup(
                layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(GroupLayout.Alignment.CENTER)
                                .addComponent(qLabel)
                                .addComponent(qValue)
                                .addComponent(wpLabel)
                                .addComponent(wpValue))
                        .addGroup(layout.createParallelGroup()
                                .addComponent(dinamicRangeLabel)
                                .addComponent(dinamicRangeValue)
                                .addComponent(wzLabel)
                                .addComponent(wzValue))
        );

    }

    public void updateLabels(int index) {
        List<Stage> currentStageList = s.getUserData().getStageList();

        if ( index != -1 ) {
            updateQ(currentStageList.get(index).getPoles());
            updatewp(currentStageList.get(index).getPoles());
            if (currentStageList.get(index).getZeros().length != 0) {
                updatewz(currentStageList.get(index).getZeros());
            }
        }
    }
    private void updateQ(Complex[] pole) { qValue.setText(String.format("%.2f", GenericUtils.getQ(pole[0]))); }
    private void updatewp(Complex[] pole) { wpValue.setText(String.format("%.2f", pole[0].getImaginary())); }
    private void updatewz(Complex[] zero) { wzValue.setText(String.format("%.2f", zero[0].getImaginary())); }
}
</file>

<file path="Aproximaciones/src/secondstage/StageTwoPanel.java">
package secondstage;

import Data.Singleton;
import Data.UserData;
import org.apache.commons.math3.complex.Complex;
import tclib.TransferFunction;

import javax.swing.*;
import java.awt.*;

public class StageTwoPanel extends JPanel {
    private StagePanel stagePanel;
    private PoleZeroPanel poleZeroPanel;

    public StageTwoPanel() {
        Singleton_S2 s = Singleton_S2.getInstance();
        this.setLayout(new BoxLayout(this, BoxLayout.X_AXIS));
        this.setBackground(Color.BLUE);

        stagePanel = s.getStagePanel();
        poleZeroPanel = s.getPoleZeroPanel();

        this.add(poleZeroPanel);
        this.add(stagePanel);
    }

    public void set(){
        //System.out.println("Empiezo a pasar a la etapa 2");
        UserData uData = Singleton.getInstance().getUserData();
        TransferFunction t = new TransferFunction(uData.getApproximationList().get(uData.getSelection()).getTF());
        if (t.equals(uData.getTransferFunction())) return;
        uData.setTransferFunction(t);
        uData.getUnmatchedPoles().clear();
        uData.getUnmatchedZeros().clear();
        uData.getStageList().clear();
        //System.out.println("Vamos a obtener los polos...");
        for(Complex x : t.getPoles()) {
            if(Math.abs(x.getImaginary()) < Math.pow(10,-6)) x = new Complex(x.getReal(),0);
            if (x.getImaginary() >= 0)  //Only the positive conjugated are stored because I only need one of the two
                uData.getUnmatchedPoles().add(x);
        }
        //System.out.println("Vamos a obtener los ceros...");
        //TODO KEVIN: muere en getZeros cuando hacemos un butter orden 9 o mayor para el RechazaBanda
        //TODO KEVIN: cuando hacemos un rechaza banda butter calcula mal los ceros (no están sobre el eje imaginario)
        for(Complex x : t.getZeros()){
            //System.out.println("x = " + x);
            if(Math.abs(x.getImaginary()) < Math.pow(10,-6)) x = new Complex(0,0);
            if (x.getImaginary() >= 0)  //Only the positive conjugated are stored because I only need one of the two
                uData.getUnmatchedZeros().add(x);
        }
        //System.out.println("Ya obtuve todo :)");
        Singleton_S2.getInstance().getPoleZeroListsPanel().updateLists();
        Singleton_S2.getInstance().getPlotPoleZeroPanel().updatePoleZeroPlot();
        Singleton_S2.getInstance().getPlotStagePanel().updatePlot();
        Singleton_S2.getInstance().getPlotPoleZeroPanel().updatePoleZeroColour();
    }
}
</file>

<file path="Aproximaciones/src/secondstage/StageVisualizerPanel.java">
package secondstage;

import javax.swing.*;

/**
 * Created by NEGU on 10/11/2015.
 */
public class StageVisualizerPanel extends JPanel {
    private PlotStagePanel plotStagePanel;

    StageVisualizerPanel() {
        Singleton_S2 s = Singleton_S2.getInstance();
        this.setLayout(new BoxLayout(this, BoxLayout.X_AXIS));

        plotStagePanel = s.getPlotStagePanel();

        this.add(plotStagePanel);
    }
}
</file>

<file path="Aproximaciones/src/tclib/templates/BandpassTemplate.java">
package tclib.templates;

import static java.lang.Math.sqrt;

public class BandpassTemplate extends SuperTemplate {

    private final double wpp;
    private final double wap;
    private final double wpm;
    private final double wam;
    private final double B;
    private final double wo;

    public double getWpp() { return wpp; }
    public double getWap() { return wap; }
    public double getWpm() { return wpm; }
    public double getWam() { return wam; }
    public double getB() { return B; }
    public double getWo() { return wo; }

    public BandpassTemplate(double Ap, double Aa, double G, double wpm, double wam, double wpp, double wap) {
        this.Ap = Ap;
        this.Aa = Aa;
        this.G = G;
        this.wpp = wpp;
        this.wap = wap;
        this.wpm = wpm;
        this.wam = wam;
        this.wo = sqrt(wpm*wpp);
        this.B = (wpp-wpm)/wo;
        normalize();
    }

    @Override
    protected void normalize() {
        if(wpm*wpp > wam*wap) {
            double wam2 = wpm * wpp / wap;
            this.wan = (wap-wam2)/(wpp-wpm);
        } else {
            double wap2 = wpm * wpp / wam;
            this.wan = (wap2 - wam) / (wpp - wpm);
        }
    }

    @Override
    public boolean equals(SuperTemplate t) {
        if(t instanceof BandpassTemplate) {
            BandpassTemplate that = (BandpassTemplate) t;
            if (this.Ap == that.Ap && this.Aa == that.Aa && this.G == that.G && this.wpp == that.wpp &&
                    this.wap == that.wap && this.wpm == that.wpm && this.wam == that.wam)
                return true;
            else return false;
        } else return false;
    }

    @Override
    public double getWmax() { return wap; }
    @Override
    public double getWmin() { return wam; }
    @Override
    public double[] getBand() { return new double[] {wpm, wpp}; }
}
</file>

<file path="Aproximaciones/src/tclib/templates/BandrejectTemplate.java">
package tclib.templates;

import static java.lang.Math.sqrt;

public class BandrejectTemplate extends SuperTemplate {

    private final double wpp;
    private final double wap;
    private final double wpm;
    private final double wam;
    private final double B;
    private final double wo;

    public double getWpp() { return wpp; }
    public double getWap() { return wap; }
    public double getWpm() { return wpm; }
    public double getWam() { return wam; }
    public double getB() { return B; }
    public double getWo() { return wo; }

    public BandrejectTemplate(double Ap, double Aa, double G, double wpm, double wam, double wpp, double wap) {
        this.Ap = Ap;
        this.Aa = Aa;
        this.G = G;
        this.wpp = wpp;
        this.wap = wap;
        this.wpm = wpm;
        this.wam = wam;
        this.wo = sqrt(wam*wap);
        this.B = (wpp-wpm)/wo;
        normalize();
    }

    @Override
    protected void normalize() {
        if(wam*wap > wpm*wpp) {
            double wpm2 = wam * wap / wpp;
            this.wan = (wpp-wpm2)/(wap-wam);
        } else {
            double wpp2 = wam * wap / wpm;
            this.wan = (wpp2-wpm)/(wap-wam);
        }
    }

    @Override
    public boolean equals(SuperTemplate t) {
        if(t instanceof BandrejectTemplate) {
            BandrejectTemplate that = (BandrejectTemplate) t;
            if (this.Ap == that.Ap && this.Aa == that.Aa && this.G == that.G && this.wpp == that.wpp &&
                    this.wap == that.wap && this.wpm == that.wpm && this.wam == that.wam)
                return true;
            else return false;
        } else return false;
    }

    @Override
    public double getWmax() { return wpp; }
    @Override
    public double getWmin() { return wpm; }
    @Override
    public double[] getBand() { return new double[] {wpm/100, wpm, wpp, wpp*100}; }
}
</file>

<file path="Aproximaciones/src/tclib/templates/DelayTemplate.java">
package tclib.templates;

public class DelayTemplate extends SuperTemplate {

    private final double wp;
    private final double wa;
    private final double delay;
    private final double psi;

    public double getWp() { return wp; }
    public double getWa() { return wa; }
    public double getDelay() { return delay; }
    public double getPsi() { return psi; }

    public DelayTemplate(double Ap, double Aa, double G, double wp, double wa, double delay, double psi) {
        this.Ap = Ap;
        this.Aa = Aa;
        this.G = G;
        this.wp = wp;
        this.wa = wa;
        this.delay = delay;
        this.psi = psi;
        normalize();
    }

    @Override
    protected void normalize() {
        this.wan = wa/wp;
    }

    @Override
    public boolean equals(SuperTemplate t) {
        if(t instanceof DelayTemplate) {
            DelayTemplate that = (DelayTemplate) t;
            if (this.Ap == that.Ap && this.Aa == that.Aa && this.G == that.G && this.wp == that.wp &&
                    this.wa == that.wa && this.delay == that.delay && this.psi == that.psi)
                return true;
            else return false;
        } else return false;
    }

    @Override
    public double getWmax() { return wa; }
    @Override
    public double getWmin() { return wp; }
    @Override
    public double[] getBand() { return new double[] {wp/100, wp}; }
}
</file>

<file path="Aproximaciones/src/tclib/templates/HighpassTemplate.java">
package tclib.templates;

public class HighpassTemplate extends SuperTemplate {

    private final double wp;
    private final double wa;

    public double getWp() { return wp; }
    public double getWa() { return wa; }

    public HighpassTemplate(double Ap, double Aa, double G, double wp, double wa) {
        this.Ap = Ap;
        this.Aa = Aa;
        this.G = G;
        this.wp = wp;
        this.wa = wa;
        normalize();
    }

    @Override
    protected void normalize() {
        this.wan = wp/wa;
    }

    @Override
    public boolean equals(SuperTemplate t) {
        if(t instanceof HighpassTemplate) {
            HighpassTemplate that = (HighpassTemplate) t;
            if (this.Ap == that.Ap && this.Aa == that.Aa && this.G == that.G && this.wp == that.wp && this.wa == that.wa)
                return true;
            else return false;
        } else return false;
    }

    @Override
    public double getWmax() { return wp; }
    @Override
    public double getWmin() { return wa; }
    @Override
    public double[] getBand() { return new double[] {wp, wp*100}; }
}
</file>

<file path="Aproximaciones/src/tclib/templates/LowpassTemplate.java">
package tclib.templates;

public class LowpassTemplate extends SuperTemplate {

    private final double wp;
    private final double wa;

    public double getWp() { return wp; }
    public double getWa() { return wa; }

    public LowpassTemplate(double Ap, double Aa, double G, double wp, double wa) {
        this.Ap = Ap;
        this.Aa = Aa;
        this.G = G;
        this.wp = wp;
        this.wa = wa;
        normalize();
    }

    @Override
    protected void normalize() {
        this.wan = wa/wp;
    }

    @Override
    public boolean equals(SuperTemplate t) {
        if(t instanceof LowpassTemplate) {
            LowpassTemplate that = (LowpassTemplate) t;
            if (this.Ap == that.Ap && this.Aa == that.Aa && this.G == that.G && this.wp == that.wp && this.wa == that.wa)
                return true;
            else return false;
        } else return false;
    }

    @Override
    public double getWmax() { return wa; }
    @Override
    public double getWmin() { return wp; }
    @Override
    public double[] getBand() { return new double[] {wp/100, wp}; }
}
</file>

<file path="Aproximaciones/src/tclib/templates/SuperTemplate.java">
package tclib.templates;

public abstract class SuperTemplate implements TemplatesInterface {
    protected double wan;   //rad/s
    protected double Ap;    //dB
    protected double Aa;    //dB
    protected double G;     //dB

    public double getWan() { return wan; }
    public double getAp() { return Ap; }
    public double getAa() { return Aa; }
    public double getG() { return G; }

    protected abstract void normalize();   //To be called by each subclass initialization.
    public abstract boolean equals(SuperTemplate t);

    public abstract double getWmax();
    public abstract double getWmin();
    public abstract double[] getBand();
}
</file>

<file path="Aproximaciones/src/tclib/templates/TemplatesInterface.java">
package tclib.templates;

/**
 * Created by NAHUEL on 31/10/2015.
 */
public interface TemplatesInterface {
    String[] templateStrings = {"Low Pass", "High Pass", "Band Pass", "Band Reject", "Delay"};
    enum templateType {LOWPASS, HIGHPASS, BANDPASS, BANDREJECT, DELAY}

}
</file>

<file path="Aproximaciones/src/tclib/GenericUtils.java">
package tclib;

import org.apache.commons.math3.complex.Complex;

import java.util.ArrayList;
import java.util.List;

public class GenericUtils {

    public static double[] linspace(double start, double end, int pointCount){
        double[] result = new double[pointCount];
        double step = (end - start) / pointCount;
        for (int i = 0; i < pointCount; i++) {
            result[i] = (start + i * step);
        }
        return result;
    }

    public static double[] logspace(double start, double end, int pointCount){
        double[] result = linspace(Math.log(start), Math.log(end), pointCount);

        for (int i = 0; i < pointCount; i++) {
            result[i] = Math.exp(result[i]);
        }
        return result;
    }

    public static double getQ(Complex x){
        return Math.abs(1./(2.*Math.cos(x.getArgument())));
    }

    public static String getPZString(Complex x, boolean isPole){
        if ( x == Complex.INF) return "No Zero";
        String str = "Zero ";
        if(isPole) str = "Pole ";
        double real = x.getReal();
        double imag = x.getImaginary();
        double Q = getQ(x);
        return str + "r: " + String.format("%.1f", real) + " i: " + String.format("%.2f", imag) + " Q: " + String.format("%.2f", Q);
    }

    public static double dynamicRangeLoss(List<TransferFunction> stages, double minW, double maxW) {
        return dynamicRangeLoss(stages, minW, maxW, 10000);
    }
    public static double dynamicRangeLoss(List<TransferFunction> stages, double minW, double maxW, int points) {
        if(stages.size() == 0) return 0;
        double freq[] = logspace(minW, maxW, points);
        double dynRangeLoss[] = new double[points];

        List<TransferFunction> acumTF =  new ArrayList<>();
        acumTF.add(new TransferFunction(stages.get(0)));
        for(int i = 1; i < stages.size(); i++){
            TransferFunction nextTF = new TransferFunction(acumTF.get(i-1));
            nextTF.multiply(stages.get(i));
            acumTF.add(nextTF);
        }

        double stageGain[] = new double[stages.size()];
        for(int i = 0; i < points; i++) {
            for (int j = 0; j < stages.size(); j++)
                stageGain[j] = acumTF.get(j).evaluateApproximationAtOmega(freq[i]).abs();
            double max = stageGain[0];
            double min = stageGain[0];
            for(double x : stageGain){
                if(max < x) max = x;
                if(min > x) min = x;
            }
            dynRangeLoss[i] =  max/min;
        }
        double maxLoss = dynRangeLoss[0];
        for(double x : dynRangeLoss){
            if(maxLoss < x) maxLoss = x;
        }
        return maxLoss;
    }
}
</file>

<file path="Aproximaciones/src/tclib/MathUtils.java">
package tclib;

/**
 * Created by kdewald on 13/10/15.
 */
public class MathUtils {

    public static double asinh(double x) { return Math.log(x + Math.sqrt(x*x + 1.0)); }
    public static double acosh(double x) { return Math.log(x + Math.sqrt(x*x - 1.0)); }
    public static double atanh(double x) { return Math.log( (x + 1.0)/(x - 1.0) ) / 2; }
    public static int factorial(int n) {
        int fact = 1; // this  will be the result.
        for (int i = 1; i <= n; i++) {
            fact *= i;
        }
        return fact;
    }
    public static int[][] getAllPermutations(int n){
        int array[][] = new int[factorial(n)][n];
        if(n < 0) return array;

        int element = 0;
        int I[] = new int[n];
        for(int i = 0; i < I.length; i++) I[i] = -1;

        mainLoop:
        for(int j = 0; j > -1; j--){
            I[j]++;
            if(I[j] >= n){
                I[j] = -1;
                continue;
            }
            for(int k=0; k<j; k++)
                if(I[j]==I[k]) {
                    j++;
                    continue mainLoop;
                }
            j++;
            if(++j <= n) continue;
            else j--;
            System.arraycopy( I, 0, array[element++], 0, n );
        }

/*        for(int[] x : array) {
            for (int i : x)
                System.out.print(i);
            System.out.println();
        }                                   */
        return array;
    }

    private static final double gr=(Math.sqrt(5)-1)/2;
    public static double gss(TransferFunction TF, double a, double b, double tol) {
        tol=1e-2;
        double c = b - gr * (b - a);
        double d = a + gr * (b - a);
        while (Math.abs(c - d) > tol) {
            double fc = TF.evaluateApproximationAtOmega(c).abs();
            double fd = TF.evaluateApproximationAtOmega(d).abs();
            if (fc < fd) {
                b = d;
                d = c;
                c = b - gr * (b - a);
            } else {
                a = c;
                c = d;
                d = a + gr * (b - a);
            }
        }
        return (b + a) / 2;
    }
}
</file>

<file path="Aproximaciones/src/tclib/TransferFunction.java">
package tclib;

import org.apache.commons.lang3.ArrayUtils;
import org.apache.commons.math3.analysis.polynomials.PolynomialFunction;
import org.apache.commons.math3.analysis.solvers.LaguerreSolver;
import org.apache.commons.math3.complex.Complex;
import org.apache.commons.math3.util.CombinatoricsUtils;
import tclib.templates.*;

import java.util.*;

public class TransferFunction {

    PolynomialFunction numerador;
    PolynomialFunction denominador;

    //estas son las listas armadas de las raices
    private List<Complex> numeradorRootList;
    private List<Complex> denominadorRootList;

    //estas hashtables tienen como key el polo y como value el orden del mismo
    private Hashtable<Complex, Integer> numeradorPoleOrderTable;
    private Hashtable<Complex, Integer> denominadorPoleOrderTable;

    public TransferFunction(PolynomialFunction numerador, PolynomialFunction denominador) {
        this.numerador = numerador;
        this.denominador = denominador;
    }
    public TransferFunction(TransferFunction that) {
        this.numerador = new PolynomialFunction(that.numerador.getCoefficients());
        this.denominador = new PolynomialFunction(that.denominador.getCoefficients());
    }
    public PolynomialFunction getNumeratorCopy() {
        return new PolynomialFunction(numerador.getCoefficients());
    }
    public PolynomialFunction getDenominatorCopy() { return new PolynomialFunction(denominador.getCoefficients()); }

    /**
     * @param numPoly: Indice del elemento indica la potencia de ese termino del polinomio.
     * @param denPoly: Indice del elemento indica la potencia de ese termino del polinomio.
     */
    public TransferFunction(double[] numPoly, double[] denPoly) {
        numerador = new PolynomialFunction(numPoly);
        denominador = new PolynomialFunction(denPoly);
    }

    /**
     * @param zeros: Array of complex numbers for each zero.
     * @param poles: Array of complex numbers for each pole.
     */
    public TransferFunction(Complex[] zeros, Complex[] poles) {
        double[] polyInit = {1.0};
        numerador = new PolynomialFunction(polyInit);
        denominador = new PolynomialFunction(polyInit);

        for (Complex zero : zeros) {
            if (zero.getImaginary() == 0) {
                double[] roots = {-zero.getReal(), 1};
                PolynomialFunction aux = new PolynomialFunction(roots);
                numerador = numerador.multiply(aux);
            } else if (zero.getImaginary() > 0) {
                double a = zero.getReal();
                double b = zero.getImaginary();

                double[] roots = {a * a + b * b, -2 * a, 1};
                PolynomialFunction aux = new PolynomialFunction(roots);
                numerador = numerador.multiply(aux);
            }
        }

        for (Complex pole : poles) {
            if (pole.getImaginary() == 0) {
                double[] roots = {-pole.getReal(), 1};
                PolynomialFunction aux = new PolynomialFunction(roots);
                denominador = denominador.multiply(aux);
            } else if (pole.getImaginary() > 0) {
                double a = pole.getReal();
                double b = pole.getImaginary();

                double[] roots = {a * a + b * b, -2 * a, 1};
                PolynomialFunction aux = new PolynomialFunction(roots);
                denominador = denominador.multiply(aux);
            }
        }
        for (double x : denominador.getCoefficients())
            System.out.print(x + " ");
        System.out.println("EndPole");
        for (double x : numerador.getCoefficients())
            System.out.print(x + " ");
        System.out.println("EndZero");

    }

    public double getModuleAtOrigin() {
        return numerador.getCoefficients()[0] / denominador.getCoefficients()[0];
    }

    public boolean equals(TransferFunction that) {
        double thisNum[] = this.numerador.getCoefficients();
        double thatNum[] = that.numerador.getCoefficients();
        double thisDen[] = this.denominador.getCoefficients();
        double thatDen[] = that.denominador.getCoefficients();
        if(thisNum.length == thatNum.length && thisDen.length == thatDen.length) {
            for (int i = 0; i < thisNum.length; i++)
                if (thisNum[i] != thatNum[i]) return false;
            for (int i = 0; i < thisDen.length; i++)
                if (thisDen[i] != thatDen[i]) return false;
            return true;
        } else return false;
    }

    public Complex evaluateApproximationAtOmega(double omega) {
        Complex evaluationPoint = new Complex(0, omega);
        Complex numValue = new Complex(0);
        double[] numCoefficient = numerador.getCoefficients();
        for (int i = 0; i < numCoefficient.length; i++) {
            numValue = numValue.add(evaluationPoint.pow(i).multiply(numCoefficient[i]));
        }

        Complex denValue = new Complex(0);
        double[] denCoefficient = denominador.getCoefficients();
        for (int i = 0; i < denCoefficient.length; i++) {
            denValue = denValue.add(evaluationPoint.pow(i).multiply(denCoefficient[i]));
        }

        return numValue.divide(denValue);
    }

    public Complex[] evaluateApproximationAtRange(double[] omegaRange) {
        Complex[] result = new Complex[omegaRange.length];

        for (int i = 0; i < omegaRange.length; i++) {
            result[i] = evaluateApproximationAtOmega(omegaRange[i]);
        }
        return result;
    }

    public void multiply(double gain) {
        double p[] = {gain};
        PolynomialFunction aux = new PolynomialFunction(p);
        numerador = numerador.multiply(aux);
    }

    public void multiply(TransferFunction that) {
        this.numerador = this.numerador.multiply(that.numerador);
        this.denominador = this.denominador.multiply(that.denominador);
    }

    public Complex[] getZeros() {
        if(numerador.getCoefficients().length > 1) {
            LaguerreSolver laguerreSolver = new LaguerreSolver();
            return laguerreSolver.solveAllComplex(numerador.getCoefficients(), 0, 100000);
        } else return new Complex[0];
    }

    public Complex[] getPoles() {
        if(denominador.getCoefficients().length > 1) {
            LaguerreSolver laguerreSolver = new LaguerreSolver();
            return laguerreSolver.solveAllComplex(denominador.getCoefficients(), 0, 100000);
        } else return new Complex[0];
    }

    public double[] getModule(double[] omegaRange) {
        Complex[] approximationResult = evaluateApproximationAtRange(omegaRange);
        double[] moduleResult = new double[omegaRange.length];
        for (int i = 0; i < moduleResult.length; i++) {
            moduleResult[i] = approximationResult[i].abs();
        }
        return moduleResult;
    }

    public double[] getModuleDB(double[] omegaRange) {
        double[] moduleResult = getModule(omegaRange);
        for (int i = 0; i < moduleResult.length; i++) {
            moduleResult[i] = 20 * Math.log10(moduleResult[i]);
        }
        return moduleResult;
    }

    public double[] getPhase(double[] omegaRange) {
        Complex[] approximationResult = evaluateApproximationAtRange(omegaRange);
        if(omegaRange.length > 1) {
            double offset = 0;
            double[] phaseResult = new double[omegaRange.length];
            double current = approximationResult[0].getArgument() + offset;
            double next;
            int i;
            for (i = 1; i < phaseResult.length; i++) {
                phaseResult[i-1] = current;
                next = approximationResult[i].getArgument() + offset;
                if( Math.abs(current - next) > Math.PI*0.95) {
                    if(!areZerosBetween(omegaRange[i-1],omegaRange[i])) {
                        offset -= 2. * Math.PI;
                        next -= 2. * Math.PI;
                    }
                    else if(next < current) {
                        offset += 2. * Math.PI;
                        next += 2. * Math.PI;
                    }
                }
                current = next;
            }
            phaseResult[i-1] = current;
            return phaseResult;
        }
        else return new double[] {approximationResult[0].getArgument()};
    }

    private boolean areZerosBetween(double w1, double w2){
        for(Complex x : getZeros())
            if((x.abs() > w1 && x.abs() < w2) || (x.abs() < w1 && x.abs() > w2)) return true;
        return false;
    }

    public double[] getImpulseResponse(double[] time) {
        double[] impulse = new double[time.length];
        for (int i = 0; i < time.length; i++) {
            impulse[i] = getImpulseResponseAtTime(time[i]);
        }
        return impulse;
    }

    public double[] getStepResponse(double[] time) {
        double[] s = {0,1};
        PolynomialFunction num = numerador;
        PolynomialFunction den = denominador.multiply(new PolynomialFunction(s));

//        double[] impulse = getImpulseResponse(time);
//        double[] step = new double[time.length];
//        double cumSum = 0;
//        for (int i = 0; i < impulse.length; i++) {
//            step[i] = cumSum;
//            cumSum += impulse[i];
//        }
//        return step;

        return new TransferFunction(num, den).getImpulseResponse(time);
    }

    public double getImpulseResponseAtTime(double time) {
        // aca calculo la funcion de transferencia para un delta t en particular
        // delta t para derivar en el caso de grado num igual a grado den
        // TODO: Hacer el backup de las variables internas que se necesitan reutilizar.
        preloadRoots();
        calculatePoleOrders();

        Complex result;
        if (numeradorRootList.size() < denominadorRootList.size()) {
            //primero verifico si el grado del polinomio del numerador es menor al grado del polinomio del denominador.
            result = calculateResidueResult(time); //llamo a la funcion que haya el residuo
        } else {
            //si los grados de los polinomios son iguales, divido por S y derivo la antitransformada
            int derivativeOrder = 0;
            while (numeradorRootList.size() >= denominadorRootList.size()) {
                addPoleToSolve();
                derivativeOrder++;
            }
            result = calculateDerivative(time, derivativeOrder);
        }
        return result.getReal();
    }

    public boolean isPureLowpass() {
        return numerador.degree() == 0;
    }

    public TransferFunction denormalize(SuperTemplate Template, double denorm) {
        if (Template instanceof LowpassTemplate)
            return denormalize((LowpassTemplate) Template, denorm);
        else if (Template instanceof HighpassTemplate)
            return denormalize((HighpassTemplate) Template, denorm);
        else if (Template instanceof BandpassTemplate)
            return denormalize((BandpassTemplate) Template, denorm);
        else if (Template instanceof BandrejectTemplate)
            return denormalize((BandrejectTemplate) Template, denorm);
        else if (Template instanceof DelayTemplate)
            return denormalize((DelayTemplate) Template, denorm);
        else
            return new TransferFunction(new double[]{1}, new double[]{1});
    }

    public TransferFunction denormalize(LowpassTemplate lowpassTemplate, double denorm) {
        double wd = lowpassTemplate.getWp() * denorm;

        double[] currentDen = denominador.getCoefficients();
        double[] currentNum = numerador.getCoefficients();

        double[] denormalizedDen = new double[currentDen.length];
        double[] denormalizedNum = new double[currentNum.length];

        for (int i = 0; i < currentDen.length; i++)
            denormalizedDen[i] = currentDen[i] * Math.pow(1.0 / wd, i);

        for (int i = 0; i < currentNum.length; i++)
            denormalizedNum[i] = currentNum[i] * Math.pow(1.0 / wd, i);

        return new TransferFunction(denormalizedNum, denormalizedDen);
    }

    public TransferFunction denormalize(DelayTemplate delayTemplate, double denorm) {
        double wd = delayTemplate.getWp() * denorm;

        double[] currentDen = denominador.getCoefficients();
        double[] currentNum = numerador.getCoefficients();

        double[] denormalizedDen = new double[currentDen.length];
        double[] denormalizedNum = new double[currentNum.length];

        for (int i = 0; i < currentDen.length; i++)
            denormalizedDen[i] = currentDen[i] * Math.pow(1.0 / wd, i);

        for (int i = 0; i < currentNum.length; i++)
            denormalizedNum[i] = currentNum[i] * Math.pow(1.0 / wd, i);

        return new TransferFunction(denormalizedNum, denormalizedDen);
    }
    
    public TransferFunction denormalize(HighpassTemplate highpassTemplate, double denorm) {
        double wd = highpassTemplate.getWp() / denorm;

        double[] currentDen = denominador.getCoefficients();
        double[] currentNum = numerador.getCoefficients();

        double[] denormalizedDen = new double[currentDen.length];
        double[] denormalizedNum = new double[currentDen.length];

        for (int i = 0; i < currentDen.length; i++)
            denormalizedDen[i] = currentDen[i] * Math.pow(wd, i);

        for (int i = 0; i < currentNum.length; i++)
            denormalizedNum[i] = currentNum[i] * Math.pow(wd, i);

        ArrayUtils.reverse(denormalizedDen);
        ArrayUtils.reverse(denormalizedNum);

        return new TransferFunction(denormalizedNum, denormalizedDen);
    }

    public TransferFunction denormalize(BandpassTemplate bandpassTemplate, double denorm) {
        double Bd = bandpassTemplate.getB() * denorm;
        double wo = bandpassTemplate.getWo();
        double[] currentDen = denominador.getCoefficients();
        double[] currentNum = numerador.getCoefficients();
        int denominatorDegree = currentDen.length - currentNum.length; // Defino por que potencia de S tengo que multiplicar y dividir
        PolynomialFunction denpol = finalPolinomeBandPass(currentDen, 0, Bd, wo); // creo el nuevo cociente
        PolynomialFunction numpol = finalPolinomeBandPass(currentNum, denominatorDegree, Bd, wo);
        return new TransferFunction(numpol, denpol);
    }

    public TransferFunction denormalize(BandrejectTemplate bandrejectTemplate, double denorm) {
        double Bd = (bandrejectTemplate.getB() / denorm);
        double wo = bandrejectTemplate.getWo();
        double[] currentDen = denominador.getCoefficients();
        double[] currentNum = numerador.getCoefficients();
        int denominatorDegree = currentDen.length - currentNum.length;// Defino por que potencia de S tengo que multiplicar y dividir
        PolynomialFunction denpol = finalPolinomeBandReject(currentDen, 0, Bd, wo);// Creo el nuevo cociente
        PolynomialFunction numpol = finalPolinomeBandReject(currentNum, denominatorDegree, Bd, wo);
        return new TransferFunction(numpol, denpol);
    }

    //<editor-fold desc="Internal Functions of Passband and Bandreject Approximations">
    private PolynomialFunction finalPolinomeBandPass(double[] originalpol, int multiplicatororder, double B, double wo) {
        int coefiterator; // Con este manejo el término del polinomio que estoy expandiendo
        double[] fix = {0}; // Para crear un polinomio vacio
        double[] addattheend = new double[originalpol.length];//aca meto el termino independiente del pol original multiplicado por s
        PolynomialFunction polinome; // COn este creo los polinomios intermedios
        PolynomialFunction finalpolinome = new PolynomialFunction(fix);

        for (coefiterator = 1; coefiterator < originalpol.length; coefiterator++) {
            polinome = turnDouble2PolynomePass(originalpol, coefiterator, B, wo);
            finalpolinome = finalpolinome.add(polinome); // Voy sumando los polinomios expandidos
        }
        addattheend[addattheend.length - 1] = originalpol[0]; // Al final le sumo el término independiente
        finalpolinome = finalpolinome.add(new PolynomialFunction(addattheend));

        if (multiplicatororder > 0) { // Si multiplique por S de un orden mayor que el orden del polinomio, corrijo con este algoritmo:
            double[] corrector = new double[multiplicatororder + 1];
            corrector[corrector.length - 1] = 1;// Simplemente multiplico lo ya hecho por un S de orden tal que cubra la diferencia
            finalpolinome = finalpolinome.multiply(new PolynomialFunction(corrector));
        }

        return finalpolinome;
    }

    private PolynomialFunction turnDouble2PolynomePass(double[] originalpolinome, int iteration, double bandwidth, double centerFrequency) {
        PolynomialFunction returnthis;
        double[] currentpolinome;
        double[] multiplicator = new double[originalpolinome.length - iteration]; // Con esto luego multiplico por S de orden tal que no queden cocientes

        currentpolinome = newtonExpands(iteration, originalpolinome[iteration], bandwidth, centerFrequency);// Expando cada binomio en newton
        returnthis = new PolynomialFunction(currentpolinome);
        multiplicator[originalpolinome.length - iteration - 1] = 1;
        returnthis = returnthis.multiply(new PolynomialFunction(multiplicator));// Devuelvo el polinomio listo para ser sumado

        return returnthis;
    }

    private PolynomialFunction finalPolinomeBandReject(double[] originalpol, int multiplicatororder, double B, double wo) {
        int coefiterator;
        double[] addattheend = new double[originalpol.length];// Con esto voy a agregar el termino independiente (en este caso el coeficiente de mayor grado) al final
        double[] fix = {0};
        PolynomialFunction polinome;
        PolynomialFunction finalpolinome = new PolynomialFunction(fix);

        for (coefiterator = 1; coefiterator < originalpol.length; coefiterator++) {
            polinome = turnDouble2PolynomeReject(originalpol, coefiterator, B, wo);
            finalpolinome = finalpolinome.add(polinome);// Voy sumando los polinomios ya expandidos y corregidos
        }

        addattheend[addattheend.length - 1] = originalpol[originalpol.length - 1];
        finalpolinome = finalpolinome.add(new PolynomialFunction(addattheend));// Aca agrego el que habia quedado como término independiente

        if (multiplicatororder > 0) {// Si el polinomio fue multiplicado por un término de grado mayor al necesario, agrego esa parte con este algoritmo:
            double[] corrector = newtonExpands(multiplicatororder, 1, B, wo);
            finalpolinome = finalpolinome.multiply(new PolynomialFunction(corrector));
        }

        return finalpolinome;
    }

    private PolynomialFunction turnDouble2PolynomeReject(double[] originalpolinome, int iteration, double bandwidth, double centerFrequency) {
        PolynomialFunction returnthis;
        double[] currentpolinome;
        double[] multiplicator = new double[originalpolinome.length - iteration]; // Con esto multiplico por S de orden tal que no queden S dividiendo

        currentpolinome = newtonExpands(iteration, originalpolinome[originalpolinome.length - 1 - iteration], bandwidth, centerFrequency);// Expando el termino con binomio de newton para poder operar con el
        returnthis = new PolynomialFunction(currentpolinome);// acá transformo el polinomio de double[] a polynome
        multiplicator[originalpolinome.length - iteration - 1] = 1;// multiplico por S^(orden total - orden del termino)
        returnthis = returnthis.multiply(new PolynomialFunction(multiplicator)); //Lo devuelvo listo para ser sumado

        return returnthis;
    }

    private double[] newtonExpands(int n, double coef, double bandwidth, double centerFrequency) { // Esta funcion expande un binomio en un polinomio
        int iterate; //esta es la potencia de S
        int kadvancer = 0; //este es K de la sumatoria
        double[] thispolinome = new double[2 * n + 1];// El tamaño va a ser de 2n (por la potencia maxima) +  1 (por el termino independiente)
        for (iterate = 0; iterate < 2 * n + 1; iterate = iterate + 2) { //
            thispolinome[iterate] = coef * Math.pow(1 / (bandwidth * centerFrequency), n) * newtonTerm(n, kadvancer, centerFrequency);
            kadvancer++;
        }
        return thispolinome;
    }

    private double newtonTerm(int n, int k, double centerFrequency) {// Esta funcion devuelve el coeficiente del termino k del polinomio de newton
        double tobereturned = CombinatoricsUtils.binomialCoefficientDouble(n, k) * Math.pow(centerFrequency, 2 * (n - k));
        return tobereturned;
    }
    //</editor-fold>

    //<editor-fold desc="Internal Functions of Impulse Response">
    private void preloadRoots() {
        Complex[] numeradorRoots = factorPolynomial(numerador);
        Complex[] denominadorRoots = factorPolynomial(denominador);
        //factorizo ambos polinomios:
        for (int i = 0; i < numeradorRoots.length; i++) {
            //redondeo las raices porque sino tira fruta
            numeradorRoots[i] = new Complex((double) Math.round(numeradorRoots[i].getReal() * 100000) / 100000,
                    (double) Math.round(numeradorRoots[i].getImaginary() * 100000) / 100000);
        }
        for (int i = 0; i < denominadorRoots.length; i++) {
            //redondeo las raices porque sino tira fruta
            denominadorRoots[i] = new Complex((double) Math.round(denominadorRoots[i].getReal() * 100000) / 100000,
                    (double) Math.round(denominadorRoots[i].getImaginary() * 100000) / 100000);
        }

        //entro a la funcion que simplifica raices comunes
        simplifyRoots(numeradorRoots, denominadorRoots);
    }

    private Complex[] factorPolynomial(PolynomialFunction polynomial) {

        if (polynomial.degree() > 0) {
            //implemento esta funcion para corregir el caso en el que no haya raices
            LaguerreSolver laguerreSolver = new LaguerreSolver();
            Complex[] polynomialRoots = laguerreSolver.solveAllComplex(polynomial.getCoefficients(), 0);
            return polynomialRoots;
        } else {
            Complex[] returnValue = {new Complex(polynomial.getCoefficients()[0])};
            return returnValue;
        }
    }

    private void simplifyRoots(Complex[] numeradorRoots, Complex[] denominadorRoots) {
        //transformo los arreglos en listas para mejor manejo
        List<Complex> numeradorRootList = new ArrayList<>(Arrays.asList(numeradorRoots));
        List<Complex> denominadorRootList = new ArrayList<>(Arrays.asList(denominadorRoots));
        List<Complex> common = new ArrayList<>(numeradorRootList);
        common.retainAll(denominadorRootList); //aca busco los factores comunes
        //ahora hago efectivamente la acción de simplificar en ambos polinomios

        if (!common.isEmpty() && numerador.degree() > 0 && denominador.degree() > 0) {
            //simplifico SOLO si ninguno de los dos es una cte
            for (Complex commoniter : common) {
                while (numeradorRootList.contains(commoniter) && denominadorRootList.contains(commoniter)) {
                    //lo hago con while
                    numeradorRootList.remove(commoniter);//para contemplar raices multiples
                    denominadorRootList.remove(commoniter);
                }
            }
        }
        this.numeradorRootList = numeradorRootList;
        this.denominadorRootList = denominadorRootList; //guardo los polinomios factorizados en las variables de la clase
    }

    private boolean calculatePoleOrders() {
        // ahora armo las tablas que tenian como key los polos y como value el orden de los mismos
        Hashtable<Complex, Integer> numeradorPoleOrderTable = new Hashtable<>();
        Hashtable<Complex, Integer> denominadorPoleOrderTable = new Hashtable<>();
        // primero lo hago con el numerador:
        if (numerador.degree() > 0) {
            for (Complex numeradorRoot : numeradorRootList) {
                //ese if verifica de no contar varias veces la misma raiz
                if (!numeradorPoleOrderTable.containsKey(numeradorRoot))
                    numeradorPoleOrderTable.put(numeradorRoot, Collections.frequency(numeradorRootList, numeradorRoot));
            }
        } else
            numeradorPoleOrderTable.put(new Complex((numerador.getCoefficients())[0]), 0);

        //ahora con el denominador
        if (denominador.degree() > 0) {
            for (Complex denominadorRoot : denominadorRootList) {
                if (!denominadorPoleOrderTable.containsKey(denominadorRoot))
                    denominadorPoleOrderTable.put(denominadorRoot, Collections.frequency(denominadorRootList, denominadorRoot));
            }
        } else
            denominadorPoleOrderTable.put(new Complex(denominador.getCoefficients()[0]), 0);

        this.numeradorPoleOrderTable = numeradorPoleOrderTable; //guardo las tablas conla informacion en las variables de la clase
        this.denominadorPoleOrderTable = denominadorPoleOrderTable;

        //dejo un return por posibles errores para el futuro
        return true;
    }

    private Complex calculateDerivative(double time, int order) {//PROBAAAAAAAAAAAAAAAAAAR
        double deltaT = 0.00005;  //delta t para derivar en el caso de grado num igual a grado den
        Complex posteriorValue; //esta la uso para derivar
        Complex priorValue;
        Complex derivative;
        if (order == 1) {
            priorValue = calculateResidueResult(time - deltaT);
            posteriorValue = calculateResidueResult(time + deltaT);
            derivative = (posteriorValue.subtract(priorValue)).divide(2 * deltaT);
        } else {
            priorValue = calculateDerivative(time - deltaT, order - 1);
            posteriorValue = calculateDerivative(time + deltaT, order - 1);
            derivative = posteriorValue.subtract(priorValue).divide(2 * deltaT);
        }
        return derivative;
    }

    private void addPoleToSolve() {
        denominadorRootList.add(new Complex(0)); //aca estoy dividiendo por s
        if (denominadorPoleOrderTable.contains(new Complex(0))) {
            //me fijo si ya esta la raiz 0,
            int originalOrder = denominadorPoleOrderTable.get(new Complex(0));
            denominadorPoleOrderTable.remove(new Complex(0));
            //si es asi, le cambio el orden
            denominadorPoleOrderTable.put(new Complex(0), ++originalOrder);
        } else {
            //si no simplemente lo agrego
            denominadorPoleOrderTable.put(new Complex(0), 1);
        }
    }

    private Complex calculateResidueResult(double time) {
        Complex result = new Complex(0);
        Set<Complex> denominatorKeys = denominadorPoleOrderTable.keySet();//hago iteradores para iterar sobre la hash tabla
        for (Complex element : denominatorKeys) {
            //primero hago los residuos de orden 1
            if (denominadorPoleOrderTable.get(element) == 1) {
                //llamo a los residuos y los voy sumando
                result = result.add(getResidualForSimpleRoot(time, element));
            } else if (denominadorPoleOrderTable.get(element) > 1) {
                //aca hago las de orden 2.
                result = result.add(getResidualForMultipleRoots(time, element, denominadorPoleOrderTable.get(element) - 1));
            }
        }
        return result;
    }

    private Complex getResidualForSimpleRoot(double time, Complex root) {

        Complex neperian = new Complex(2.71828182846); //creo el numero E porque no andaba exp
        Complex value = new Complex(1); //creo el valor de retorno

        if (numerador.degree() > 0) {
            for (Complex element : numeradorRootList) {
                value = value.multiply(root.subtract(element)); //primero resuelvo la parte del numerador de los residuos
            }
        } else {
            value = value.multiply(numerador.getCoefficients()[0]);
        }
        for (Complex element : denominadorRootList) {//RESOLVERESTO
            if (element.subtract(root).abs() > 0.001) { //ahora resuelvo la parte del denominador, obviamente simplificando
                value = value.divide(root.subtract(element));//al punto donde evaluo el residuo
            }
        }
        value = value.multiply(neperian.pow(root.multiply(time)));//ahora multiplico por la exponencial
        return value;
    }

    private Complex getResidualForMultipleRoots(double time, Complex root, int order) {
        Complex priorValue;
        Complex posteriorValue;
        Complex derivativeValue;
        Complex deltaZ = new Complex(0.00005);
        if (order == 1) {
            priorValue = getResidualForSimpleRoot(time, root.subtract(deltaZ));//aca hago el residuo en un deta z anterior
            posteriorValue = getResidualForSimpleRoot(time, root.add(deltaZ));//aca en un delta z posterior
            derivativeValue = (posteriorValue.subtract(priorValue)).divide(deltaZ.multiply(2)); //aca resuelvo la derivada

        } else {
            priorValue = getResidualForMultipleRoots(time, root.subtract(deltaZ), order - 1);
            posteriorValue = getResidualForMultipleRoots(time, root.add(deltaZ), order - 1);
            derivativeValue = (posteriorValue.subtract(priorValue)).divide(deltaZ.multiply(2));
        }
        return derivativeValue;
    }
    //</editor-fold>

    public static void executeTest() {

        Complex zero1 = new Complex(2, 3);

        Complex[] zeros = {zero1};


        TransferFunction tf = new TransferFunction(zeros, zeros);

        System.out.println(Arrays.toString(tf.numerador.getCoefficients()));
        System.out.println(Arrays.toString(tf.denominador.getCoefficients()));

    }
}
</file>

<file path="Aproximaciones/src/thirdstage/ComponentsPanel.java">
package thirdstage;

import Data.Singleton;
import mathematics.Stage;
import org.apache.commons.math3.analysis.solvers.LaguerreSolver;
import org.apache.commons.math3.complex.Complex;

import javax.swing.*;
import java.util.List;

public class ComponentsPanel extends JPanel{
    private DefaultListModel<String> componentListModel = new DefaultListModel<>();
    private JList<String> componentList = new JList<>(componentListModel);

	ComponentsPanel(){
        setBorder(BorderFactory.createTitledBorder("Components"));

        componentList.setLayoutOrientation(JList.HORIZONTAL_WRAP);
        JScrollPane componentListScroller = new JScrollPane(componentList);

        updateComponentList();

        //Setup layout
        GroupLayout layout = new GroupLayout(this);
        this.setLayout(layout);
        layout.setAutoCreateGaps(true);
        layout.setAutoCreateContainerGaps(true);
        layout.setHorizontalGroup(layout.createSequentialGroup().addComponent(componentListScroller));
        layout.setVerticalGroup(layout.createSequentialGroup().addComponent(componentListScroller));
	}

    public void updateComponentList() {
        Singleton s = Singleton.getInstance();
        Singleton_S3 s3 = Singleton_S3.getInstance();

        List<Stage> currentStage = s.getUserData().getStageList();
        int index = s3.getStagePanel().getSelectedIndex();

        if ( index != -1 ) {
            double Q = currentStage.get(index).getQ();
            double wo = currentStage.get(index).getPoles()[0].getImaginary();
            double G = currentStage.get(index).getGdB();

            if ( s3.getTopologyConfigPanel().getIndex() != -1 ) {
                switch (s3.getTopologyConfigPanel().getSelectedString()) {
                    case "HPSallen":
                        getHPSallen(Q, wo, G);
                        break;
                    case "LPSallen":
                        getLPSallen(Q, wo, G);
                        break;
                    case "LPAckerberg Mossberg":
                        getAckerbergMossberg(Q, wo, G);
                        break;
                    case "HPAckerberg Mossberg":
                        getAckerbergMossberg(Q, wo, G);
                        break;
                    case "BSAckerberg Mossberg":
                        getAckerbergMossberg(Q, wo, G);
                        break;
                    case "BPAckerberg Mossberg":
                        getAckerbergMossberg(Q, wo, G);
                        break;
                    case "BPRauch":
                        getBPRauch(Q, wo, G);
                        break;
                    case "BPSallen":
                        getBPSallen(Q, wo, G);
                        break;
                    case "LPFleischer Tow":
                        getFleischerTow(Q, wo, G);
                        break;
                    case "HPFleischer Tow":
                        getFleischerTow(Q, wo, G);
                        break;
                    case "BSFleischer Tow":
                        getFleischerTow(Q, wo, G);
                        break;
                    case "BPFleischer Tow":
                        getFleischerTow(Q, wo, G);
                        break;
                    case "LPKerwin Huelsman Newcomb":
                        getKHN(Q, wo, G);
                        break;
                    case "HPKerwin Huelsman Newcomb":
                        getKHN(Q, wo, G);
                        break;
                    case "BSKerwin Huelsman Newcomb":
                        getKHN(Q, wo, G);
                        break;
                    case "BPKerwin Huelsman Newcomb":
                        getKHN(Q, wo, G);
                        break;
                    case "LPTow Thomas":
                        getTT(Q, wo, G);
                        break;
                    case "HPTow Thomas":
                        getTT(Q, wo, G);
                        break;
                    case "BSTow Thomas":
                        getTT(Q, wo, G);
                        break;
                    case "BPTow Thomas":
                        getTT(Q, wo, G);
                        break;
                    case "LPRauch":
                        getLPRauch(Q, wo, G);
                        break;
                    case "HPRauch":
                        getHPRauch(Q, wo, G);
                        break;
                    default:
                        System.out.println("Se te escapó un switch case! Ojo!");
                        break;
                }
            }
        }
    }

    //Sallen Key
    private void getLPSallen(double Q, double wo, double G) {
        componentListModel.removeAllElements();

        double Ra = 1000;
        double Rb;
        double R1;
        double R2;
        double C1 = 1000;
        double C2;

        Rb = (Math.pow(10, G/20)*Ra);
        LaguerreSolver laguerreSolver = new LaguerreSolver();
        double[] coefficients = {2+G, -1/Q, 1};
        Complex[] r2 = laguerreSolver.solveAllComplex( coefficients, 10 );
        if ( r2[0].getReal() < 0 ) {
            R2 = Math.abs(r2[1].getReal());
        }
        else {
            R2 = r2[0].getReal();
        }

        R1 = 1/(R2*Math.sqrt(wo*C1));
        C2 = C1;

        componentListModel.addElement( "| R1 = " + R1 + " |" );
        componentListModel.addElement( "| R2 = " + R2 + " |" );
        componentListModel.addElement( "| RA = " + Ra + " |" );
        componentListModel.addElement( "| RB = " + Rb + " |" );
        componentListModel.addElement( "| C1 = " + C1 + " |" );
        componentListModel.addElement( "| C2 = " + C2 + " |" );
    }
    private void getHPSallen(double Q, double wo, double G) {
        componentListModel.removeAllElements();

        double Ra = 1000;
        double Rb;
        double R1;
        double R2;
        double C1 = 1000;
        double C2;

        Rb = (Math.pow(10, G/20)*Ra);
        LaguerreSolver laguerreSolver = new LaguerreSolver();
        double[] coefficients = {1-G, -2/Q, 1};
        Complex[] r2 = laguerreSolver.solveAllComplex( coefficients, 10 );
        if ( r2[0].getReal() < 0 ) {
            R2 = Math.abs(r2[1].getReal());
        }
        else {
            R2 = r2[0].getReal();
        }

        R1 = 1/(R2*Math.sqrt(wo*C1));
        C2 = C1;

        componentListModel.addElement( "| R1 = " + R1 + " |" );
        componentListModel.addElement( "| R2 = " + R2 + " |" );
        componentListModel.addElement( "| RA = " + Ra + " |" );
        componentListModel.addElement( "| RB = " + Rb + " |" );
        componentListModel.addElement( "| C1 = " + C1 + " |" );
        componentListModel.addElement( "| C2 = " + C2 + " |" );
    }
    private void getBPSallen(double Q, double wo, double G) {
        //TODO: esta aun es chamuyo
        componentListModel.removeAllElements();

        double Ra = 1000;
        double Rb;
        double R1;
        double R2;
        double R3;
        double C1 = 1000;
        double C2;

        Rb = (Math.pow(10, G/20)*Ra);
        LaguerreSolver laguerreSolver = new LaguerreSolver();
        double[] coefficients = {1-G, -2/Q, 1};
        Complex[] r2 = laguerreSolver.solveAllComplex( coefficients, 10 );
        if ( r2[0].getReal() < 0 ) {
            R2 = Math.abs(r2[1].getReal());
        }
        else {
            R2 = r2[0].getReal();
        }

        R1 = 1/(R2*Math.sqrt(wo*C1));
        C2 = C1;
        R3 = R1;

        componentListModel.addElement( "| R1 = " + R1 + " |" );
        componentListModel.addElement( "| R2 = " + R2 + " |" );
        componentListModel.addElement( "| R3 = " + R3 + " |");
        componentListModel.addElement( "| RA = " + Ra + " |" );
        componentListModel.addElement( "| RB = " + Rb + " |" );
        componentListModel.addElement( "| C1 = " + C1 + " |" );
        componentListModel.addElement( "| C2 = " + C2 + " |" );
    }
    //Rauch
    private void getBPRauch(double Q, double w0, double midBandGaindb){
        componentListModel.removeAllElements();

        //Componentes del circuito
        double R1 = 50000;    //Seteado en 50k para tener buenos valores de Zin
        double C2;   //C2==C3
        double C3;
        double R4;
        double R5;
        double Rx1;
        double Rx2;

        //Formas de calcularlo
        double Qo = 1.5;
        double alpha = (2.*(1-Qo/Q))/9.;
        double K = alpha/(1+alpha);
        double gain= Math.pow(10,midBandGaindb/20.);
        double H = (gain*Qo*(1-K))/Q;
        double a = H/(2*Math.pow(Qo,2));
        C2 = (2*Qo)/(w0*9*a*R1);
        C3 = C2;
        double R = R1*a;
        R4 = R/(1-a);
        R5 = 9*R;
        double Rx = 10000;    //seteo resistencia media de salida en 10 k porque si, esto es una monarquía
        Rx1 = Rx*(1-K);
        Rx2 = Rx*K;

        componentListModel.addElement( "| R1 = " + R1 + " |" );
        componentListModel.addElement( "| R2 = " + Rx2 + " |" );
        componentListModel.addElement( "| Rx1 = " + Rx1 + " |" );
        componentListModel.addElement( "| R4 = " + R4 + " |" );
        componentListModel.addElement( "| R5 = " + R5 + " |" );
        componentListModel.addElement( "| C2 = " + C2 + " |" );
        componentListModel.addElement( "| C3 = " + C3 + " |" );
    }
    private void getLPRauch(double Qp, double wp, double gainDb) {
        componentListModel.removeAllElements();

        /*Componentes a definir*/
        double R1;
        double R2;
        double R3;
        double C4=Math.pow(10,-9);  //Seteo capacitor en 1 nF porque me pinto el ojete
        double C5;

        double gain=Math.pow(10,gainDb/20.);
        double m=0.5*(Math.pow(1./(4*Math.pow(Qp,2)*(1.+gain)),0.5));
        C5=Math.pow(m,2)*C4;
        R2=(1.+Math.pow(1.-4.*(1+gain)*(Math.pow(m*Qp,2)),0.5))/(2.*wp*Qp*Math.pow(m,2)*C4);
        R1=R2/gain;
        R3=1./(R2*Math.pow(m*wp*C4,2));

        componentListModel.addElement( "| R1 = " + R1 + " |" );
        componentListModel.addElement( "| R2 = " + R2 + " |" );
        componentListModel.addElement( "| R3 = " + R3 + " |" );
        componentListModel.addElement( "| C4 = " + C4 + " |" );
        componentListModel.addElement( "| C5 = " + C5 + " |" );
    }
    private void getHPRauch(double Qp, double wp, double gainDb) {
        componentListModel.removeAllElements();

        double C1=Math.pow(1.5*10,-9);  //1.5 nano porque pinto gira
        double C2;
        double C3;
        double R4;
        double R5;

        double gain=Math.pow(10,gainDb/20.);
        double m=0.5;
        C3=Math.pow(m,2)*C1;
        C2=C1/gain;
        R4=gain/(wp*Qp*C1*(1+(Math.pow(m,2)+1)*gain));
        R5=(Qp*(1+(Math.pow(m,2)+1)*gain))/(wp*C1*Math.pow(m,2));

        componentListModel.addElement( "| C1 = " + C1 + " |" );
        componentListModel.addElement( "| C2 = " + C2 + " |" );
        componentListModel.addElement( "| R3 = " + C3 + " |" );
        componentListModel.addElement( "| R4 = " + R4 + " |" );
        componentListModel.addElement( "| R5 = " + R5 + " |" );
    }
    //Universales
    private void getKHN(double Q, double wo, double G) {
        componentListModel.removeAllElements();

        //Componentes del Circuito
        double R4 = 47000;
        double R6;
        double R1 = 1000;
        double R3 = 47000;  //Zin
        double R5;
        double R2;
        double R7 = 1000;
        double R8;
        double R9;
        double Rg;
        double C1;
        double C2;

        //Calculo
        Rg = 2*Q/R4;
        C1 = 1/(wo*R1);
        R6 = Math.pow(10, G/20)*R3;


        C2 = C1;
        R2 = R1;
        R5 = R6;
        R8 = R7;
        R9 = R7;

        componentListModel.addElement( "| R4 = " + R4 + " |" );
        componentListModel.addElement( "| R6 = " + R6 + " |" );
        componentListModel.addElement( "| R1 = " + R1 + " |" );
        componentListModel.addElement( "| R3 = " + R3 + " |" );
        componentListModel.addElement( "| R5 = " + R5 + " |" );
        componentListModel.addElement( "| R2 = " + R2 + " |" );
        componentListModel.addElement( "| R7 = " + R7 + " (Only for Band Reject) |" );
        componentListModel.addElement( "| R8 = " + R8 + " (Only for Band Reject) |" );
        componentListModel.addElement( "| R9 = " + R9 + " (Only for Band Reject) |" );
        componentListModel.addElement( "| Rg = " + Rg + " |" );
        componentListModel.addElement( "| C1 = " + C1 + " |" );
        componentListModel.addElement( "| C2 = " + C2 + " |" );
    }
    private void getTT(double Q, double wo, double G) {
        componentListModel.removeAllElements();

        double R1 = 1000;
        double R3;
        double R4;
        double R6 = 1000;
        double R2;
        double R5;
        double R7 = 1000;
        double R8;
        double R9;
        double C1;
        double C2;

        R2 = Math.pow(10, G/20)*R1;
        C1 = 1/(R1*Math.pow(10, G/20));
        C1 = 1/(wo*R6);
        R3 = Q*R6;

        R4 = R6;
        R2 = R6;
        R5 = R6;
        C2 = C1;
        R8 = R7;
        R9 = R7;

        componentListModel.addElement( "| R6 = " + R6 + " |" );
        componentListModel.addElement( "| R5 = " + R5 + " |" );
        componentListModel.addElement( "| R1 = " + R1 + " |" );
        componentListModel.addElement( "| R4 = " + R4 + " |" );
        componentListModel.addElement( "| R2 = " + R2 + " |" );
        componentListModel.addElement( "| R3 = " + R3 + " |" );
        componentListModel.addElement( "| R7 = " + R7 + " (Only for Band Reject) |" );
        componentListModel.addElement( "| R8 = " + R8 + " (Only for Band Reject) |" );
        componentListModel.addElement( "| R9 = " + R9 + " (Only for Band Reject) |" );
        componentListModel.addElement( "| C1 = " + C1 + " |" );
        componentListModel.addElement( "| C2 = " + C2 + " |" );
    }
    private void getAckerbergMossberg(double Q, double wo, double G) {
        componentListModel.removeAllElements();

        double R1 = 1000;
        double R2 = 1000;
        double R3 = 1000;
        double R4;
        double R5;
        double R6;
        double R7 = 1000;
        double R8;
        double R9;
        double C1;
        double C2;

        R5 = Math.pow(10, G/20)*R1/Math.pow(wo, 2);
        C1 = 1/(wo*R3);
        R2 = Q/(wo*C1);

        C2 = C1;
        R4 = R3;
        R5 = R3;
        R6 = R3;
        R8 = R7;
        R9 = R7;

        componentListModel.addElement( "| R6 = " + R6 + " |" );
        componentListModel.addElement( "| R5 = " + R5 + " |" );
        componentListModel.addElement( "| R1 = " + R1 + " |" );
        componentListModel.addElement( "| R4 = " + R4 + " |" );
        componentListModel.addElement( "| R2 = " + R2 + " |" );
        componentListModel.addElement( "| R3 = " + R3 + " |" );
        componentListModel.addElement( "| R7 = " + R7 + " (Only for Band Reject) |" );
        componentListModel.addElement( "| R8 = " + R8 + " (Only for Band Reject) |" );
        componentListModel.addElement( "| R9 = " + R9 + " (Only for Band Reject) |" );
        componentListModel.addElement( "| C1 = " + C1 + " |" );
        componentListModel.addElement( "| C2 = " + C2 + " |" );
    }
    private void getFleischerTow(double Q, double wo, double G) {
        componentListModel.removeAllElements();

        double R1 = 1000;
        double R2;
        double R3 = 1000;
        double R4;
        double R5;
        double R6;
        double R7 = 1000;
        double R8;
        double R9;
        double C1;
        double C2;

        R5 = Math.pow(10, G/20)*R1/Math.pow(wo, 2);
        C1 = 1/(wo*R3);
        R2 = Q/(wo*C1);

        C2 = C1;
        R2 = R3;
        R4 = R3;
        R5 = R3;
        R6 = R3;
        R8 = R7;
        R9 = R7;

        componentListModel.addElement( "| R6 = " + R6 + " |" );
        componentListModel.addElement( "| R5 = " + R5 + " |" );
        componentListModel.addElement( "| R1 = " + R1 + " |" );
        componentListModel.addElement( "| R4 = " + R4 + " |" );
        componentListModel.addElement( "| R2 = " + R2 + " |" );
        componentListModel.addElement( "| R3 = " + R3 + " |" );
        componentListModel.addElement( "| R7 = " + R7 + " (Only for Band Reject) |" );
        componentListModel.addElement( "| R8 = " + R8 + " (Only for Band Reject) |" );
        componentListModel.addElement( "| R9 = " + R9 + " (Only for Band Reject) |" );
        componentListModel.addElement( "| C1 = " + C1 + " |" );
        componentListModel.addElement( "| C2 = " + C2 + " |" );
    }
}
</file>

<file path="Aproximaciones/src/thirdstage/FilterCircuitPanel.java">
package thirdstage;

import javax.imageio.ImageIO;
import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;

public class FilterCircuitPanel extends JPanel{
    private BufferedImage image;
    private Singleton_S3 s = Singleton_S3.getInstance();
    private JLabel imageLabel = s.getScaledImageLabel();
    //private JButton testButton = new JButton("Update Image");

	FilterCircuitPanel(){
		setBorder(BorderFactory.createTitledBorder("Filter Circuit"));

        /*testButton.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                updateImage("BPSallen");
            }
        });
*/
        this.add(imageLabel);
        //this.add(testButton);
    }

    public void updateImage(String path) {
        try {
            System.out.println("Looking for image" + path + ".jpg");
            Image image = ImageIO.read(new File("./images/" + path + ".jpg"));
            imageLabel.setIcon(new ImageIcon(image));
        }
        catch (IOException e) {
            e.printStackTrace();
        }
    }
}
</file>

<file path="Aproximaciones/src/thirdstage/ImageDrawer.java">
package thirdstage;

import java.awt.*;

/**
 * This utility class draws and scales an image to fit canvas of a component.
 * if the image is smaller than the canvas, it is kept as it is.
 *
 * @author www.codejava.net
 *
 */
public class ImageDrawer {

    public static void drawScaledImage(Image image, Component canvas, Graphics g) {
        int imgWidth = image.getWidth(null);
        int imgHeight = image.getHeight(null);

        double imgAspect = (double) imgHeight / imgWidth;

        int canvasWidth = canvas.getWidth();
        int canvasHeight = canvas.getHeight();

        double canvasAspect = (double) canvasHeight / canvasWidth;

        int x1 = 0; // top left X position
        int y1 = 0; // top left Y position
        int x2 = 0; // bottom right X position
        int y2 = 0; // bottom right Y position

        if (imgWidth < canvasWidth && imgHeight < canvasHeight) {
            // the image is smaller than the canvas
            x1 = (canvasWidth - imgWidth)  / 2;
            y1 = (canvasHeight - imgHeight) / 2;
            x2 = imgWidth + x1;
            y2 = imgHeight + y1;

        } else {
            if (canvasAspect > imgAspect) {
                y1 = canvasHeight;
                // keep image aspect ratio
                canvasHeight = (int) (canvasWidth * imgAspect);
                y1 = (y1 - canvasHeight) / 2;
            } else {
                x1 = canvasWidth;
                // keep image aspect ratio
                canvasWidth = (int) (canvasHeight / imgAspect);
                x1 = (x1 - canvasWidth) / 2;
            }
            x2 = canvasWidth + x1;
            y2 = canvasHeight + y1;
        }

        g.drawImage(image, x1, y1, x2, y2, 0, 0, imgWidth, imgHeight, null);
    }
}
</file>

<file path="Aproximaciones/src/thirdstage/PlotPanel.java">
package thirdstage;

import javax.swing.*;

public class PlotPanel extends JPanel{
	PlotPanel(){
		setBorder(BorderFactory.createTitledBorder("Panel para el plot"));
		setBounds(0, 0, 300, 200);
		
	}
}
</file>

<file path="Aproximaciones/src/thirdstage/ScaledImageLabel.java">
package thirdstage;

import javax.swing.ImageIcon;
import javax.swing.*;
import java.awt.*;

/**
 * This is an extended version of a JLabel which draws its icon image using
 * the ImageDrawer utility.
 *
 * @author www.codejava.net
 *
 */
public class ScaledImageLabel extends JLabel {
    protected void paintComponent(Graphics g) {
        ImageIcon icon = (ImageIcon) getIcon();
        if (icon != null) {
            ImageDrawer.drawScaledImage(icon.getImage(), this, g);
        }
    }
}
</file>

<file path="Aproximaciones/src/thirdstage/SensitivitiesPanel.java">
package thirdstage;

import javax.imageio.ImageIO;
import javax.swing.*;
import javax.swing.table.TableColumn;

import java.awt.*;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;

public class SensitivitiesPanel extends JPanel{
	private BufferedImage image;
	private Singleton_S3 s = Singleton_S3.getInstance();
	private JLabel imageLabel = new ScaledImageLabel();

	SensitivitiesPanel(){
		setBorder(BorderFactory.createTitledBorder("Sensitivities"));

		this.add(imageLabel);
	}

	public void updateImage(String path) {
		try {
			Image image = ImageIO.read(new File("./images/" + path + "Table.jpg"));
			imageLabel.setIcon(new ImageIcon(image));
		}
		catch (IOException e) {
			e.printStackTrace();
		}
	}
}
</file>

<file path="Aproximaciones/src/thirdstage/Singleton_S3.java">
package thirdstage;

import secondstage.PlotPoleZeroPanel;
import secondstage.PoleZeroListsPanel;
import secondstage.StageProperties;

/**
 * Created by NEGU on 10/11/2015.
 */
public class Singleton_S3 {
    private static final Singleton_S3 INSTANCE = new Singleton_S3();
    private Singleton_S3() {}
    public static Singleton_S3 getInstance() { return INSTANCE; }

    private FilterCircuitPanel filterCircuitPanel = null;
    private StagePropertiesPanel stagePropertiesPanel = null;
    private StagesSelectionPanel stagesSelectionPanel = null;
    private TopologyConfigPanel stageconfigpanel = null;
    private ComponentsPanel componentspanel= null;
    private SensitivitiesPanel sensitivitiespanel= null;
    private StagePanel stagepanel= null;
    private PlotPanel plotpanel= null;
    private PoleZeroListsPanel poleZeroListsPanel = null;
    private PlotPoleZeroPanel plotPoleZeroPanel = null;
    private StageProperties stageProperties = null;
    private ScaledImageLabel scaledImageLabel = null;

    public ScaledImageLabel getScaledImageLabel() {
        if (scaledImageLabel == null)
            scaledImageLabel = new ScaledImageLabel();
        return scaledImageLabel;
    }
    public PoleZeroListsPanel getPoleZeroListsPanel() {
        if (poleZeroListsPanel == null)
            poleZeroListsPanel = new PoleZeroListsPanel();
        return poleZeroListsPanel;
    }
    public PlotPoleZeroPanel getPlotPoleZeroPanel(){
        if (plotPoleZeroPanel == null)
            plotPoleZeroPanel = new PlotPoleZeroPanel();
        return plotPoleZeroPanel;
    }
    public StageProperties getStageProperties() {
        if ( stageProperties == null)
            stageProperties = new StageProperties();
        return stageProperties;
    }
    public PlotPanel getPlotPanel() {
        if (plotpanel == null)
        	plotpanel = new PlotPanel();
        return plotpanel;
    }
    public StagePanel getStagePanel() {
        if (stagepanel == null)
        	stagepanel = new StagePanel();
        return stagepanel;
    }
    public SensitivitiesPanel getSensitivitiesPanel() {
        if (sensitivitiespanel == null)
        	sensitivitiespanel = new SensitivitiesPanel();
        return sensitivitiespanel;
    }
    public ComponentsPanel getComponentsPanel() {
        if (componentspanel == null)
        	componentspanel = new ComponentsPanel();
        return componentspanel;
    }
    public TopologyConfigPanel getTopologyConfigPanel() {
        if (stageconfigpanel == null)
        	stageconfigpanel = new TopologyConfigPanel();
        return stageconfigpanel;
    }
    public FilterCircuitPanel getFilterCircuitPanel() {
        if (filterCircuitPanel == null)
            filterCircuitPanel = new FilterCircuitPanel();
        return filterCircuitPanel;
    }
    public StagePropertiesPanel getStagePropertiesPanel() {
        if (stagePropertiesPanel == null)
            stagePropertiesPanel = new StagePropertiesPanel();
        return stagePropertiesPanel;
    }
    public StagesSelectionPanel getStagesSelectionPanel() {
        if (stagesSelectionPanel == null)
            stagesSelectionPanel = new StagesSelectionPanel();
        return stagesSelectionPanel;
    }
    







}
</file>

<file path="Aproximaciones/src/thirdstage/StagePanel.java">
package thirdstage;

import Data.Singleton;
import mathematics.Stage;
import secondstage.PlotPoleZeroPanel;
import secondstage.PoleZeroListsPanel;
import secondstage.StageProperties;

import java.awt.*;
import java.awt.List;
import java.util.*;
import javax.swing.*;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;

public class StagePanel extends JPanel{
    private DefaultListModel<String> stagesListModel = new DefaultListModel<>();
    private JList<String> stagesList = new JList<>(stagesListModel);

	
	StagePanel() {
		Singleton_S3 s = Singleton_S3.getInstance();
        //Create the list
        stagesList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
        stagesList.setLayoutOrientation(JList.VERTICAL);
        JScrollPane stagesListScroller = new JScrollPane(stagesList);

        stagesList.getSelectionModel().addListSelectionListener(new ListSelectionListener() {
            @Override
            public void valueChanged(ListSelectionEvent e) {
                //TODO: poner que cambie la lista de filtros
                if (!stagesList.isSelectionEmpty()) {
                    s.getTopologyConfigPanel().updateList();
                    s.getComponentsPanel().updateComponentList();
                    s.getStageProperties().updateLabels(stagesList.getSelectedIndex());
                }
            }
        });

        this.add(stagesListScroller);
	}

    public void updateList() {
        //TODO: getear el index y volver a ponerlo de forma copada
        Singleton s = Singleton.getInstance();
        stagesListModel.removeAllElements();
        java.util.List<Stage> currentStageList = s.getUserData().getStageList();
        for (Stage x : currentStageList) {
            stagesListModel.addElement( x.getDetails() );
        }
    }

    public int getSelectedIndex() {
        if ( stagesList.isSelectionEmpty() ) {
            return -1;
        }
        else {
            return stagesList.getSelectedIndex();
        }
    }
}
</file>

<file path="Aproximaciones/src/thirdstage/StagePropertiesPanel.java">
package thirdstage;

import javax.swing.*;
//import java.awt.event.*;

public class StagePropertiesPanel extends JPanel{
        
	SensitivitiesPanel sensitivitiespanel = new SensitivitiesPanel();
	
	StagePropertiesPanel(){
        this.setLayout(new BoxLayout(this, BoxLayout.X_AXIS));
        //TODO: stageConfig, componentsPanel y sensitivitiesPanel implementar en distintos paneles
        
        Singleton_S3 s = Singleton_S3.getInstance();

        sensitivitiespanel= s.getSensitivitiesPanel();
        this.add(sensitivitiespanel);
	}
}
</file>

<file path="Aproximaciones/src/thirdstage/StagesSelectionPanel.java">
package thirdstage;

import secondstage.PlotPoleZeroPanel;
import secondstage.StageProperties;

import javax.swing.*;
import java.awt.*;

public class StagesSelectionPanel extends JPanel{
	FilterCircuitPanel filterCircuitPanel;
    StagePanel stagePanel;
    TopologyConfigPanel stageconfigpanel = new TopologyConfigPanel();
    ComponentsPanel componentspanel = new ComponentsPanel();
    StageProperties stageProperties;
    PlotPoleZeroPanel plotPoleZeroPanel;


	StagesSelectionPanel(){
		Singleton_S3 s = Singleton_S3.getInstance();
        //setBorder(BorderFactory.createTitledBorder("Stages"));
        this.setLayout(new BoxLayout(this, BoxLayout.X_AXIS));
        
        filterCircuitPanel = s.getFilterCircuitPanel();
        stagePanel = s.getStagePanel();
        componentspanel= s.getComponentsPanel();
        stageconfigpanel= s.getTopologyConfigPanel();
        stageProperties = s.getStageProperties();
        plotPoleZeroPanel = s.getPlotPoleZeroPanel();

       //Setup layout
        GroupLayout layout = new GroupLayout(this);
        this.setLayout(layout);
        layout.setAutoCreateGaps(true);
        layout.setAutoCreateContainerGaps(true);

        layout.setHorizontalGroup(
                layout.createSequentialGroup()
                        .addComponent(filterCircuitPanel)
                        .addGroup(layout.createParallelGroup()
                                .addComponent(stagePanel)
                                .addComponent(stageconfigpanel))
                        .addGroup(layout.createParallelGroup()
                                .addComponent(componentspanel)
                                .addComponent(stageProperties))
                        .addComponent(plotPoleZeroPanel)
        );
        layout.setVerticalGroup(
                layout.createParallelGroup()
                        .addComponent(filterCircuitPanel)
                        .addGroup(layout.createSequentialGroup()
                                .addComponent(stagePanel)
                                .addComponent(stageconfigpanel))
                        .addGroup(layout.createSequentialGroup()
                                .addComponent(componentspanel)
                                .addComponent(stageProperties))
                        .addComponent(plotPoleZeroPanel)
        );
        //layout.linkSize(SwingConstants.VERTICAL, filterCircuitPanel, stagePanel);
	}
}
</file>

<file path="Aproximaciones/src/thirdstage/StageThreePanel.java">
package thirdstage;



import javax.swing.*;
import java.awt.*;

public class StageThreePanel extends JPanel {
    private StagePropertiesPanel stagePropertiesPanel;
    private StagesSelectionPanel stagesSelectionPanel;
    private Singleton_S3 s = Singleton_S3.getInstance();

    public StageThreePanel() {
        this.setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));

        stagePropertiesPanel = s.getStagePropertiesPanel();
        stagesSelectionPanel = s.getStagesSelectionPanel();

        this.add(stagesSelectionPanel);
        this.add(stagePropertiesPanel);
    }

    public void set(){
        s.getStagePanel().updateList();
        Singleton_S3.getInstance().getPlotPoleZeroPanel().updatePoleZeroPlot();
        Singleton_S3.getInstance().getPlotPoleZeroPanel().updatePoleZeroColour();
    }
}
</file>

<file path="Aproximaciones/src/thirdstage/TopologyConfigPanel.java">
package thirdstage;

import Data.Singleton;
import mathematics.Stage;

import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.*;
import javax.swing.*;

public class TopologyConfigPanel extends JPanel {
	
	private JComboBox topologyList = new JComboBox();
	//private JTextField textfield = new JTextField("1000");

	TopologyConfigPanel(){
		setBorder(BorderFactory.createTitledBorder("Stage Configuration"));

        topologyList.addItem("LPSallen");

        topologyList.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                Singleton_S3 s = Singleton_S3.getInstance();
                s.getComponentsPanel().updateComponentList();
                if ( topologyList.getSelectedIndex() != -1 ) {
                    s.getFilterCircuitPanel().updateImage((String) topologyList.getSelectedItem());
                    s.getSensitivitiesPanel().updateImage((String) topologyList.getSelectedItem());
                }
            }
        });

        updateList();
		this.add(topologyList);
		//this.add(new JLabel("R1 [ohm]"));
		//this.add(textfield);
	}

	public int getIndex() {
        return topologyList.getSelectedIndex();
    }

    public void updateList() {
        Singleton s = Singleton.getInstance();
        Singleton_S3 s3 = Singleton_S3.getInstance();

        int index = s3.getStagePanel().getSelectedIndex();
        if ( index != -1 ) {
            List<Stage> currentStage = s.getUserData().getStageList();
            List<String> filterString = currentStage.get(index).getList();

            topologyList.removeAllItems();
            for (String x : filterString)
                topologyList.addItem(x);
        }
    }

    public String getSelectedString() { return (String) topologyList.getSelectedItem(); }
}
</file>

<file path="Aproximaciones/.gitignore">
# Covers JetBrains IDEs: IntelliJ, RubyMine, PhpStorm, AppCode, PyCharm, CLion, Android Studio

# User-specific stuff:
.idea/workspace.xml
.idea/tasks.xml
.idea/dictionaries
.idea/shelf

# Sensitive or high-churn files:
.idea/dataSources.ids
.idea/dataSources.xml
.idea/sqlDataSources.xml
.idea/dynamic.xml
.idea/uiDesigner.xml

# Gradle:
.idea/gradle.xml
.idea/libraries

# Mongo Explorer plugin:
.idea/mongoSettings.xml

## File-based project format:
*.ipr
*.iws

## Plugin-specific files:

# IntelliJ
out/*

# mpeltonen/sbt-idea plugin
.idea_modules/

# JIRA plugin
atlassian-ide-plugin.xml

# Crashlytics plugin (for Android Studio and IntelliJ)
com_crashlytics_export_strings.xml
crashlytics.properties
crashlytics-build.properties
fabric.properties
</file>

<file path="Aproximaciones/Aproximaciones.iml">
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/lib" type="java-resource" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="library" name="jmathplot" level="project" />
    <orderEntry type="library" name="jfreechart-1.0.19" level="project" />
    <orderEntry type="library" name="jcommon-1.0.23" level="project" />
    <orderEntry type="library" name="jmathio" level="project" />
    <orderEntry type="library" name="commons-math3-3.5" level="project" />
    <orderEntry type="library" name="src" level="project" />
    <orderEntry type="library" name="commons-lang3-3.4" level="project" />
    <orderEntry type="library" exported="" name="flanagan" level="project" />
    <orderEntry type="module-library">
      <library>
        <CLASSES>
          <root url="jar://C:/Program Files/Java/jdk1.8.0_60/jre/lib/ext/flanagan.jar!/" />
        </CLASSES>
        <JAVADOC />
        <SOURCES />
      </library>
    </orderEntry>
    <orderEntry type="library" name="ellipticFunctions" level="project" />
    <orderEntry type="library" name="mfc" level="project" />
    <orderEntry type="library" name="ellipticFunctions" level="project" />
    <orderEntry type="library" name="mfc" level="project" />
  </component>
</module>
</file>

<file path="mv.exe.stackdump">
MSYS-1.0.12 Build:2012-07-05 14:56
Exception: STATUS_ACCESS_VIOLATION at eip=00428DAA
eax=680A38E4 ebx=685704EC ecx=00552D8E edx=00000140 esi=00000000 edi=685700D4
ebp=0029FE90 esp=0029FE6C program=C:\Program Files (x86)\Git\bin\mv.exe
cs=0023 ds=002B es=002B fs=0053 gs=002B ss=002B
Stack trace:
Frame     Function  Args
0029FE90  00428DAA  (685700D4, 00000140, 00000003, 004244EA)
0029FEE0  0042466B  (00000000, DB17C100, 0029FF20, 00413C70)
0029FF00  00424C5F  (00401E50, 00401000, 00000000, 00000000)
0029FF20  00424C98  (00000000, 00000000, 00000000, 00000000)
0029FF50  00413B80  (00401E50, 00000000, 00000000, 00000000)
0029FF80  0040103D  (7FFDE000, 772D3720, 63BF0EC0, 0029FFDC)
0029FF94  772D3744  (7FFDE000, C9EFC203, 00000000, 00000000)
0029FFDC  776DA064  (FFFFFFFF, 776FD7C0, 00000000, 00000000)
0029FFEC  776DA02F  (00401000, 7FFDE000, 00000000, 78746341)
End of stack trace
</file>

<file path="README.md">
# TP_MATLAB
Diseño de filtros analógicos por aproximaciones GUI
</file>

<file path="wc.exe.stackdump">
MSYS-1.0.12 Build:2012-07-05 14:56
Exception: STATUS_ACCESS_VIOLATION at eip=00418DAA
eax=680A220C ebx=68570B14 ecx=005B2C16 edx=0000012C esi=00000000 edi=685700D4
ebp=0029FE90 esp=0029FE6C program=C:\Program Files (x86)\Git\bin\wc.exe
cs=0023 ds=002B es=002B fs=0053 gs=002B ss=002B
Stack trace:
Frame     Function  Args
0029FE90  00418DAA  (685700D4, 0000012C, 00000003, 004144EA)
0029FEE0  0041466B  (00000000, 5B086717, 0029FF20, 00407E8C)
0029FF00  00414C5F  (00401CFC, 00401000, 00000000, 00000000)
0029FF20  00414C98  (00000000, 00000000, 00000000, 00000000)
0029FF50  00407D9C  (00401CFC, 00000000, 00000000, 00000000)
0029FF80  0040103D  (7FFDE000, 772D3720, 59848978, 0029FFDC)
0029FF94  772D3744  (7FFDE000, 37A939D6, 00000000, 00000000)
0029FFDC  776DA064  (FFFFFFFF, 776FD7B0, 00000000, 00000000)
0029FFEC  776DA02F  (00401000, 7FFDE000, 00000000, 78746341)
End of stack trace
</file>

</files>
