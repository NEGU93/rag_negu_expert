This file is a merged representation of the entire codebase, combined into a single document by Repomix.
The content has been processed where security check has been disabled.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Security check has been disabled - content may contain sensitive information
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
cmake/
  FindAllegro5.cmake
include/
  allegro.hpp
  ArcheologistButton.hpp
  ArcheologistCharacter.hpp
  Button.hpp
  Character.hpp
  ChoosePlayer.hpp
  ClimberButton.hpp
  ClimberCharacter.hpp
  def.hpp
  ExplorerButton.hpp
  ExplorerCharacter.hpp
  fsmInit.h
  Game.hpp
  MeteorologistButton.hpp
  MeteorologistCharacter.hpp
  MultiPlayerGame.hpp
  NavigatorButton.hpp
  NavigatorCharacter.hpp
  Network.hpp
  Packages.hpp
  Part.hpp
  polo.h
  polonet.h
  SinglePlayerGame.hpp
  StartMenu.hpp
  StormCard.hpp
  Tile.hpp
  WaterCarrierButton.hpp
  WaterCarrierCharacter.hpp
src/
  allegro.cpp
  ArcheologistButton.cpp
  ArcheologistCharacter.cpp
  Button.cpp
  Character.cpp
  ChoosePlayer.cpp
  ClimberButton.cpp
  ClimberCharacter.cpp
  ExplorerButton.cpp
  ExplorerCharacter.cpp
  fsmInit.cpp
  Game.cpp
  main.cpp
  MeteorologistButton.cpp
  MultiPlayerGame.cpp
  NavigatorButton.cpp
  NavigatorCharacter.cpp
  Network.cpp
  Packages.cpp
  Part.cpp
  polo.c
  polonet.c
  SinglePlayerGame.cpp
  StartMenu.cpp
  StormCard.cpp
  Tile.cpp
  WaitForEvent.cpp
  WaterCarrierButton.cpp
  WaterCarrierCharacter.cpp
testingAllegro/
  hello.c
.gitignore
allegro.log.txt
CMakeLists.txt
README.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="cmake/FindAllegro5.cmake">
# - Find allegro 5
# Find the native ALLEGRO 5 includes and library
#
#  ALLEGRO_INCLUDE_DIR - where to find allegro.h, etc.
#  ALLEGRO_LIBRARIES   - List of libraries when using allegro.
#  ALLEGRO_FOUND       - True if allegro found.


find_package(PkgConfig)

# Find main allegro and assume the rest is there too
pkg_check_modules(Allegro5_PKGCONF allegro-5)

# Perhaps use this later?
# pkg_search_module(ALLEGRO5 REQUIRED allegro-5 allegro-5.0)

# MESSAGE("lib: ${Allegro5_PKGCONF_LIBRARY_DIRS}")
# MESSAGE("include: ${Allegro5_PKGCONF_INCLUDE_DIRS}")

# Include dir
find_path(Allegro5_INCLUDE_DIR
        NAMES allegro5/allegro5.h
        PATHS ${Allegro5_PKGCONF_INCLUDE_DIRS}
        )

# message("include dir: ${Allegro5_INCLUDE_DIR}")

# Names of all libraries in Allegro, without versions
set(ALLEGRO5_ALL_LIBRARIES
        allegro allegro_image allegro_font
        allegro_primitives allegro_ttf allegro_audio
        allegro_dialog allegro_memfile allegro_acodec
        allegro_color allegro_main allegro_physfs
        )

# set(ALLEGRO5_LIBRARIES "")

# Find all libraries to link
foreach(ALLEGRO5_ONE_LIBRARY ${ALLEGRO5_ALL_LIBRARIES})
    # message("${ALLEGRO5_ONE_LIBRARY}")
    find_library("${ALLEGRO5_ONE_LIBRARY}_AID" "${ALLEGRO5_ONE_LIBRARY}"
            ${Allegro5_PKGCONF_LIBRARY_DIRS}
            )
    set(Allegro5_LIBRARIES
            "${Allegro5_LIBRARIES}" "${${ALLEGRO5_ONE_LIBRARY}_AID}")
    # MESSAGE("${Allegro5_LIBRARIES}")
endforeach(ALLEGRO5_ONE_LIBRARY)
# Remove first empty erroneous "library"
list(REMOVE_AT Allegro5_LIBRARIES 0)
# MESSAGE("${Allegro5_LIBRARIES}")
# message("${ALLEGRO5_LIBRARIES}")
# allegro_image allegro_font allegro_primitives
#   allegro_ttf allegro_audio allegro_dialog allegro_acodec
#   allegro_color allegro_main allegro_physfs



# Set the include dir variables and the libraries and let libfind_process do the rest.
set(ALLEGRO_INCLUDE_DIR "${Allegro5_INCLUDE_DIR}")
set(ALLEGRO_LIBRARIES "${Allegro5_LIBRARIES}")
# libfind_process(Allegro5)

# MESSAGE("all libs: ${ALLEGRO_LIBRARIES}")
# MESSAGE("all include: ${ALLEGRO_INCLUDE_DIR}")

FIND_PACKAGE_HANDLE_STANDARD_ARGS(Allegro5 DEFAULT_MSG ALLEGRO_LIBRARIES ALLEGRO_INCLUDE_DIR)

MARK_AS_ADVANCED(ALLEGRO_INCLUDE_DIR ALLEGRO_LIBRARIES)
</file>

<file path="include/allegro.hpp">
#ifndef ALLEGRO_H_INCLUDED
#define ALLEGRO_H_INCLUDED

#define ALLEGRO_STATICLINK 
#include <allegro5/allegro5.h>
#include <allegro5/allegro_primitives.h>
#include <allegro5/allegro_font.h>
#include <allegro5/allegro_ttf.h>
#include <allegro5/allegro_image.h>
#include <allegro5/allegro_audio.h>
#include <allegro5/allegro_acodec.h>

#include <cmath>

#define SCREEN_X 1600
#define SCREEN_Y 900

#define MAXRESOLUTION_X 1920
#define MAXRESOLUTION_Y 1080

#define WINDOWED

typedef struct {
	int screenWidth;
	int screenHeight;
	double volume;
	//DISPLAYS
	ALLEGRO_DISPLAY *display;
	ALLEGRO_DISPLAY *startMenuDisplay;
	//EVENT QUEUE
	ALLEGRO_EVENT_QUEUE *events_queue;
	//TIMERS
	ALLEGRO_TIMER * timer;
	ALLEGRO_TIMER *timeout;
	//Samples (TODO: posria ponerse en una segunda esctructura)
	ALLEGRO_SAMPLE *backgroundMusic;
	ALLEGRO_SAMPLE *clickOnButtonSound;
	ALLEGRO_SAMPLE *sunBeatsDownSound;
	ALLEGRO_SAMPLE *waterSound;
	ALLEGRO_SAMPLE *stormSound;
	ALLEGRO_SAMPLE *excavateSound;
	ALLEGRO_SAMPLE* curiositySound;
	ALLEGRO_SAMPLE* teleportSound;
	ALLEGRO_SAMPLE* startMusic;
	ALLEGRO_SAMPLE* rejectWaterGirlSound;
	ALLEGRO_SAMPLE* rejectEquipmentGirlSound;
	ALLEGRO_SAMPLE* rejectWaterBoySound;
	ALLEGRO_SAMPLE* rejectEquipmentBoySound;
	ALLEGRO_SAMPLE_ID backgroundMusicID;
	//FONTS
	ALLEGRO_FONT *font;
	ALLEGRO_FONT *gameFont;
	ALLEGRO_FONT *statusFont;
	//BITMAPS
	ALLEGRO_BITMAP* fondo;
	ALLEGRO_BITMAP* mouse;
	ALLEGRO_BITMAP* menuBackgroundImage;
	ALLEGRO_BITMAP* backgroundStartMenuImage;
	ALLEGRO_BITMAP* stormMeter[15];
	ALLEGRO_BITMAP* haveEquipments[6];
	ALLEGRO_BITMAP* noEquipments[6];
	ALLEGRO_BITMAP* equipmentCards[6];
	ALLEGRO_BITMAP* partsImages[8];
	ALLEGRO_BITMAP* rectangleImage[6];
	//CURSOR
	ALLEGRO_MOUSE_CURSOR* cursor;
	
} ALL;

bool init_allegro(ALL *allegro);
void destroyAll(ALL *allegro);
char *getcharAllegro(ALL *allegro, int x, int y);
void printAllegro(ALL* allegro, char *msg);
void drawStartMenu(ALL *allegro);
void drawChooseModeStartMenu(ALL *allegro);
ALLEGRO_BITMAP *al_load_bitmap_resized(const char *filename, ALL* allegro); //TODO: que pase solo los ints que necesito y no toda la struct

#endif
</file>

<file path="include/ArcheologistButton.hpp">
#ifndef ARCHEOLOGISTBUTTON_H_INCLUDED
#define ARCHEOLOGISTBUTTON_H_INCLUDED

#include "Button.hpp"

class ArcheologistButton : public Button {
public:
	ArcheologistButton();
	ArcheologistButton(int x0, int y0, const char *imageName, const char * nonSelectedImageName, ALL* allegro);
	bool buttonAction(int x, int y);
};

#endif
</file>

<file path="include/ArcheologistCharacter.hpp">
#ifndef ARCHEOLOGISTCHARACTER_H_
#define ARCHEOLOGISTCHARACTER_H_

#include "Character.hpp"

class ArcheologistCharacter : public Character{
public:
	ArcheologistCharacter(int rowSet, int columnSet, Container inf, ALL *allegro);
    ~ArcheologistCharacter();

private:
	ALLEGRO_BITMAP* watersImage[MAXOFWATERS];
	ALLEGRO_BITMAP* archeologistImage;
};

#endif
</file>

<file path="include/Button.hpp">
#ifndef BUTTON_H_INCLUDED
#define BUTTON_H_INCLUDED	//Se incluyen definiciones y estructuras que usan todos los .cpp

#include "def.hpp"
#include "allegro.hpp"

enum buttonEnum{REMOVEBUTTON, EXCAVATEBUTTON, PICKUPBUTTON, OFFERWBUTTON, OFFEREBUTTON, REQUESTWBUTTON,REQUESTEBUTTON};

typedef struct {
	pos initialPos;
	pos endPos;
} ButtonPos;

class Button {
public:
	Button();
	Button(int x0, int y0, const char *imageName, const char * selectedImageName, ALL* allegro);	//Receives the initial position of the button
	~Button();
	bool checkMouse(int x, int y, double volume);									//See if the mouse is over the button
	void testButtonAction(int x, int y);
	void updateButton(ALL *allegro);
	int getMiddleOfX();
	int getMiddleOfY();
	pos getInitialPos();
	void changeCoords(int x, int y);

protected:
	bool mouseOverButton;
	ButtonPos buttonPos;
	ALLEGRO_BITMAP *buttonImage;
	ALLEGRO_BITMAP *nonSelectedImage;
	ALLEGRO_SAMPLE *selectCharSample;
private:
	ALLEGRO_SAMPLE *mouseOverButtonSample;
};

#endif
</file>

<file path="include/Character.hpp">
#ifndef CHARACTER_H_INCLUDED
#define CHARACTER_H_INCLUDED

#include "def.hpp"
#include "Packages.hpp"
#include "allegro.hpp"

#define MAXOFWATERS 7 //for the array of watersImage for each character

class Character {
public:
	Character();
	Character(int rowSet, int columnSet, Container info, ALL* allegro);
	~Character();
	//Update Allegro
	void updateChar(ALL* allegro, int numofplayer);		//TODO: necesito que la clase sea virtual para el dynamimc_cast :S
	void updateChar(ALL *allegro, int numofplayer, int x, int y);
	void updateEquipments(ALL* allegro);
	bool checkButton(EquipmentsEnum equipEnum, int mousex, int mousey, double volume);
	//Actions
	bool removeSand();
	bool dig();
	bool pickUpPart();
	//Waters
	void drinkWater();
	virtual void addWater();
	bool haveWater();
	int getWaters() { return waters; }
	//Equipments
	bool shield;		//TODO: no me gusta :P
	bool haveSolarShield();
	void increaseSolarShield() { solarShield++; }
	void decreaseSolarShield() { solarShield--; }
	bool haveDuneBlaster();
	void increaseDuneBlaster() { duneBlaster++; }
	void decreaseDuneBlaster() { duneBlaster--; }
	bool haveJetPack();
	void increaseJetPack() { jetPack++; }
	void decreaseJetPack() { jetPack--; }
	bool haveWaterReserve();
	void increaseWaterReserve() { secretWaterReserve++; }
	void decreaseWaterReserve() { secretWaterReserve--; }
	bool haveTerrascope();
	void increaseTerrascope() { terrascope++; }
	void decreaseTerrascope() { terrascope--; }
	bool haveTimeThrottle();
	void increaseTimeThrottle() { timeThrottle++; }
	void decreaseTimeThrottle() { timeThrottle--; }
	//Setter
	bool setPos(int row, int column);
	void setName(char* name);
	//Getters
	uint getCardIndex();
	int getNumberOfMoves() { return numberOfMoves; }
	int getRow() { return row; }
	int getColumn() { return column; }
	int getDuneBlast() { return duneBlaster; }
	int getJetPack() { return jetPack; }
	int getSolarShield() { return solarShield; }
	int getTerrascope() { return terrascope; }
	int getSecretWaterReserve() { return secretWaterReserve; }
	int getTimeThrottle() { return timeThrottle; }
	//Moves Left
	void resetNumberOfMoves();
	void increaseMoves(){ numberOfMoves++; }
	//Movements
	bool moveUp();
	bool moveDown();
	bool moveLeft();
	bool moveRight();
	//Sounds
	void playGettingCloseSound();
protected:
	//methods
	bool decreseMoves();
	//variables
	char name[SIZEOFNAME];
	pos updateCoords(ALL *allegro);
	int numberOfMoves;	//Number of moves left before end of turn
	int row;			//Location of the player
	int column;
	int waters;
	//Images
	ALLEGRO_BITMAP *image;
	ALLEGRO_BITMAP* watersImages[MAXOFWATERS];
	ALLEGRO_BITMAP* adventurerImage;
	//Equipments
	int solarShield;
	int duneBlaster;
	int jetPack;
	int secretWaterReserve;
	int terrascope;
	int timeThrottle;
	//Buttons (Equipments)
	Button *duneBlasterButton; 
	Button *solarShieldButton;
	Button *jetPackButton;
	Button *secretWaterReserveButton;
	Button *terrascopeButton;
	Button *timeThrottleButton;
	//Sounds
	bool getClose;
	ALLEGRO_SAMPLE *gettingCloseSound;
};

#endif
</file>

<file path="include/ChoosePlayer.hpp">
#ifndef CHOOSEPLAYER_H_INCLUDED
#define CHOOSEPLAYER_H_INCLUDED	//Se incluyen definiciones y estructuras que usan todos los .cpp

#include "def.hpp"
#include "allegro.hpp"
#include "Packages.hpp"
#include "ArcheologistButton.hpp"
#include "ExplorerButton.hpp"
#include "NavigatorButton.hpp"
#include "WaterCarrierButton.hpp"
#include "MeteorologistButton.hpp"
#include "ClimberButton.hpp"

//enum roles {ARCHEOLOGIST=0x30, CLIMBER, EXPLORER, METEOROLOGIST, NAVIGATOR, WATER_CARRIER};
// TODO: have to basically repeat the enum here.
enum Role {ARCHEOLOGIST_ROLE=0x30, CLIMBER_ROLE, EXPLORER_ROLE, METEOROLOGIST_ROLE, NAVIGATOR_ROLE, WATER_CARRIER_ROLE};

//I made this class static because I'll only have one game
/*static*/ class ChoosePlayer {
public:
	ChoosePlayer(ALL *allegro);
	~ChoosePlayer();
	bool eventHandler(ALL *allegro);
	bool initializeAllegro(ALL* allegro);

	Role get_p1_role() { return rol1; }
	Role get_p2_role() { return rol2; }
private:
	//Buffer
	int player;
	Role rol1;
	Role rol2;

	//Methods
	void updateScreen(ALL *allegro);
	//Variables
	pos mouse;
	bool redraw;
	ArcheologistButton *archeologistButton;
	ExplorerButton *explorerButton;
	NavigatorButton *navigatorButton;
	WaterCarrierButton *waterCarrierButton;
	MeteorologistButton *meteorologistButton;
	ClimberButton *climberButton;
};

#endif
</file>

<file path="include/ClimberButton.hpp">
#ifndef CLIMBERBUTTON_H_INCLUDED
#define CLIMBERBUTTON_H_INCLUDED

#include "Button.hpp"

class ClimberButton : public Button {
public:
	ClimberButton();
	ClimberButton(int x0, int y0, const char *imageName, const char * nonSelectedImageName, ALL* allegro);
	bool buttonAction(int x, int y);
};

#endif
</file>

<file path="include/ClimberCharacter.hpp">
#ifndef CLIMBERCHARACTER_H_
#define CLIMBERCHARACTER_H_

#include "Character.hpp"
#include "Button.hpp"

class ClimberCharacter : public Character {
public:
	ClimberCharacter(int rowSet, int columnSet, Container info, ALL* allegro);
	~ClimberCharacter();
	void updateClimber(ALL* allegro);
	void clickOnButton(int x, int y, double volume);
	void checkMouseOverButton(int x, int y, double volume) { takeWithMeButton->checkMouse(x, y, volume); }
	//Getter
	bool getTakeWithMe() { return takeWithMe; }
private:
	void toogleTakeWithMe() { takeWithMe = !takeWithMe; }
	ALLEGRO_BITMAP* watersImage[MAXOFWATERS];
	ALLEGRO_BITMAP* climberImage;
	Button *takeWithMeButton;
	ALLEGRO_BITMAP* selectedImage;
	ALLEGRO_BITMAP* unableToTakeCharacterWithMe;	//TODO: Esto aun no funciona... habrï¿½a que hacer un updateChar que le pase una variable extra y le diga si puede o no (game sabe si hay dos pjs en el mismo lugar)
	bool takeWithMe;
};

#endif
</file>

<file path="include/def.hpp">
#ifndef DEF_H_INCLUDED
#define DEF_H_INCLUDED	//Se incluyen definiciones y estructuras que usan todos los .cpp

#include <iostream>
#ifdef __cplusplus__
#include <cstdlib>
#else
#include <stdlib.h>
#endif

#define HEIGHT 900
#define WIDTH 602
#define WHITE 255,255,255
#define BLACK 0,0,0
#define SIZEOFNAME 10
#define SECONDARY_BUTTON 2

typedef struct {
	int x;
	int y;
} pos;

using namespace std;

typedef unsigned char uchar;
//typedef unsigned long int uint;		// already on /usr/include/x86_64-linux-gnu/sys/types.h

#endif
</file>

<file path="include/ExplorerButton.hpp">
#ifndef EXPLORERBUTTON_H_INCLUDED
#define EXPLORERBUTTON_H_INCLUDED

#include "Button.hpp"

class ExplorerButton : public Button {
public:
	ExplorerButton();
	ExplorerButton(int x0, int y0, const char *imageName, const char * nonSelectedImageName, ALL* allegro);
	bool buttonAction(int x, int y);
};

#endif
</file>

<file path="include/ExplorerCharacter.hpp">
#ifndef EXPLORERCHARACTER_H_
#define EXPLORERCHARACTER_H_

#include "Character.hpp"

class ExplorerCharacter : public Character{
public:
	ExplorerCharacter(int rowSet, int columnSet, Container info, ALL* allegro);
	~ExplorerCharacter();
	//Special movements.
	void moveUpRightDiagonally();
	void moveUpLeftDiagonally();
	void moveDownRightDiagonally();
	void moveDownLeftDiagonally();
	void useDuneBlasterDiagonally();

private:
	ALLEGRO_BITMAP* watersImage[MAXOFWATERS];
	ALLEGRO_BITMAP* explorerImage;
};

#endif
</file>

<file path="include/fsmInit.h">
#ifndef FSMINIT
#define FSMINIT

#include <iostream>
using namespace std;
#include "allegro.hpp"
#include "Packages.hpp"
#include "Network.hpp"

#include "def.hpp"

typedef enum {TURN,ASK4NAME, IDLE,W4NAME,READINGNAME,W4STRING,SENDNAME,W4ACK,STARTINFO,W4STARTINFO,W4ACK2,SENDACK,W4TURN,W4ACK3,END} eventtype;

class FSMI
{
public:
	FSMI();
	void start(ALL *allegro);
	void restart(ALL *allegro);
	void checkdata();
	Container getInfo();
	void print(Container ex);
	initNetwork net;
protected:
	Container data;			//Se usa de buffer para mandar y recibir informacion, por medio de los slots
	Container Informacion;	// Container para tener los datos guardados del usuario, solo se usan name, tiles, roles y turno. No slots.
	Pack pck;	//Paquete de datos
	bool nameready;
	char state;
	char prevstate;
	bool exit;	//Para controlar el flujo de la fsm (1 o 0)
	char turn;
	void changestate(char newstate);	//Variable para la maquina de estados inicial
	void turnsort();	// Funcion para determinar el turno inicial, aleatorio
};

#endif
</file>

<file path="include/Game.hpp">
#ifndef GAME_H_INCLUDED
#define GAME_H_INCLUDED

#include "def.hpp"
#include "allegro.hpp"
#include "Button.hpp"
#include "Tile.hpp"
#include "Character.hpp"
/* ESTO NO ME GUSTA */
#include "MeteorologistCharacter.hpp"
#include "ClimberCharacter.hpp"
#include "ArcheologistCharacter.hpp"
#include "ExplorerCharacter.hpp"
#include "WaterCarrierCharacter.hpp"
#include "NavigatorCharacter.hpp"

#include "StartMenu.hpp"
#include "fsmInit.h"
#include "Part.hpp"
#include "StormCard.hpp"
#include <algorithm>		//Used to shuffle the array of tiles
#include <array>

//#define DEBUG_GAME
//#define DEBUG_INIT
//#define DEBUG_UPDATE_SCREEN

#define MODEBUTTONSNUMBER 7
#define TILEDECKNUMBER 25
#define MAXWATERS 5

enum ModeEnum { NORMAL, REMOVESAND, //Normal Use
	PEEPMODE, MOVEOTHER,			//Characters special
	DUNEBLASTERMODE, JETPACKMODE, TERRASCOPEMODE,	//Equipments
	OFFEREQUIPMENTMODE, REQUESTEQUIPMENTMODE, OFFERWATERMODE, REQUESTWATERMODE };

class Game {
public:
    //! Methods
	Game() = default;
	~Game();
	virtual bool eventHandler(ALL *allegro) = 0;
	bool getPlayAgain() { return playAgain; }
	bool getGameOver() { return gameOver; }

	//! Variables
    Container info;
    pos mouse{};
    bool redraw{};

    ModeEnum modeEnum;				//ModeEnum is used to know in wich mode I am... say.. have to move or remove sand
    int SandMarkersLeft{};
    int sandStormLevel{};
    //double volume;
    //Decks
    std::array< StormCard *, CANTOFSTORM> stormCardsDeck{};
    std::array<Tile *, TILEDECKNUMBER> tilesDeck{};		//Important! its a deck of cards seen as an array, we will use algorithm library to make it work.
    //int stormCardIndex;			//Indexes for the decks
    int equipIndex{};
    int peepOffset{};
    EquipmentsEnum equipOffset;
    int firstTimeUpdateScreenChooseEquipment{};		//ChooseEquipment Counter
    int firstTimeUpdateScreenPeep{};				//Peep Counter
    // Character Variables
    bool playAgain{};
    bool gameOver{};
    Character *character{};
    Character *character2{};
    //Parts
    Part *engine{};
    Part *solarCrystal{};
    Part *propeller{};
    Part *navigationDeck{};
    //BUTTONS
    Button *endTurnButton{};
    Button *modesButtons[MODEBUTTONSNUMBER]{};
    Button *watersButton[MAXWATERS]{};
    //Peep Buttons
    Button *nextButton{};
    Button *previousButton{};
    Button *selectPeepCard{};
    Button *selectEquipmentCard{};
    //VolumeButtons
    Button *muteButton{};
    Button *noMuteButton{};

	//Methods
	pos getSpot(int row, int column, ALL* allegro, ALLEGRO_BITMAP* image);		//Gets the pos of the image you must put giving the row and column where the item is.
    virtual void updateScreen(ALL* allegro) = 0;
    virtual void updateTilesButton(ALL* allegro) = 0;
	virtual void pickUpAction() = 0;
	//End Of Game
	virtual bool win(ALL *allegro) = 0;
	virtual bool lose(ALL *allegro) = 0;
	virtual void wannaPlay(ALL *allegro, char ID) = 0;
	//Mouse Methods
	virtual void click(ALL* allegro) = 0;
    virtual void clickOnPeepMode(ALL* allegro) = 0;
    virtual void clickOnJetPackMode(ALL* allegro) = 0;
    virtual void clickOnTerrascopeMode(ALL* allegro) = 0;
    virtual void clickOnRequestWaterMode(ALL*  allegro) = 0;
    virtual void clickOnOfferEquipmentMode(ALL* allegro) = 0;
    virtual void clickOnRequestEquipmentMode(ALL* allegro) = 0;
    virtual void clickOnOfferWaterMode(ALL* allegro) = 0;
    virtual void clickOnDefaultMode(ALL* allegro) = 0;
	void checkMouse(ALL* allegro);
	virtual void checkTilesButtons(double volume) = 0;
    virtual void clickTilesButtons(ALL *allegro) = 0;
    virtual void clickModesButtons(ALL* allegro) = 0;
	void clickEquipmentButtons(ALL* allegro);
	//Perform Action
	void performTileAction(TilesEnum tileEnum, int index, ALL* allegro);
	virtual void performEquipmentsAction(EquipmentsEnum equipEnum, ALL *allegro) = 0;
	//Tile Deck methods
	void swapTiles(int i, int j);		//Lets use swap from STL (algorithm)
	void shuffleTiles();		//Lets use shuffle from STL
	//Equipments methods
	virtual void drawEquipment(EquipmentsEnum equipEnum) = 0;

	//StormCards methods
	void performStormCardAction(ALL *allegro, StormCardsEnum cardEnum);
	virtual void drawStormCards(ALL *allegro) = 0;
	void swapStormCards(int i, int j);
	//Initialize Methods
	bool initializeAllegro(ALL* allegro);
	void initializeBoard(ALL* allegro);
	void initializeStormCards(ALL* allegro);
	void initializeCharacters(Container info, ALL* allegro);
	void initializeButtons(ALL* allegro);
	void initializeWaterButtons(ALL* allegro);
	void initializePeepButtons(ALL* allegro);
	void initializeEquipmentCardButton(ALL* allegro);
	//Keys Pressed
	virtual void keyUp(ALL *allegro) = 0;
    virtual void keyDown(ALL *allegro) = 0;
    virtual void keyLeft(ALL *allegro) = 0;
    virtual void keyRight(ALL *allegro) = 0;
    virtual void keyE(ALL* allegro) = 0;
    virtual void keyP(ALL *allegro) = 0;
    virtual void keyR(ALL *allegro) = 0;
    void keyEscape();
	//Peep Methods
	void nextPeepStormCard();
	void previousPeepStormCard();
	void resetPeepOffset() { peepOffset = 0; }
	//Offer equipment Methods
	void nextEquipCard();
	void previousEquipCard();
};

#endif
</file>

<file path="include/MeteorologistButton.hpp">
#ifndef METEOROLOGISTBUTTON_H_INCLUDED
#define METEOROLOGISTBUTTON_H_INCLUDED

#include "Button.hpp"

class MeteorologistButton : public Button {
public:
	MeteorologistButton();
	MeteorologistButton(int x0, int y0, const char *imageName, const char * nonSelectedImageName, ALL* allegro);
	bool buttonAction(int x, int y);
};

#endif
</file>

<file path="include/MeteorologistCharacter.hpp">
#ifndef METEOROLOGIST_H_INCLUDED
#define METEOROLOGIST_H_INCLUDED

#include "Character.hpp"
#include "Button.hpp"

class MeteorologistCharacter : public Character {
public:
	MeteorologistCharacter(int rowSet, int columnSet, Container info, ALL* allegro);
	~MeteorologistCharacter();
	bool checkMouseOverButton(int x, int y, double volume) { return seeStormDeckButton->checkMouse(x, y, volume); }
	void updateMeteorologistButton(ALL* allegro) { seeStormDeckButton->updateButton(allegro); }
	bool peep();
private:
	ALLEGRO_BITMAP *watersImage[MAXOFWATERS];
	ALLEGRO_BITMAP *meteorologistImage;
	Button *seeStormDeckButton;
};

#endif
</file>

<file path="include/MultiPlayerGame.hpp">
//
// Created by barrachina on 12/21/18.
//

#ifndef FORBIDDENDESERT_MULTIPLAYERGAME_H
#define FORBIDDENDESERT_MULTIPLAYERGAME_H

#include "Game.hpp"

#define TIME_TERRASCOPE 3000

class MultiPlayerGame : public Game {
public:
    MultiPlayerGame(ALL *allegro, FSMI *gameNetwork);

    bool eventHandler(ALL *allegro) override;
    bool receiveHandler(ALL* allegro);
    void pickUpAction() override;

private:
    FSMI *gameNetwork;
    Pack gamePack;
    bool turn{};	// Used to know which turn is it... true = this computer turn. False = companion turn.

    //! Methods
    void chooseOption(ALL* allegro, Container temp);
    // Update Screen
    void updateScreen(ALL* allegro) override;
    void updateTilesButton(ALL* allegro) override;
    //End Of Game
    bool win(ALL *allegro) override;
    bool lose(ALL *allegro) override;
    void wannaPlay(ALL *allegro, char ID) override;
    //Keys Pressed
    void keyUp(ALL *allegro) override;
    void keyDown(ALL *allegro) override;
    void keyLeft(ALL *allegro) override;
    void keyRight(ALL *allegro) override;
    void keyE(ALL* allegro) override;
    void keyP(ALL *allegro) override;
    void keyR(ALL *allegro) override;
    //Mouse Methods
    void click(ALL* allegro);
    void clickOnPeepMode(ALL* allegro);
    void clickOnJetPackMode(ALL* allegro);
    void clickOnTerrascopeMode(ALL* allegro);
    void clickOnRequestWaterMode(ALL*  allegro);
    void clickOnOfferEquipmentMode(ALL* allegro);
    void clickOnRequestEquipmentMode(ALL* allegro);
    void clickOnOfferWaterMode(ALL* allegro);
    void clickOnDefaultMode(ALL* allegro);
    void clickTilesButtons(ALL *allegro);
    void clickModesButtons(ALL* allegro);
    void checkTilesButtons(double volume);

    //Equipments methods
    void drawEquipment(EquipmentsEnum equipEnum);
    void drawStormCards(ALL *allegro);

    void performEquipmentsAction(EquipmentsEnum equipEnum, ALL *allegro) override;

};


#endif //FORBIDDENDESERT_MULTIPLAYERGAME_H
</file>

<file path="include/NavigatorButton.hpp">
#ifndef NAVIGATORBUTTON_H_INCLUDED
#define NAVIGATORBUTTON_H_INCLUDED

#include "Button.hpp"

class NavigatorButton : public Button {
public:
	NavigatorButton();
	NavigatorButton(int x0, int y0, const char *imageName, const char * nonSelectedImageName, ALL* allegro);
	bool buttonAction(int x, int y);
};

#endif
</file>

<file path="include/NavigatorCharacter.hpp">
#ifndef NAVIGATORCHARACTER_H_
#define NAVIGATORCHARACTER_H_

#include "Character.hpp"

class NavigatorCharacter : public Character{
public:
	NavigatorCharacter(int rowSet, int columnSet, Container info, ALL *allegro);
	~NavigatorCharacter();

	bool checkMouseOverButton(int x, int y, bool moveState, double volume);
	void updateNavigator(ALL* allegro, bool moveState);

	bool havePartnersMovesLeft() { return (partnerMovesLeft > 0); }
	bool decresePartnerMoves();
	bool usedPartnerMoves();

	bool haveMoves() { return numberOfMoves > 0; }
	void decreseMoves() { numberOfMoves--; }

	void resetPartnerMoves();
private:
	ALLEGRO_BITMAP* watersImage[MAXOFWATERS];
	ALLEGRO_BITMAP* navigatorImage;
	Button *moveOtherPlayerButton;
	Button *doneButton;
	int partnerMovesLeft;
};

#endif
</file>

<file path="include/Network.hpp">
#ifndef NET
#define NET

#include <iostream>
#include "polonet.h"
#include "allegro.hpp"
#include "def.hpp"
#ifdef _WIN32
#include <Windows.h>
#endif
#include <ctime>

using namespace std;

#define PORT 15786
#define SIZEMAX	20
#define CLIENT 6
#define SERVER 7
#define TIME_OUT 10

class Network
{
public:
	//protected:
	PolonetConn connection;
	int port;
	char IP[SIZEMAX];
	char typeconn;
	bool abort;
};

class initNetwork : public Network
{
public:
	//initNetwork(){};
	initNetwork();
	~initNetwork();
	void initializeNet(ALL *allegro); //Initializes connection

protected:
	int randNum; // Random number generated by RandGenerator()
	bool endflag; //Flag that shows if user desired to finish connection
	void seedStart(); // Starts Seed - JV
	void randGenerator(); //Generates random number from 200 to 10k - JV
	void getIP(ALL* allegro); //Gets string of IP and saves it in IP -JV
};

#endif
</file>

<file path="include/Packages.hpp">
#ifndef PACKAGE_H_
#define PACKAGE_H_

#include <iostream>
#include "polonet.h"
//#include <windows.h>
#include <algorithm>
#include "Tile.hpp"
#include "StormCard.hpp"
#include "ChoosePlayer.hpp"
#include <map>

#define BUFFERSIZE 255
#define CANTOFTILES 25
#define CANTOFSTORM 31
#define CANTOFEQUIPMENT 12
#define NAME 0x10
#define NAME_IS 0x11
#define ACK 0x01
#define I_START 0x21
#define YOU_START 0x20
#define MOVE 0x31
#define REMOVE 0x32
#define OFFER_EQUIPMENT 0x35
#define OFFER_WATER 0x36
#define REQUEST_EQUIPMENT 0x37
#define REQUEST_WATER 0x38
#define REQUEST_MOVE 0x39
#define PLAY_EQUIPMENT 0x3D
#define PEEP 0x3C
#define EXCAVATE 0x33
#define PICKUP 0x34
#define TAKE_WATER 0x3A
#define DECREASE_WITHDRAWAL 0x3B
#define PASS 0x3E
#define AGREE 0x02
#define DISAGREE 0x03
#define ERROR_ 0xFF
#define PLAY_AGAIN 0x43
#define GAME_OVER 0x42
#define WE_WON 0x40
#define WE_LOST 0x41
#define QUIT 0xfe
#define DRAW_STORM_CARDS 0x3F
#define START_INFO 0x12
#define NOEVENT 0x00

#define TIMEOUT 5 //5 seconds for timeout.

enum roles {ARCHEOLOGIST=0x30, CLIMBER, EXPLORER, METEOROLOGIST, NAVIGATOR, WATER_CARRIER};
static map<roles, string> RolesNames = {
		{ARCHEOLOGIST, "Archeologist"},
		{CLIMBER, "Climber"},
		{EXPLORER, "Explorer"},
		{METEOROLOGIST, "Meteorologist"},
		{NAVIGATOR, "Navigator"},
		{WATER_CARRIER, "Watercarrier"}
};
enum EquipmentsEnum{DUNEBLAST=0x01, JETPACK, SOLARSHIELD, TERRASCOPE, SECRETWATERRESERVE,TIMETHROTTLE}; 

int myRand(int i);

class Container;
class Pack
{
public:

	void sendPack();//
	Container receivePack();
	Pack(PolonetConn connection=0);
	~Pack();
	void cleanBuffer();
	void waitForAck(ALL *allegro);
	//Genero todos los paquetes de datos
	void ack();//
	void agree();//
	void disagree();//
	void name();//
	void nameis(char* name);
	Container startinfo(ALL* allegro);
	void youstart();//
	void istart();//
	void move(char row, char column);//
	void remove(char row, char column);//
	void excavate();//
	void pickup();//
	void offerequipment(char equipment);//
	void offerwater(char water);//
	void requestequipment(char equipment);
	void requestwater(char water);
	void requestmove(char row, char column);//
	void takewater();
	void decreasewithdrawal();
	void peep(char index); 
	void playequipment(char equipment, char row, char col);
	void pass();
	void drawstrcard(char first, char second, char third=0, char forth=0, char fifth=0, char sixth=0); //
	void wewon();
	void welost();
	void gameover();
	void playagain();
	void quit();
	void error();
	PolonetConn connection;

protected:
	char* buffer;
	char recbuffer[BUFFERSIZE];
	char size;
	roles rolesort();	//Rol del usuario, tambien aleatorio

};


class Container
{
public:
	Container();
	//~Container();	No hay destructor
	
	void addName(char* name);
	void addFriendName(char* name);
	void addInfo(Container info);

	void startinfo(roles rol1, roles rol2);

	// Variables
	unsigned char ID;	//ID de cada uno
	char Slot1;
	char Slot2;
	char Slot3;
	char Slot4;
	char Slot5;
	char Slot6;
	char Slot7;
	char name[SIZEOFNAME];				//Nombre
	char friendName[SIZEOFNAME];
	TilesEnum tiles[CANTOFTILES];		//Arreglo de las cartas
	StormCardsEnum storm[CANTOFSTORM];
	EquipmentsEnum equipment[CANTOFEQUIPMENT];
//	EquipmentEnum equipment[6];
	roles myRol;
	roles friendRol;
	char myTurn;
};

#endif // PACKAGE_H_
</file>

<file path="include/Part.hpp">
#ifndef PART_H_INCLUDED
#define PART_H_INCLUDED

#include "def.hpp"
#include "allegro.hpp"

class Part {
public:
	Part();
	Part(const char *partImageName);
	~Part();
	void updatePart(ALL* allegro);
	//Find Item
	void findRow(int newRow, ALL* allegro);
	void findColum(int newColumn, ALL* allegro);
	void pickUpPart();
	//Getters
	bool getFoundState() { return found; }
	bool getPickedState() { return picked; }
	int getRow() { return row; }
	int getColumn() { return column; }
	uint getCardIndex() { return 5 * column + row; }
	//Setters
	void setCardIndex(int index, ALL* allegro);
private:
	pos updateCoords(ALL* allegro);
	pos partCoords;
	bool found;
	bool picked;
	int row;		//This will state the location of the part... if -1 means it has not been found yet.
	int column;
	ALLEGRO_BITMAP *partImage;
	ALLEGRO_SAMPLE *pickUpSound;
};

#endif
</file>

<file path="include/polo.h">
/**
 * libpolo
 * Lightweight graphics library for educational environments
 * (C) 2011 by the libpolo team.
 *     Marc S. Ressl (mressl@itba.edu.ar)
 *     Jorge Prendes (jprendes@itba.edu.ar)
 * Released under the GPL
 *
 * Requires the glut library.
 */

/*
 * Basics:
 * - Call initPolo() to initialize the graphics window.
 * - libpolo continuously calls a user function to redraw the screen. 
 *   You can define this function with setDrawCallback().
 * - Call runPolo() to run graphics and get your user function called.
 * - To close the graphics window, call exitPolo().
 *
 * Drawing:
 * - The coordinate origin (0, 0) is at the lower left.
 * - Color components (RGBA, HSVA) are in the range 0.0 to 1.0.
 * - Alpha is the level of opacity (0.0 is transparent, 1.0 is opaque).
 * - Drawing primitives are rendered using a border color (use setPenColor())
 *   and fill color (setFillColor() or setFillGradient()).
 *
 * Using images:
 * - Images must be in uncompressed BMP format, either 24-bit RGB or 32-bit RGBA.
 * - Make sure you called initPolo before loading images.
 * - Use loadImage() to load a BMP file from disk. You will get an Image reference.
 *   If the image could not be loaded you get the value 0.
 * - Use drawImage() to draw an image to screen.
 * - Use drawSetTint() to set the tint parameter. This lets you tint your image
     with a color and alpha. To just paint, use tint POLO_WHITE.
 * - Use freeImage() after you finished using your image.
 * - Call setTexture() to fill drawing primitives with a texture.
 *   Make sure the width and height of your image is a power of 2 when using
 *   textures.
 *
 * Keyboard and mouse:
 * - Use getKey(), getMouseX(), getMouseY() and getMouseButtonState()
 *   to query the keyboard and mouse. Use clearKey() to clear a read key.
 * - Keyboard codes are in UNICODE. Special keys are defined in PoloKeys.
 *
 * Time:
 * - Use getTime() to get the number of seconds since the program started.
 *   This value is accurate up to several milliseconds.
 *
 */

#ifndef _LIBPOLO_H
#define _LIBPOLO_H

/* #define USE_FREEGLUT */

#ifdef __APPLE__
#include <OpenGL/OpenGL.h>
#include <GLUT/glut.h>
#ifdef USE_FREEGLUT
#include <GLUT/freeglut.h>
#endif
#else
#include <GL/glut.h>
#ifdef USE_FREEGLUT 
#include <GL/freeglut.h>
#endif
#endif

#ifdef __cplusplus
extern "C" {
#endif

// Definitions
#define Color unsigned int
#define Image unsigned int

enum PoloColors
{
	POLO_TRANSPARENT    = 0x00000000,
	POLO_WHITE          = 0xffffffff,
	POLO_BLACK          = 0x000000ff,
	
	POLO_CANTALOUPE     = 0xffcc66ff,
	POLO_HONEYDEW       = 0xccff66ff,
	POLO_SPINDRIFT      = 0x66ffccff,
	POLO_SKY            = 0x66ccffff,
	POLO_LAVENDER       = 0xcc66ffff,
	POLO_CARNATION      = 0xff6fcfff,
	POLO_LICORICE       = 0x000000ff,
	POLO_SNOW           = 0xffffffff,
	POLO_SALMON         = 0xff6666ff,
	POLO_BANANA         = 0xffff66ff,
	POLO_FLORA          = 0x66ff66ff,
	POLO_ICE            = 0x66ffffff,
	POLO_ORCHID         = 0x6666ffff,
	POLO_BUBBLEGUM      = 0xff66ffff,
	POLO_LEAD           = 0x191919ff,
	POLO_MERCURY        = 0xe6e6e6ff,
	POLO_TANGERINE      = 0xff8000ff,
	POLO_LIME           = 0x80ff00ff,
	POLO_SEAFOAM        = 0x00ff80ff,
	POLO_AQUA           = 0x0080ffff,
	POLO_GRAPE          = 0x8000ffff,
	POLO_STRAWBERRY     = 0xff0080ff,
	POLO_TUNGSTEN       = 0x333333ff,
	POLO_SILVER         = 0xccccccff,
	POLO_MARASCHINO     = 0xff0000ff,
	POLO_LEMON          = 0xffff00ff,
	POLO_SPRING         = 0x00ff00ff,
	POLO_TURQUOISE      = 0x00ffffff,
	POLO_BLUEBERRY      = 0x0000ffff,
	POLO_MAGENTA        = 0xff00ffff,
	POLO_IRON           = 0x424242ff,
	POLO_MAGNESIUM      = 0xb3b3b3ff,
	POLO_MOCHA          = 0x804000ff,
	POLO_FERN           = 0x408000ff,
	POLO_MOSS           = 0x008040ff,
	POLO_OCEAN          = 0x004080ff,
	POLO_EGGPLANT       = 0x400080ff,
	POLO_MAROON         = 0x800040ff,
	POLO_STEEL          = 0x666666ff,
	POLO_ALUMINUM       = 0x999999ff,
	POLO_CAYENNE        = 0x800000ff,
	POLO_ASPARAGUS      = 0x808000ff,
	POLO_CLOVER         = 0x008000ff,
	POLO_TEAL           = 0x008080ff,
	POLO_MIDNIGHT       = 0x000080ff,
	POLO_PLUM           = 0x800080ff,
	POLO_TIN            = 0x7f7f7fff,
	POLO_NICKEL         = 0x808080ff,
};

enum PoloKey
{
	POLO_BACKSPACE = 0x08,
	POLO_TAB = 0x09,
	POLO_ENTER = 0x0d,
	POLO_ESC = 0x1b,
	POLO_F1 = 0xe000,
	POLO_F2,
	POLO_F3,
	POLO_F4,
	POLO_F5,
	POLO_F6,
	POLO_F7,
	POLO_F8,
	POLO_F9,
	POLO_F10,
	POLO_F11,
	POLO_F12,
	POLO_UP,
	POLO_DOWN,
	POLO_LEFT,
	POLO_RIGHT,
	POLO_PAGEUP,
	POLO_PAGEDOWN,
	POLO_HOME,
	POLO_END,
};

enum PoloFont
{
	POLO_COURIER_13,
	POLO_COURIER_15,
	POLO_TIMES_10,
	POLO_TIMES_24,
	POLO_HELVETICA_10,
	POLO_HELVETICA_12,
	POLO_HELVETICA_18,
};

// Initialization & exit
void setPoloUserData(void *userData);
void initPolo(int width, int height, int fullscreen, const char *windowTitle);
void runPolo();
void exitPolo();

// Drawing
void setDrawCallback(void (*drawCallback)(void *userData));

Color getColorFromRGBA(float red, float green, float blue, float alpha);
Color getColorFromRGB(float red, float green, float blue);
Color getColorFromHSVA(float hue, float saturation, float value, float alpha);
Color getColorFromHSV(float hue, float saturation, float value);

void setPenColor(Color color);
void setFillColor(Color color);
void setFillGradient(Color color1, Color color2);

void drawPoint(float x, float y);
void drawLine(float x1, float y1, float x2, float y2);
void drawRect(float x, float y, float width, float height);
void drawRoundedRect(float x, float y, float width, float height, float edgeRadius);
void drawTriangle(float x1, float y1, float x2, float y2, float x3, float y3);
void drawQuad(float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4);
void drawCircle(float x, float y, float radius);

void clearScreen();
void updateScreen();
float getScreenWidth();
float getScreenHeight();

void setTextFont(enum PoloFont font);
float getTextDrawWidth(const char *str);
float getTextDrawHeight(const char *str);
void drawText(float x, float y, const char *str);

Image loadImage(const char *path);
float getImageWidth(Image image);
float getImageHeight(Image image);
void drawImage(float x, float y, Image image);
void setDrawTint(Color tint);
void setDrawScale(float scale);
void setTexture(Image image);
void freeImage(Image image);

// Keyboard
void setKeyboardCallback(void (*keyboardCallback)(void *userData, int key));
int getKey();
void clearKey();

// Mouse
void setMouseMotionCallback(void (*mouseMotionCallback)(void *userData, int x, int y));
void setMouseButtonCallback(void (*mouseButtonCallback)(void *userData, int button, int pressed));
float getMouseX();
float getMouseY();
int isMouseButtonPressed(int buttonIndex);
void showMousePointer();
void hideMousePointer();

// Time
void setTimerCallback(void (*timerCallback)(void *userData, int id));
void runTimer(int id, int milliseconds);
float getTime();

#ifdef __cplusplus
}
#endif

#endif
</file>

<file path="include/polonet.h">
/**
 * libpolonet
 * Lightweight TCP/IP network module for educational environments
 * (C) 2011 by the libpolo team.
 *     Marc S. Ressl (mressl@itba.edu.ar)
 *     Jorge Prendes (jprendes@itba.edu.ar)
 *     Agustin Perez Moreno
 * Released under the GPL
 */

/*
 * Polonet is capable of making and receiving TCP/IP connections.
 *
 * Usage as a client:
 * - Call openConnection() to connect to a host. This returns a
 *   PolonetConn identifier. If the connection could not be established,
 *   the identifier is 0.
 *
 * Usage as a server:
 * - Call startListening() to start listening to connections on a port.
 *   It returns 1 on success, 0 on error.
 * - getAvailableConnection() gets the next available incoming connection.
 *   If there is no incoming connection, 0 is returned.
 *
 * Managing a connection:
 * - Before you can use a connection, it is pending. Use isPending() to
 *   determine if a connection is being established.
 * - isConnected() determines if a connection is established.
 * - Call sendData() to send bytes to a connection. It returns
 *   the number of bytes sent.
 * - Call receiveData() to receive bytes from a connection. It returns
 *   the number of bytes received.
 * - Call closeConnection() to close a connection. You should always
 *   close the connections you receive from openConnection() or
 *   getAvailableConnection().
 * - Note: all calls are non-blocking.
 * - Note: when disconnected, isConnected() returns true until all data has
 *   been read with receiveData().
 */

#ifndef _LIBPOLONET_H
#define _LIBPOLONET_H

#ifdef __cplusplus
extern "C" {
#endif

#define PolonetConn int

/* Client functions */
PolonetConn openConnection(const char *hostname, unsigned short port);

/* Server functions */
int startListening(unsigned short port);
void stopListening();
PolonetConn getAvailableConnection();

/* Connection functions */
int isPending(PolonetConn conn);
int isConnected(PolonetConn conn);
int sendData(PolonetConn conn, char *buffer, const int bufferSize);
int receiveData(PolonetConn conn, char *buffer, const int bufferSize);
void closeConnection(PolonetConn conn);

#ifdef __cplusplus
}
#endif

#endif
</file>

<file path="include/SinglePlayerGame.hpp">
//
// Created by barrachina on 12/21/18.
//

#ifndef FORBIDDENDESERT_SINGLEPLAYERGAME_H
#define FORBIDDENDESERT_SINGLEPLAYERGAME_H

#include "Game.hpp"

class SinglePlayerGame : public Game {
public:
    SinglePlayerGame(ALL *allegro, Container *info);
    bool eventHandler(ALL *allegro) override;
private:
    //! Methods
    void pickUpAction() override;
    // Update Screen
    void updateScreen(ALL* allegro) override;
    void updateTilesButton(ALL* allegro) override;
    //End Of Game
    bool win(ALL *allegro) override;
    bool lose(ALL *allegro) override;
    void wannaPlay(ALL *allegro, char ID) override;
    //Keys Pressed
    void keyUp(ALL *allegro) override;
    void keyDown(ALL *allegro) override;
    void keyLeft(ALL *allegro) override;
    void keyRight(ALL *allegro) override;
    void keyE(ALL* allegro) override;
    void keyP(ALL *allegro) override;
    void keyR(ALL *allegro) override;
    //Mouse Methods
    void click(ALL* allegro) override;
    void clickOnPeepMode(ALL* allegro) override;
    void clickOnJetPackMode(ALL* allegro) override;
    void clickOnTerrascopeMode(ALL* allegro) override;
    void clickOnRequestWaterMode(ALL*  allegro) override;
    void clickOnOfferEquipmentMode(ALL* allegro) override;
    void clickOnRequestEquipmentMode(ALL* allegro) override;
    void clickOnOfferWaterMode(ALL* allegro) override;
    void clickOnDefaultMode(ALL* allegro) override;     // TODO: here to change player
    void clickTilesButtons(ALL *allegro) override;
    void clickModesButtons(ALL* allegro) override;
    void checkTilesButtons(double volume) override;

    //Equipments methods
    void drawEquipment(EquipmentsEnum equipEnum) override;
    void drawStormCards(ALL *allegro) override;

    void performEquipmentsAction(EquipmentsEnum equipEnum, ALL *allegro) override;
};


#endif //FORBIDDENDESERT_SINGLEPLAYERGAME_H
</file>

<file path="include/StartMenu.hpp">
#ifndef STARTMENU_H_INCLUDED
#define STARTMENU_H_INCLUDED	//Se incluyen definiciones y estructuras que usan todos los .cpp

#include "def.hpp"
#include "allegro.hpp"
#include "fsmInit.h"

class StartMenu {
public:
	StartMenu(ALL *allegro);
	//~StartMenu();

	bool eventHandler(ALL *allegro);

    bool get_player_mode() { return singlePlayer; }

private:
	//! Variables
	pos mouse;
	bool redraw;
	bool singlePlayer;

	//ALLEGRO_BITMAP	*background;
	// Buttons
	Button *singlePlayerButton;
	Button *multiPlayerButton;

	//! Methods
	void checkMouse(ALL* allegro);
	bool click(ALL* allegro);
	void initializeButtons(ALL* allegro);

	void updateScreen(ALL* allegro);


};

#endif
</file>

<file path="include/StormCard.hpp">
#ifndef STORMCARD_H_INCLUDED
#define STORMCARD_H_INCLUDED

#include "def.hpp"
#include "allegro.hpp"

enum StormCardsEnum { SUNBEATSDOWN, STORMUP,
	RIGHT1, LEFT1, UP1, DOWN1,
	RIGHT2, LEFT2, UP2, DOWN2,
	RIGHT3, LEFT3, UP3, DOWN3};

class StormCard {
public:
	StormCard();
	~StormCard();
	StormCard(StormCardsEnum cardEnum, ALL *allegro);
	//Getter
	StormCardsEnum getStormCardType() { return stormCardEnum; }
	void showImage(ALL *allegro);
	void peepShowImage(ALL* allegro) { al_draw_bitmap(cardImage, (allegro->screenWidth - al_get_bitmap_width(cardImage)) / 2, (allegro->screenHeight - al_get_bitmap_height(cardImage)) / 2, 0); }
private:
	ALLEGRO_BITMAP *cardImage;
	StormCardsEnum stormCardEnum;
};

#endif
</file>

<file path="include/Tile.hpp">
#ifndef TILES_H_INCLUDED
#define TILES_H_INCLUDED

#include "def.hpp"
#include "allegro.hpp"
#include "Button.hpp"

enum TilesEnum { STORM, CRASHSITE, WATER, DEFAULT, TUNNEL, LAUNCHPAD, 
	GEAR1, GEAR2, GEAR3, GEAR4, GEAR5, GEAR6, GEAR7, GEAR8, 
	PROPELLERROW, PROPELLERCOLUMN, SOLARCRYSROW, SOLARCRYSCOLUMN, NAVIGATIONROW, NAVIGATIONCOLUMN, ENGINEROW, ENGINECOLUMN };

static char *TilesNames[] = {
		const_cast<char *>("STORM"), const_cast<char *>("CRASHSITE"), const_cast<char *>("WATER"),
		const_cast<char *>("DEFAULT"), const_cast<char *>("TUNNEL"), const_cast<char *>("LAUNCHPAD"),
		const_cast<char *>("GEAR1"), const_cast<char *>("GEAR2"), const_cast<char *>("GEAR3"),
		const_cast<char *>("GEAR4"), const_cast<char *>("GEAR5"), const_cast<char *>("GEAR6"),
		const_cast<char *>("GEAR7"), const_cast<char *>("GEAR8"),
		const_cast<char *>("PROPELLERROW"), const_cast<char *>("PROPELLERCOLUMN"), const_cast<char *>("SOLARCRYSROW"),
		const_cast<char *>("SOLARCRYSCOLUMN"), const_cast<char *>("NAVIGATIONROW"),
		const_cast<char *>("NAVIGATIONCOLUMN"), const_cast<char *>("ENGINEROW"), const_cast<char *>("ENGINECOLUMN")
		};

class Tile {
public:
	Tile();
	Tile(TilesEnum tileType, ALL* allegro);
	~Tile();
	void updateTile(ALL *allegro);
	//Buttons Methods
	void updateButton(ALL* allegro);
	bool checkButton(int mousex, int mousey, double volume);
	//Setters
	void turnTile();
	void turnTerrascopeTile();
	void setSand(int i);
	void increaseSand();
	void setCoord(pos coords);
	// Getters
	TilesEnum gettileType() { return tileEnum; }
	bool isTurned() {return turned;}
	void setTurned(bool turned) { this->turned = turned; }
	bool canIMove(bool climber);
	int getSand(void) { return sand; }
	bool canIMoveClimber();
	bool haveSand();
	void removeSand() { if(sand>0) sand--; }
	ALLEGRO_BITMAP* getTileBackImage() { return backOfCardImage; }
private:
	ALLEGRO_BITMAP *backOfCardImage;
	ALLEGRO_BITMAP *frontOfCardImage;
	Button *frontCardButton;
	Button *backCardButton;
	ALLEGRO_BITMAP *oneSandImage;
	ALLEGRO_BITMAP *multipleSandImage;
	pos tileCoords;
	bool turned;
	TilesEnum tileEnum;
	int sand;
};

#endif
</file>

<file path="include/WaterCarrierButton.hpp">
#ifndef WATERCARRIERBUTTON_H_INCLUDED
#define WATERCARRIERBUTTON_H_INCLUDED

#include "Button.hpp"

class WaterCarrierButton : public Button {
public:
	WaterCarrierButton();
	WaterCarrierButton(int x0, int y0, const char *imageName, const char * nonSelectedImageName, ALL* allegro);
	bool buttonAction(int x, int y);
};

#endif
</file>

<file path="include/WaterCarrierCharacter.hpp">
#ifndef WATERCARRIERCHARACTER_H_INCLUDED
#define WATERCARRIERCHARACTER_H_INCLUDED

#include "Character.hpp"

class WaterCarrierCharacter : public Character {
public:
	WaterCarrierCharacter(int rowSet, int columnSet, Container info, ALL *allegro);
	~WaterCarrierCharacter();
	virtual void addWater();		//As in the father its virtual it will be virtual anyway but for clarity I define it virtual
	bool checkMouseOverButton(int x, int y, double volume) { return getWatersFromWellButton->checkMouse(x, y, volume); }
	void updateGetWatersFromWell(bool imOnDiscoveredWell, ALL* allegro);
	bool getWatersFromWell();

private:
	ALLEGRO_BITMAP *watersImage[MAXOFWATERS];
	ALLEGRO_BITMAP *waterCarrierImage;
	Button *getWatersFromWellButton;
	ALLEGRO_BITMAP* disabledGetWatersFromWellImage;
};

#endif
</file>

<file path="src/allegro.cpp">
#include "allegro.hpp"
#include "def.hpp"


#define FPS 30
#define SAMPLES 3	//Number of audios that can me played at the same time
#define FONTSIZE 60

#define OK 0
#define READY 1
#define EXIT -1
//Dejar estos aca!

//////////////////////////////////////////////////////////////////////////////////////////////
//				INICIALIZO ALLEGRO Y TODOS LOS COMPLEMENTOS QUE SE USAN						//
//////////////////////////////////////////////////////////////////////////////////////////////
bool init_allegro(ALL *allegro) {
	bool state = false;
	allegro->volume = 1.0;
	//Initialize Allegro
	if (al_init()) {
		if (al_init_primitives_addon()) {
			if (al_init_image_addon()) {
				if (al_install_mouse()) {
					if (al_install_keyboard()) {
						//CODE TO FULLSCREEN, CHANGE IN CASE OF MULFUNCTION
						/*TODO: lo comento porque es dificil para debuguear... luego agregarlo. tira mas facha*/
						/*ALLEGRO_DISPLAY_MODE   disp_data;
						al_get_display_mode(al_get_num_display_modes() - 1, &disp_data);
						al_set_new_display_flags(ALLEGRO_FULLSCREEN);
						allegro->display = al_create_display(disp_data.width, disp_data.height);
						allegro->screenWidth = disp_data.width;
						allegro->screenHeight = disp_data.height;*/
						//allegro->display = al_create_display(SCREEN_X, SCREEN_Y);
						allegro->screenWidth = SCREEN_X;
						allegro->screenHeight = SCREEN_Y;

						allegro->startMenuDisplay = al_create_display(WIDTH * allegro->screenWidth / MAXRESOLUTION_X, HEIGHT * allegro->screenHeight / MAXRESOLUTION_Y);
						al_set_window_title(allegro->startMenuDisplay, "Start Menu");

						if (allegro->startMenuDisplay != NULL) {
							state = true;
						}
						else { cerr << "Failed to initialize startMenuDisplay" << endl; al_uninstall_keyboard(); }
					}
					else { cerr << "Failed to initialize keyboard" << endl; al_uninstall_mouse(); }
				}
				else { cerr << "Failed to initialize mouse" << endl; al_shutdown_image_addon(); }
			}
			else { cerr << "Failed to initialize image addon" << endl; al_shutdown_primitives_addon(); }
		}
		else { cerr << "Failed to initialize primitives addon" << endl; }
	}
	else { cerr << "Failed to initialize allegro" << endl; }
	//Timer for polonet
	if (state) {
		state = false;
		if (allegro->timeout = al_create_timer(1)) {
			al_set_timer_count(allegro->timeout, 0);
			state = true;
		}
		else { cerr << "Failed to initialize timeout" << endl; }
	}
	//Initialize events
	if (state) {
		state = false;
		if (allegro->timer = al_create_timer(1.0 / FPS)) {
			if (allegro->events_queue = al_create_event_queue()) {
				al_register_event_source(allegro->events_queue, al_get_display_event_source(allegro->startMenuDisplay));
				al_register_event_source(allegro->events_queue, al_get_timer_event_source(allegro->timer));
				al_register_event_source(allegro->events_queue, al_get_keyboard_event_source());
				al_register_event_source(allegro->events_queue, al_get_mouse_event_source());
				state = true;
			}
		}
		else { cerr << "Failed to initialize timer" << endl; }
	}
	//Initialize stormMeter image
	if (state) {
		state = false;
		if (allegro->stormMeter[0] = al_load_bitmap_resized("Resources/StormMeter/stormMeterImage.png", allegro)) {
			if (allegro->stormMeter[1] = al_load_bitmap_resized("Resources/StormMeter/stormMeter1Image.png", allegro)) {
				if (allegro->stormMeter[2] = al_load_bitmap_resized("Resources/StormMeter/stormMeter2Image.png", allegro)) {
					if (allegro->stormMeter[3] = al_load_bitmap_resized("Resources/StormMeter/stormMeter3Image.png", allegro)) {
						if (allegro->stormMeter[4] = al_load_bitmap_resized("Resources/StormMeter/stormMeter4Image.png", allegro)) {
							if (allegro->stormMeter[5] = al_load_bitmap_resized("Resources/StormMeter/stormMeter5Image.png", allegro)) {
								if (allegro->stormMeter[6] = al_load_bitmap_resized("Resources/StormMeter/stormMeter6Image.png", allegro)) {
									if (allegro->stormMeter[7] = al_load_bitmap_resized("Resources/StormMeter/stormMeter7Image.png", allegro)) {
										if (allegro->stormMeter[8] = al_load_bitmap_resized("Resources/StormMeter/stormMeter8Image.png", allegro)) {
											if (allegro->stormMeter[9] = al_load_bitmap_resized("Resources/StormMeter/stormMeter9Image.png", allegro)) {
												if (allegro->stormMeter[10] = al_load_bitmap_resized("Resources/StormMeter/stormMeter10Image.png", allegro)) {
													if (allegro->stormMeter[11] = al_load_bitmap_resized("Resources/StormMeter/stormMeter11Image.png", allegro)) {
														if (allegro->stormMeter[12] = al_load_bitmap_resized("Resources/StormMeter/stormMeter12Image.png", allegro)) {
															if (allegro->stormMeter[13] = al_load_bitmap_resized("Resources/StormMeter/stormMeter13Image.png", allegro)) {
																if (allegro->stormMeter[14] = al_load_bitmap_resized("Resources/StormMeter/stormMeter14Image.png", allegro)) {
																	state = true;
																}
																else { cerr << "Unable to load stormMeter14Image" << endl; }
															}
															else { cerr << "Unable to load stormMeter13Image" << endl; }
														}
														else { cerr << "Unable to load stormMeter12Image" << endl; }
													}
													else { cerr << "Unable to load stormMeter11Image" << endl; }
												}
												else { cerr << "Unable to load stormMeter10Image" << endl; }
											}
											else { cerr << "Unable to load stormMeter9Image" << endl; }
										}
										else { cerr << "Unable to load stormMeter8Image" << endl; }
									}
									else { cerr << "Unable to load stormMeter7Image" << endl; }
								}
								else { cerr << "Unable to load stormMeter6Image" << endl; }
							}
							else { cerr << "Unable to load stormMeter5Image" << endl; }
						}
						else { cerr << "Unable to load stormMeter4Image" << endl; }
					}
					else { cerr << "Unable to load stormMeter3Image" << endl; }
				}
				else { cerr << "Unable to load stormMeter2Image" << endl; }
			}
			else { cerr << "Unable to load stormMeter1Image" << endl; }
		}
		else { cerr << "Unable to load stormMeterImage" << endl; }
	}
	if (state) {
		state = false;
		if (allegro->menuBackgroundImage = al_load_bitmap_resized("Resources/BackMenu.png", allegro)) { state = true; }
	}
	if (state) {
		state = false;
		if (allegro->backgroundStartMenuImage = al_load_bitmap_resized("Resources/startMenuImage.png", allegro)) { state = true; }
	}
	//Initialize Equipment
	if (state) {
		state = false;
		if (allegro->haveEquipments[0] = al_load_bitmap_resized("Resources/Equipment/haveDuneBlasterImage.png", allegro)) {
			if (allegro->haveEquipments[1] = al_load_bitmap_resized("Resources/Equipment/haveJetPackImage.png", allegro)) {
				if (allegro->haveEquipments[2] = al_load_bitmap_resized("Resources/Equipment/haveSecretWaterReserveImage.png", allegro)) {
					if (allegro->haveEquipments[3] = al_load_bitmap_resized("Resources/Equipment/haveSolarShieldImage.png", allegro)) {
						if (allegro->haveEquipments[4] = al_load_bitmap_resized("Resources/Equipment/haveTerrascopeImage.png", allegro)) {
							if (allegro->haveEquipments[5] = al_load_bitmap_resized("Resources/Equipment/haveTimeThrottleImage.png", allegro)) {
								if (allegro->noEquipments[0] = al_load_bitmap_resized("Resources/Equipment/noDuneBlasterImage.png", allegro)) {
									if (allegro->noEquipments[1] = al_load_bitmap_resized("Resources/Equipment/noJetPackImage.png", allegro)) {
										if (allegro->noEquipments[2] = al_load_bitmap_resized("Resources/Equipment/noSecretWaterReserveImage.png", allegro)) {
											if (allegro->noEquipments[3] = al_load_bitmap_resized("Resources/Equipment/noSolarShieldImage.png", allegro)) {
												if (allegro->noEquipments[4] = al_load_bitmap_resized("Resources/Equipment/noTerrascopeImage.png", allegro)) {
													if (allegro->noEquipments[5] = al_load_bitmap_resized("Resources/Equipment/noTimeThrottleImage.png", allegro)) {
														if (allegro->equipmentCards[0] = al_load_bitmap_resized("Resources/Equipment/duneBlasterImage.png", allegro)) {
															if (allegro->equipmentCards[1] = al_load_bitmap_resized("Resources/Equipment/jetPackImage.png", allegro)) {
																if (allegro->equipmentCards[2] = al_load_bitmap_resized("Resources/Equipment/solarShieldImage.png", allegro)) {
																	if (allegro->equipmentCards[3] = al_load_bitmap_resized("Resources/Equipment/terrascopeImage.png", allegro)) {
																		if (allegro->equipmentCards[4] = al_load_bitmap_resized("Resources/Equipment/secretWaterReserveImage.png", allegro)) {
																			if (allegro->equipmentCards[5] = al_load_bitmap_resized("Resources/Equipment/timeThrottleImage.png", allegro)) {
																				state = true;
																			}
																			else { cerr << "Unable to load timeThrottleImage.png" << endl; }
																		}
																		else { cerr << "Unable to load secretWaterReserveImage.png" << endl; }
																	}
																	else { cerr << "Unable to load terrascopeImage.png" << endl; }
																}
																else { cerr << "Unable to load solarShieldImage.png" << endl; }
															}
															else { cerr << "Unable to load jetPackImage.png" << endl; }
														}
														else { cerr << "Unable to load duneBlasterImage.png" << endl; }
													}
													else { cerr << "Unable to load noTimeThrottleImage.png" << endl; }
												}
												else { cerr << "Unable to load noTerrascopeImage.png" << endl; }
											}
											else { cerr << "Unable to load noSolarShieldImage.png" << endl; }
										}
										else { cerr << "Unable to load noSecretWaterReserveImage.png" << endl; }
									}
									else { cerr << "Unable to load noJetPackImage.png" << endl; }
								}
								else { cerr << "Unable to load noDuneBlasterImage.png" << endl; }
							}
							else { cerr << "Unable to load haveTimeThrottleImage.png" << endl; }
						}
						else { cerr << "Unable to load haveTerrascopeImage.png" << endl; }
					}
					else { cerr << "Unable to load haveSolarShieldImage.png" << endl; }
				}
				else { cerr << "Unable to load haveSecretWaterReserveImage.png" << endl; }
			}
			else { cerr << "Unable to load haveJetPackImage.png" << endl; }
		}
		else { cerr << "Unable to load haveDuneBlasterImage.png" << endl; }
	}
	//Load Part Images
	if (state) {
		state = false;
		if (allegro->partsImages[0] = al_load_bitmap_resized("Resources/Parts/engineImage.png", allegro)) {
			if (allegro->partsImages[1] = al_load_bitmap_resized("Resources/Parts/navegationDeckImage.png", allegro)) {
				if (allegro->partsImages[2] = al_load_bitmap_resized("Resources/Parts/propellerImage.png", allegro)) {
					if (allegro->partsImages[3] = al_load_bitmap_resized("Resources/Parts/solarCrystalImage.png", allegro)) {
						if (allegro->partsImages[4] = al_load_bitmap_resized("Resources/Parts/noEngineImage.png", allegro)) {
							if (allegro->partsImages[5] = al_load_bitmap_resized("Resources/Parts/noNavegationDeckImage.png", allegro)) {
								if (allegro->partsImages[6] = al_load_bitmap_resized("Resources/Parts/noPropellerImage.png", allegro)) {
									if (allegro->partsImages[7] = al_load_bitmap_resized("Resources/Parts/noSolarCrystalImage.png", allegro)) {
										state = true;
									}
									else { cerr << "Failed to load No Solar Crystal Image" << endl; }
								}
								else { cerr << "Failed to load no Propeller Image" << endl; }
							}
							else { cerr << "Failed to load no NavigationDeckImage" << endl; }
						}
						else { cerr << "Failed to load no EngineImage" << endl; }
					}
					else { cerr << "Failed to load no Solar Crystal Image" << endl; }
				}
				else { cerr << "Failed to load Propeller Image" << endl; }
			}
			else { cerr << "Failed to load NavigationDeckImage" << endl; }
		}
		else { cerr << "Failed to load EngineImage" << endl; }
	}
	//Rectangle
	if (state) {
		state = false;
		if (allegro->rectangleImage[0] = al_load_bitmap_resized("Resources/Buttons/AdventurerSpecialsDescription/archeologistRectangle.png", allegro)) {
			if (allegro->rectangleImage[1] = al_load_bitmap_resized("Resources/Buttons/AdventurerSpecialsDescription/climberRectangle.png", allegro)) {
				if (allegro->rectangleImage[2] = al_load_bitmap_resized("Resources/Buttons/AdventurerSpecialsDescription/explorerRectangle.png", allegro)) {
					if (allegro->rectangleImage[3] = al_load_bitmap_resized("Resources/Buttons/AdventurerSpecialsDescription/navigatorRectangle.png", allegro)) {
						if (allegro->rectangleImage[4] = al_load_bitmap_resized("Resources/Buttons/AdventurerSpecialsDescription/waterCarrierRectangle.png", allegro)) {
							if (allegro->rectangleImage[5] = al_load_bitmap_resized("Resources/Buttons/AdventurerSpecialsDescription/meteorologistRectangle.png", allegro)) {
								state = true;
							}
							else { cerr << "Failed to load Meteorologist Rectangle" << endl; }
						}
						else { cerr << "Failed to load Water Carrier Rectangle" << endl; }
					}
					else { cerr << "Failed to load Navigator Rectangle" << endl; }
				}
				else { cerr << "Failed to load Explorer Rectangle" << endl; }
			}
			else { cerr << "Failed to load Climber Rectangle" << endl; }
		}
		else { cerr << "Failed to load Archeologist Rectangle" << endl; }
	}
	//Load Audio
	if (state) {
		state = false;
		if (al_install_audio()) {
			if (al_init_acodec_addon()) {
				if (al_reserve_samples(SAMPLES)) {
					if (allegro->backgroundMusic = al_load_sample("Resources/Sounds/MenuBackMusic.wav")) {
						if (allegro->clickOnButtonSound = al_load_sample("Resources/Sounds/ClickOnButton.wav")) {
							if (allegro->sunBeatsDownSound = al_load_sample("Resources/Sounds/SunBeatsDown.wav")) {
								if (allegro->waterSound = al_load_sample("Resources/Sounds/WATER.wav")) {
									if (allegro->stormSound = al_load_sample("Resources/Sounds/storm.wav")) {
										if (allegro->excavateSound = al_load_sample("Resources/Sounds/excavate.wav")) {
											if (allegro->curiositySound = al_load_sample("Resources/Sounds/curiosity.wav")) {
												if (allegro->teleportSound = al_load_sample("Resources/Sounds/teleport.wav")) {
													if (allegro->startMusic = al_load_sample("Resources/Sounds/blood.wav")) {
														if (allegro->rejectEquipmentBoySound = al_load_sample("Resources/Sounds/RejectEquipment(B).wav")) {
															if (allegro->rejectEquipmentGirlSound = al_load_sample("Resources/Sounds/RejectEquipment(G).wav")) {
																if (allegro->rejectWaterBoySound = al_load_sample("Resources/Sounds/RejectWater(B).wav")) {
																	if (allegro->rejectWaterGirlSound = al_load_sample("Resources/Sounds/RejectWater(G).wav")) {
																		state = true;
																	}
																}
																else { cerr << "Failed to load Reject Water Sound" << endl; }
															}
															else { cerr << "Failed to load Reject Equipment Sound" << endl; }
														}
														else { cerr << "Failed to load Reject Equipment Sound" << endl; }
													}
													else { cerr << "Failed to load blood sound" << endl; }
												}
												else { cerr << "Failed to load teleport Sound" << endl; }
											}
											else { cerr << "Failed to load curiosity Sound" << endl; }
										}
										else { cerr << "Failed to load Excavate Sound" << endl; }
									}
									else { cerr << "Failed to load Storm Sound sample" << endl; }
								}
								else { cerr << "Failed to load sample water sound" << endl; }
							}
							else { cerr << "Failed to load sample sun beats down" << endl; }
						}
						else { cerr << "Failed to load samples" << endl; }
					}
				}
				else { cerr << "Failed to reserve samples" << endl; }
			}
			else { cerr << "Failed to init audio addon" << endl; }
		}
		else { cerr << "Failed to install audio" << endl; }
	}
	//Initialize fonts
	if (state) {
		state = false;
		al_init_font_addon();
		if (al_init_ttf_addon()) {
			if (allegro->font = al_load_ttf_font("Resources/Papyrus.ttf", 25, 0)) {
				if (allegro->statusFont = al_load_ttf_font("Resources/consola.ttf", 12, 0)) {
					if (allegro->gameFont = al_load_ttf_font("Resources/Papyrus.ttf", FONTSIZE * allegro->screenHeight / MAXRESOLUTION_Y, 0)) {
						state = true;
					}
					else { cerr << "Failed to initialize gameFont" << endl; }
				}
				else { cerr << "Failed to initialize consola.ttf" << endl; }
			}
			else { cerr << "Failed to initialize Papyrus.ttf" << endl; }
		}
		else { cerr << "Failed to initialize ttf addon" << endl; }
	}

	al_flip_display();
	al_start_timer(allegro->timer);

	return state;
}

void destroyAll(ALL *allegro) {
	al_destroy_event_queue(allegro->events_queue);
	//Timers
	al_destroy_timer(allegro->timer);
	al_destroy_timer(allegro->timeout);
	//Sample
	al_destroy_sample(allegro->clickOnButtonSound);
	al_destroy_sample(allegro->sunBeatsDownSound);
	al_destroy_sample(allegro->waterSound);
	al_destroy_sample(allegro->excavateSound);
	al_destroy_sample(allegro->curiositySound);
	al_destroy_sample(allegro->teleportSound);
	al_destroy_sample(allegro->startMusic);
	al_destroy_sample(allegro->rejectWaterGirlSound);
	al_destroy_sample(allegro->rejectEquipmentBoySound);
	al_destroy_sample(allegro->rejectWaterBoySound);
	al_destroy_sample(allegro->rejectEquipmentGirlSound);
	al_destroy_sample(allegro->backgroundMusic);
	//Fonts
	al_destroy_font(allegro->font);
	al_destroy_font(allegro->statusFont);
	al_destroy_font(allegro->gameFont);
	//Bitmaps
	al_destroy_bitmap(allegro->menuBackgroundImage);
	al_destroy_bitmap(allegro->backgroundStartMenuImage);
	al_destroy_bitmap(allegro->fondo);
	al_destroy_bitmap(allegro->mouse);
	for (int i = 0; i < 15; i++)
		al_destroy_bitmap(allegro->stormMeter[i]);
	for (int i = 0; i < 6; i++) {
		al_destroy_bitmap(allegro->haveEquipments[i]);
		al_destroy_bitmap(allegro->noEquipments[i]);
		al_destroy_bitmap(allegro->equipmentCards[i]);
	}
	for (int i = 0; i < 8; i++)
		al_destroy_bitmap(allegro->partsImages[i]);
	for (int i = 0; i < 6; i++)
		al_destroy_bitmap(allegro->rectangleImage[i]);
	//Cursor
	al_destroy_mouse_cursor(allegro->cursor);
	//Addons
	al_uninstall_keyboard();
	al_uninstall_mouse();
	al_shutdown_image_addon();
	al_shutdown_ttf_addon();
	al_shutdown_primitives_addon();
	al_uninstall_audio();

}

char* getcharAllegro(ALL* allegro, int x, int y) {
	ALLEGRO_USTR* str = al_ustr_new("");            //creo ustring para escribir en allegro
	int pos = (int)al_ustr_size(str);
	char* mystring;

	char quit = OK;
	while (quit == OK) {
		al_draw_filled_rectangle(x, y, x + WIDTH * allegro->screenWidth / MAXRESOLUTION_X / 2 - 8, y + 40, al_map_rgb(0, 0, 0));
		al_draw_ustr(allegro->font, al_map_rgb(WHITE), x, y, ALLEGRO_ALIGN_LEFT, str);  //area donde escribo
		al_flip_display();  //muestro lo que escribo

		ALLEGRO_EVENT e;
		al_wait_for_event(allegro->events_queue, &e);
		switch (e.type) {
		case ALLEGRO_EVENT_KEY_CHAR:
			if (e.keyboard.unichar >= 32) {
				pos += al_ustr_append_chr(str, e.keyboard.unichar);
			}
			else if (e.keyboard.keycode == ALLEGRO_KEY_BACKSPACE) {
				if (al_ustr_prev(str, &pos))
					al_ustr_truncate(str, pos);
			}
			if (e.keyboard.unichar == 13) {
				quit = READY;
			}
			break;
		case ALLEGRO_EVENT_DISPLAY_CLOSE:
			quit = EXIT;
			break;
		}
	}
	if (quit == READY)
		mystring = (char *)al_cstr(str);     //TIRA WARNING POR QUE LA FUNCION TRABAJA CON CONST    
	if (quit == EXIT)
		mystring = NULL;

	return mystring;
}

void printAllegro(ALL *allegro, char *msg) {
	al_set_target_backbuffer(allegro->startMenuDisplay);
	al_draw_filled_rectangle(0, HEIGHT * allegro->screenHeight / MAXRESOLUTION_Y - 15, WIDTH * allegro->screenWidth / MAXRESOLUTION_X, HEIGHT * allegro->screenHeight / MAXRESOLUTION_Y, al_map_rgb(0, 0, 0));
	al_draw_textf(allegro->statusFont, al_map_rgb(WHITE), WIDTH * allegro->screenWidth / MAXRESOLUTION_X / 2, HEIGHT * allegro->screenHeight / MAXRESOLUTION_Y - 12, ALLEGRO_ALIGN_CENTRE, "%s", msg);
	al_flip_display();
}

ALLEGRO_BITMAP *al_load_bitmap_resized(const char *filename, ALL* allegro) {
	ALLEGRO_BITMAP *resized_bmp, *loaded_bmp, *prev_target;
	//La idea es que esta funcion hace lo mismo que al_load_bitmap pero ya resizeado...

	// 1. load the bitmap at the original size				 
	loaded_bmp = al_load_bitmap(filename);
	if (!loaded_bmp) return NULL;

	// 2. create a temporary bitmap of size we want
	resized_bmp = al_create_bitmap(al_get_bitmap_width(loaded_bmp) * allegro->screenWidth / MAXRESOLUTION_X, al_get_bitmap_height(loaded_bmp) * allegro->screenHeight / MAXRESOLUTION_Y);
	if (!resized_bmp) {
		al_destroy_bitmap(loaded_bmp);
		return NULL;
	}

	// 3. set the target bitmap to the resized bmp
	prev_target = al_get_target_bitmap();
	al_set_target_bitmap(resized_bmp);

	// 4. copy the loaded bitmap to the resized bmp
	al_draw_scaled_bitmap(loaded_bmp,
		0, 0,                                // source origin
		al_get_bitmap_width(loaded_bmp),     // source width
		al_get_bitmap_height(loaded_bmp),    // source height
		0, 0,                                // target origin
		al_get_bitmap_width(loaded_bmp) * allegro->screenWidth / MAXRESOLUTION_X,		// target dimensions
		al_get_bitmap_height(loaded_bmp) * allegro->screenHeight / MAXRESOLUTION_Y,
		0                                    // flags
		);

	// 5. restore the previous target and clean up
	al_set_target_bitmap(prev_target);
	al_destroy_bitmap(loaded_bmp);

	return resized_bmp;
}

void drawStartMenu(ALL *allegro) {
	al_set_target_backbuffer(allegro->startMenuDisplay);
	al_clear_to_color(al_map_rgb(0, 0, 0));
	al_draw_bitmap(allegro->backgroundStartMenuImage, 0, 0, 0);
	al_draw_filled_rectangle(0, HEIGHT * allegro->screenHeight / MAXRESOLUTION_Y - 15, WIDTH * allegro->screenWidth / MAXRESOLUTION_X, HEIGHT * allegro->screenHeight / MAXRESOLUTION_Y, al_map_rgb(0, 0, 0));
	al_draw_text(allegro->font, al_map_rgb(WHITE), 10, HEIGHT * allegro->screenHeight / MAXRESOLUTION_Y / 3 - 30, 0, "Please, enter IP:");
	al_draw_filled_rectangle(5, HEIGHT * allegro->screenHeight / MAXRESOLUTION_Y / 3, WIDTH * allegro->screenWidth / MAXRESOLUTION_X * 0.7, HEIGHT * allegro->screenHeight / MAXRESOLUTION_Y / 3 + 40, al_map_rgb(0, 0, 0));
	al_draw_text(allegro->font, al_map_rgb(WHITE), 10, HEIGHT * allegro->screenHeight / MAXRESOLUTION_Y / 2 - 30, 0, "Your name:");
	al_draw_filled_rectangle(5, HEIGHT * allegro->screenHeight / MAXRESOLUTION_Y / 2, WIDTH * allegro->screenWidth / MAXRESOLUTION_X * 0.7, HEIGHT * allegro->screenHeight / MAXRESOLUTION_Y / 2 + 40, al_map_rgb(0, 0, 0));
}

void drawChooseModeStartMenu(ALL *allegro) {
	al_set_target_backbuffer(allegro->startMenuDisplay);
	al_clear_to_color(al_map_rgb(0, 0, 0));
	al_draw_bitmap(allegro->backgroundStartMenuImage, 0, 0, 0);
	al_draw_text(allegro->font, al_map_rgb(WHITE), 10, HEIGHT * allegro->screenHeight / MAXRESOLUTION_Y / 3 - 30, 0, "Please, enter IP:");
	al_draw_text(allegro->font, al_map_rgb(WHITE), 10, HEIGHT * allegro->screenHeight / MAXRESOLUTION_Y / 2 - 30, 0, "Your name:");
}
</file>

<file path="src/ArcheologistButton.cpp">
#include "ArcheologistButton.hpp"

ArcheologistButton::ArcheologistButton() {}
ArcheologistButton::ArcheologistButton(int x0, int y0, const char *imageName, const char * nonSelectedImageName, ALL* allegro) : Button(x0, y0, imageName, nonSelectedImageName, allegro) {}

bool ArcheologistButton::buttonAction(int x, int y) {
	if (mouseOverButton) {
		cout << "Click on Archeologist Button" << endl;
		al_play_sample(selectCharSample, 1.0, 0.0, 1.0, ALLEGRO_PLAYMODE_ONCE, NULL);
		return true;
	}
	return false;
}
</file>

<file path="src/ArcheologistCharacter.cpp">
#include "ArcheologistCharacter.hpp"


ArcheologistCharacter::ArcheologistCharacter(int rowSet, int columnSet, Container info, ALL* allegro) : Character(rowSet, columnSet, info, allegro) {
	if(adventurerImage = al_load_bitmap_resized("Resources/Players/archeologistImage.png", allegro)){
		if (image = al_load_bitmap_resized("Resources/Players/Pawns/ArcheologistPawnImage.png", allegro)) {
			if (gettingCloseSound = al_load_sample("Resources/Sounds/MustBeGettingClose(Girl).wav")) {
			}
			else { cout << "Failed to load Must be getting close Sound" << endl; }
		}
		else { cout << "Failed to load Archeologist Pawn Image" << endl; }
	}
	else { cout << "Failed to load archeologistImage.png" << endl; }
}
ArcheologistCharacter::~ArcheologistCharacter()
{
	for (int i = 0; i < MAXOFWATERS; i++) { al_destroy_bitmap(watersImage[i]); }
	al_destroy_bitmap(archeologistImage);
	al_destroy_sample(gettingCloseSound);
}
</file>

<file path="src/Button.cpp">
#include "Button.hpp"

Button::Button() {}
Button::Button(int x0, int y0, const char * imageName, const char * nonSelectedImageName, ALL* allegro) {
	if (this->buttonImage = al_load_bitmap_resized(imageName, allegro) ) {
		if (this->nonSelectedImage = al_load_bitmap_resized(nonSelectedImageName, allegro)) {
			buttonPos.initialPos.x = x0;
			buttonPos.initialPos.y = y0;
			buttonPos.endPos.x = buttonPos.initialPos.x + al_get_bitmap_width(buttonImage);
			buttonPos.endPos.y = buttonPos.initialPos.y + al_get_bitmap_height(buttonImage);

			selectCharSample = al_load_sample("Resources/Sounds/ClickOnButton.wav");
			mouseOverButtonSample = al_load_sample("Resources/Sounds/MOUSEOVERBUTTON.wav");

			mouseOverButton = false;
		}
		else { cout << "Failed to load No selected Image, it seams this file is missing:" << nonSelectedImageName << endl; }
	}
	else { cout << "Couldn't load button image, it seams this file is missing:" << imageName << endl; }
}
void Button::changeCoords(int x, int y) {
	buttonPos.initialPos.x = x;
	buttonPos.initialPos.y = y;
	buttonPos.endPos.x = buttonPos.initialPos.x + al_get_bitmap_width(buttonImage);
	buttonPos.endPos.y = buttonPos.initialPos.y + al_get_bitmap_height(buttonImage);
}
void Button::updateButton(ALL *allegro) {
	if (mouseOverButton) { 
		//cout << buttonPos.initialPos.x << endl;
		al_draw_bitmap(nonSelectedImage, buttonPos.initialPos.x, buttonPos.initialPos.y - al_get_bitmap_height(buttonImage) / 2.0, 0);
	}
	else { 
		//cout << buttonPos.initialPos.x << endl;
		al_draw_bitmap(buttonImage, buttonPos.initialPos.x, buttonPos.initialPos.y - al_get_bitmap_height(buttonImage) / 2.0, 0);
	}
}
bool Button::checkMouse(int x, int y, double volume) {
	if ((x > buttonPos.initialPos.x) && (x < buttonPos.endPos.x)) {
		if ((y > buttonPos.initialPos.y - al_get_bitmap_height(buttonImage) / 2.0) && (y < buttonPos.endPos.y - al_get_bitmap_height(buttonImage) / 2.0)) {
			if (!mouseOverButton) {
				al_play_sample(mouseOverButtonSample, volume, 0.0, 3.0, ALLEGRO_PLAYMODE_ONCE, NULL);
			}
			mouseOverButton = true;
		}
		else { mouseOverButton = false; }
	}
	else { mouseOverButton = false; }
	return mouseOverButton;
}
void Button::testButtonAction(int x, int y) {
	if (mouseOverButton) {
		//Here I set the Button callback
		cout << "Button Click" << endl;
	}
}
int Button::getMiddleOfX() {
	return (buttonPos.initialPos.x + buttonPos.endPos.x) / 2;
}
int Button::getMiddleOfY() {
	return (buttonPos.initialPos.y + buttonPos.endPos.y) / 2;
}
pos Button::getInitialPos(void){
	return buttonPos.initialPos;
}
Button::~Button(){
	al_destroy_bitmap(buttonImage);
	al_destroy_bitmap(nonSelectedImage);
	//al_destroy_sample(selectCharSample);
	//al_destroy_sample(mouseOverButtonSample);
}
</file>

<file path="src/Character.cpp">
#include "Character.hpp"

Character::Character() {
		row = 0;
		column = 0;
		numberOfMoves = 4;
		waters = 4;
}
Character::Character(int rowSet, int columnSet, Container info, ALL* allegro) {
	
	int yoffset = allegro->screenHeight * 16 / 19 + al_get_bitmap_height(al_load_bitmap_resized("Resources/Equipment/haveDuneBlasterImage.png", allegro)) / 2.0;
	int xoffset = allegro->screenWidth / 3;
	int i = 0;
	if (gettingCloseSound = al_load_sample("Resources/Sounds/MustBeGettingClose(Boy).wav")) {

	}
	else { cerr << "Failed to load Must be getting close Sound" << endl; }
	if (image) {
		if (watersImages[0] = al_load_bitmap_resized("Resources/Water Level/0WaterLevelImage.png", allegro)) {
			if (watersImages[1] = al_load_bitmap_resized("Resources/Water Level/1WaterLevelImage.png", allegro)) {
				if (watersImages[2] = al_load_bitmap_resized("Resources/Water Level/2WaterLevelImage.png", allegro)) {
					if (watersImages[3] = al_load_bitmap_resized("Resources/Water Level/3WaterLevelImage.png", allegro)) {
						if (watersImages[4] = al_load_bitmap_resized("Resources/Water Level/4WaterLevelImage.png", allegro)) {
							if (watersImages[5] = watersImages[6] = al_load_bitmap_resized("Resources/Water Level/DWaterLevelImage.png", allegro)) {
								getClose = true;
								row = rowSet;
								column = columnSet;
								numberOfMoves = 4;
								waters = 4;
								shield = false;
								solarShield = 0;
								duneBlaster = 0;
								jetPack = 0;
								secretWaterReserve = 0; 
								terrascope = 0;
								timeThrottle = 0;
								duneBlasterButton = new Button(xoffset, yoffset, "Resources/Equipment/haveDuneBlasterImage.png", "Resources/Equipment/haveDuneBlasterImage.png", allegro);
								jetPackButton = new Button( xoffset + (al_get_bitmap_width(allegro->noEquipments[4]) + 1), yoffset, "Resources/Equipment/haveJetPackImage.png","Resources/Equipment/haveJetPackImage.png", allegro);
								secretWaterReserveButton = new Button(xoffset + 2 * (al_get_bitmap_width(allegro->noEquipments[0]) + 1), yoffset,"Resources/Equipment/haveSecretWaterReserveImage.png","Resources/Equipment/haveSecretWaterReserveImage.png", allegro);
								solarShieldButton = new Button(xoffset + 3 * (al_get_bitmap_width(allegro->noEquipments[4]) + 1), yoffset,"Resources/Equipment/haveSolarShieldImage.png","Resources/Equipment/haveSolarShieldImage.png", allegro);
								terrascopeButton = new Button( xoffset + 4 * (al_get_bitmap_width(allegro->noEquipments[4]) + 1), yoffset, "Resources/Equipment/haveTerrascopeImage.png","Resources/Equipment/haveTerrascopeImage.png", allegro);
								timeThrottleButton = new Button(xoffset + 5 * (al_get_bitmap_width(allegro->noEquipments[4]) + 1), yoffset,"Resources/Equipment/haveTimeThrottleImage.png","Resources/Equipment/haveTimeThrottleImage.png", allegro);
							}
							else { cerr << "Unable to load Dead Water Level Image" << endl; }
						}
						else { cerr << "Unable to load 4 water level Image" << endl; }
					}
					else { cerr << "Unable to load 3 water level Image" << endl; }
				}
				else { cerr << "Unable to load 2 water level Image" << endl; }
			}
			else { cerr << "Unable to load 1 water level Image" << endl; }
		}
		else { cerr << "Unable to load 0 water level Image" << endl; }
	}
}
void Character::drinkWater() {
	if (waters > 0 && waters != 6) { waters--; }
	else { waters = 6; } //I use the sixth image to show the dead Image
}
void Character::addWater(){
	if(waters < 4)
		waters++;
}
bool Character::haveWater(){
	if (waters == 6) { return false; }
	return true;
}
void Character::updateChar(ALL *allegro, int numofplayer, int x, int y) {
	if (numofplayer == 1) { al_draw_textf(allegro->font, al_map_rgb(WHITE), x, 2 * y, ALLEGRO_ALIGN_CENTRE, "Your moves Left: %d", numberOfMoves); }
	else { al_draw_textf(allegro->font, al_map_rgb(WHITE), x, 2 * y, ALLEGRO_ALIGN_CENTRE, "Partner moves Left: %d", numberOfMoves); }
	updateChar(allegro, numofplayer);
}
void Character::updateChar(ALL *allegro, int numofplayer) {
	pos charCoords = updateCoords(allegro);
	al_draw_bitmap(image, charCoords.x, charCoords.y, 0);
	//al_draw_bitmap(waterImage, allegro->screenWidth - al_get_bitmap_width(waterImage)*3/2, allegro->screenHeight / 2, 0);
	if(numofplayer == 1){
		al_draw_textf(allegro->gameFont, al_map_rgb(WHITE), allegro->screenWidth/16, allegro->screenHeight * 0.05, ALLEGRO_ALIGN_CENTRE,"%s",name);
		if (waters >= 0) { al_draw_bitmap(watersImages[waters], 0, allegro->screenHeight / 2 - al_get_bitmap_height(watersImages[waters]), 0); }
		al_draw_bitmap(adventurerImage, allegro->screenWidth / 8, allegro->screenHeight * 0.1, 0);
		//al_draw_bitmap(allegro->roles[(int)rol-48], allegro->screenWidth/8, allegro->screenHeight/8, 0);
		updateEquipments(allegro);
	}
	else if(numofplayer == 2){
		al_draw_textf(allegro->gameFont, al_map_rgb(WHITE), allegro->screenWidth/16, allegro->screenHeight * 0.55, ALLEGRO_ALIGN_CENTRE,"%s",name);
		if (waters >= 0) { al_draw_bitmap(watersImages[waters], 0, allegro->screenHeight - al_get_bitmap_height(watersImages[waters]), 0); }
		al_draw_bitmap(adventurerImage, allegro->screenWidth / 8, allegro->screenHeight * 0.6, 0);
		//al_draw_bitmap(allegro->roles[(int)rol-48], allegro->screenWidth/8, allegro->screenHeight *0.625, 0);
	}
	
}
bool Character::checkButton(EquipmentsEnum equipEnum, int mousex, int mousey, double volume){
	switch (equipEnum)
	{
	case DUNEBLAST:
		if(duneBlasterButton->checkMouse(mousex, mousey, volume))
			return true;
		else return false;
	case JETPACK:
		if(jetPackButton->checkMouse(mousex, mousey, volume))
			return true;
		else return false;
	case SOLARSHIELD:
		if(solarShieldButton->checkMouse(mousex, mousey, volume))
			return true;
		else return false;
	case TERRASCOPE:
		if(terrascopeButton->checkMouse(mousex, mousey, volume))
			return true;
		else return false;
	case SECRETWATERRESERVE:
		if(secretWaterReserveButton->checkMouse(mousex, mousey, volume))
			return true;
		else return false;
	case TIMETHROTTLE:
		if(timeThrottleButton->checkMouse(mousex, mousey, volume))
			return true;
		else return false;
	default:
		return false;
	}
}
void Character::updateEquipments(ALL* allegro) {
	//Update Equipments
	int yoffset = allegro->screenHeight * 16 / 19;
	int xoffset = allegro->screenWidth / 3;
	int i = 0;
	if (duneBlaster > 0) {
		duneBlasterButton->updateButton(allegro);
		al_draw_textf(allegro->font, al_map_rgb(BLACK), xoffset + i * (al_get_bitmap_width(allegro->noEquipments[4]) + 1), yoffset, 0, "%d", duneBlaster);
	}
	else { al_draw_bitmap(allegro->noEquipments[i], xoffset + i * (al_get_bitmap_width(allegro->noEquipments[4]) + 1), yoffset, 0); }
	i++;
	if (jetPack > 0) {
		jetPackButton->updateButton(allegro);
		al_draw_textf(allegro->font, al_map_rgb(BLACK), xoffset + i * (al_get_bitmap_width(allegro->noEquipments[4]) + 1), yoffset, 0, "%d", jetPack);
	}
	else { al_draw_bitmap(allegro->noEquipments[i], xoffset + i * (al_get_bitmap_width(allegro->noEquipments[4]) + 1), yoffset, 0); }
	i++;
	if (secretWaterReserve > 0) {
		secretWaterReserveButton->updateButton(allegro);
		al_draw_textf(allegro->font, al_map_rgb(BLACK), xoffset + i * (al_get_bitmap_width(allegro->noEquipments[0]) + 1), yoffset, 0, "%d", secretWaterReserve);
	}
	else { al_draw_bitmap(allegro->noEquipments[i], xoffset + i * (al_get_bitmap_width(allegro->noEquipments[4]) + 1), yoffset, 0); }
	i++;
	if (solarShield > 0) {
		solarShieldButton->updateButton(allegro);
		al_draw_textf(allegro->font, al_map_rgb(BLACK), xoffset + i * (al_get_bitmap_width(allegro->noEquipments[4]) + 1), yoffset, 0, "%d", solarShield);
	}
	else { al_draw_bitmap(allegro->noEquipments[i], xoffset + i * (al_get_bitmap_width(allegro->noEquipments[4]) + 1), yoffset, 0); }
	i++;
	if (terrascope > 0) {
		terrascopeButton->updateButton(allegro);
		al_draw_textf(allegro->font, al_map_rgb(BLACK), xoffset + i * (al_get_bitmap_width(allegro->noEquipments[4]) + 1), yoffset, 0, "%d", terrascope);
	}
	else { al_draw_bitmap(allegro->noEquipments[i], xoffset + i * (al_get_bitmap_width(allegro->noEquipments[4]) + 1), yoffset, 0); }
	i++;
	if (timeThrottle > 0) {
		timeThrottleButton->updateButton(allegro);
		al_draw_textf(allegro->font, al_map_rgb(BLACK), xoffset + i * (al_get_bitmap_width(allegro->noEquipments[4]) + 1), yoffset, 0, "%d", timeThrottle);
	}
	else { al_draw_bitmap(allegro->noEquipments[i], xoffset + i * (al_get_bitmap_width(allegro->noEquipments[4]) + 1), yoffset, 0); }
}

bool Character::decreseMoves() {
	if (numberOfMoves > 0) { 
		numberOfMoves--; 
		return true;
	}
	else { return false; }
}
pos Character::updateCoords(ALL *allegro) {
	int n = allegro->screenWidth / 3.0;
	int yoffset = (allegro->screenHeight - n) / 2.0;
	int xoffset = n;
	pos tempPos;
	if(image){
		int l = abs((n - al_get_bitmap_width(image) * 5) / 4);	//If the number is negative it souldn't run anyway... but at least it won't explote.
		tempPos.x = (column)*(al_get_bitmap_width(image) + l) + xoffset;
		tempPos.y = (row)*(al_get_bitmap_width(image) + l) + yoffset;
	}
	else {
		cout << "Can't update coords" << endl;
		tempPos.x = 0;
		tempPos.y = 0;
	}
	return tempPos;
}
bool Character::moveUp() {
	if (row > 0 && numberOfMoves > 0) {
		row--;
		decreseMoves();
		return true;
	}
	else { return false; }
}
bool Character::moveDown() {
	if (row < 4 && numberOfMoves > 0) {
		row++;
		decreseMoves();
		return true;
	}
	else { return false; }
}
bool Character::moveLeft() {
	if (column > 0 && numberOfMoves > 0) {
		column--;
		decreseMoves();
		return true;
	}
	else { return false; }
}
bool Character::moveRight() {
	if (column < 4 && numberOfMoves > 0) {
		column++;
		decreseMoves();
		return true;
	}
	else { return false; }
}
bool Character::removeSand() {
	if (numberOfMoves > 0) {
#ifdef DEBUG_GAME
		cout << "Remove Sand" << endl;
#endif
		decreseMoves();
		return true;
	}
	else { return false; }
}
bool Character::dig() {
	if (numberOfMoves > 0) {
#ifdef DEBUG_GAME
		cout << "Dig" << endl;
#endif
		decreseMoves();
		return true;
	}
	else { return false; }
}
bool Character::pickUpPart() {
	if (numberOfMoves > 0) {
#ifdef DEBUG_GAME
		cout << "Pick Up Part" << endl;
#endif
		decreseMoves();
		return true;
	}
	else { return false; }
}
void Character::resetNumberOfMoves() {
	numberOfMoves = 4;
}
uint Character::getCardIndex() {
	return 5 * column + row;
}
bool Character::setPos(int row, int column) {
	if (this->row != row || this->column != column) {		//if already there its no point on doing this
		//cout << "set pos" << endl;
		if (!decreseMoves()) { return false; }
		this->row = row;
		this->column = column;
		return true;
	}
	else { 
		cerr << "They wanted me to move where I already was" << endl;
		return false;
	} //Normally this should never happen so I print for it to be fixed
}
void Character::setName(char* name){
	strncpy(this->name,name,SIZEOFNAME);
}

bool Character::haveDuneBlaster(){
	if(duneBlaster > 0)
		return true;
	else return false;
}
bool Character::haveJetPack(){
	if(jetPack > 0)
		return true;
	else return false;
}
bool Character::haveWaterReserve(){
	if(secretWaterReserve > 0)
		return true;
	else return false;
}
bool Character::haveSolarShield(){
	if(solarShield > 0)
		return true;
	else return false;
}
bool Character::haveTerrascope(){
	if(terrascope > 0)
		return true;
	else return false;
}
bool Character::haveTimeThrottle(){
	if(timeThrottle > 0)
		return true;
	else return false;
}
Character::~Character(){
	al_destroy_bitmap(image);
	al_destroy_bitmap(adventurerImage);
	delete duneBlasterButton;
	delete solarShieldButton;
	delete jetPackButton;
	delete secretWaterReserveButton;
	delete terrascopeButton;
	delete timeThrottleButton;
}
void Character::playGettingCloseSound() {
	if (getClose) {
		al_play_sample(gettingCloseSound, 1, 0, 1, ALLEGRO_PLAYMODE_ONCE, NULL);
		getClose = false;
	}
}
</file>

<file path="src/ChoosePlayer.cpp">
#include "ChoosePlayer.hpp"

ChoosePlayer::ChoosePlayer(ALL *allegro) {
	initializeAllegro(allegro);
	player = 1;
	// Create all 6 characterButtons
	archeologistButton = new ArcheologistButton(0, allegro->screenHeight / 2.0, "Resources/Buttons/ArcheologistButton.png", "Resources/Buttons/SelectedArcheologistButton.png", allegro);
	explorerButton = new ExplorerButton(allegro->screenWidth / 6.0, allegro->screenHeight / 2.0, "Resources/Buttons/ExplorerButton.png", "Resources/Buttons/SelectedExplorerButton.png", allegro);
	navigatorButton = new NavigatorButton(allegro->screenWidth / 3.0, allegro->screenHeight / 2.0, "Resources/Buttons/NavigatorButton.png", "Resources/Buttons/SelectedNavigatorButton.png", allegro);
	waterCarrierButton = new WaterCarrierButton(allegro->screenWidth / 2.0, allegro->screenHeight / 2.0, "Resources/Buttons/WaterCarrierButton.png", "Resources/Buttons/SelectedWaterCarrierButton.png", allegro);
	climberButton = new ClimberButton(allegro->screenWidth * 2.0 / 3.0, allegro->screenHeight / 2.0, "Resources/Buttons/ClimberButton.png", "Resources/Buttons/SelectedClimberButton.png", allegro);
	meteorologistButton = new MeteorologistButton(allegro->screenWidth * 5.0 / 6.0, allegro->screenHeight / 2.0, "Resources/Buttons/MeteorologistButton.png", "Resources/Buttons/SelectedMeteorologistButton.png", allegro);
	
	mouse.x = allegro->screenWidth / 2.0;
	mouse.y = allegro->screenHeight / 2.0;
	redraw = true;
}
bool ChoosePlayer::eventHandler(ALL *allegro) {
	bool stillPlaying = true;
	ALLEGRO_EVENT ev;
	al_wait_for_event(allegro->events_queue, &ev);

	if (ev.type == ALLEGRO_EVENT_TIMER) {
		redraw = true;
	}
	else if (ev.type == ALLEGRO_EVENT_DISPLAY_CLOSE) {
		stillPlaying = false;
	}
	else if (ev.type == ALLEGRO_EVENT_MOUSE_AXES || ev.type == ALLEGRO_EVENT_MOUSE_ENTER_DISPLAY) {
		mouse.x = ev.mouse.x;
		mouse.y = ev.mouse.y;
		archeologistButton->checkMouse(ev.mouse.x, ev.mouse.y, allegro->volume);
		explorerButton->checkMouse(ev.mouse.x, ev.mouse.y, allegro->volume);
		navigatorButton->checkMouse(ev.mouse.x, ev.mouse.y, allegro->volume);
		meteorologistButton->checkMouse(ev.mouse.x, ev.mouse.y, allegro->volume);
		climberButton->checkMouse(ev.mouse.x, ev.mouse.y, allegro->volume);
		waterCarrierButton->checkMouse(ev.mouse.x, ev.mouse.y, allegro->volume);
	}
	else if (ev.type == ALLEGRO_EVENT_MOUSE_BUTTON_UP) {
		//If there whas a selected character, then return true, else return false
		if (archeologistButton->buttonAction(ev.mouse.x, ev.mouse.y)) {
			if (player == 1) {
				rol1 = ARCHEOLOGIST_ROLE;
				player = 2;
				return true;
			}
			else if (rol1 != ARCHEOLOGIST_ROLE) {	//If im player 2, I must check player 1 is not the same character.
				rol2 = ARCHEOLOGIST_ROLE;
				return false;
			}
			return true;		//Player 1 is already this type
		}
		if (explorerButton->buttonAction(ev.mouse.x, ev.mouse.y)) { 
			if (player == 1) {
				rol1 = EXPLORER_ROLE;
				player = 2;
				return true;
			}
			else if (rol1 != EXPLORER_ROLE) {	//If im player 2, I must check player 1 is not the same character.
				rol2 = EXPLORER_ROLE;
				return false;
			}
			return true;		//Player 1 is already this type
		}
		if (navigatorButton->buttonAction(ev.mouse.x, ev.mouse.y)) { 
			if (player == 1) {
				rol1 = NAVIGATOR_ROLE;
				player = 2;
				return true;
			}
			else if (rol1 != NAVIGATOR_ROLE) {	//If im player 2, I must check player 1 is not the same character.
				rol2 = NAVIGATOR_ROLE;
				return false;
			}
			return true;		//Player 1 is already this type	 
		}
		if (meteorologistButton->buttonAction(ev.mouse.x, ev.mouse.y)) { 
			if (player == 1) {
				rol1 = METEOROLOGIST_ROLE;
				player = 2;
				return true;
			}
			else if (rol1 != METEOROLOGIST_ROLE) {	//If im player 2, I must check player 1 is not the same character.
				rol2 = METEOROLOGIST_ROLE;
				return false;
			}
			return true;		//Player 1 is already this type
		}
		if (climberButton->buttonAction(ev.mouse.x, ev.mouse.y)) { 
			if (player == 1) {
				rol1 = CLIMBER_ROLE;
				player = 2;
				return true;
			}
			else if (rol1 != CLIMBER_ROLE) {	//If im player 2, I must check player 1 is not the same character.
				rol2 = CLIMBER_ROLE;
				return false;
			}
			return true;		//Player 1 is already this type
		}
		if (waterCarrierButton->buttonAction(ev.mouse.x, ev.mouse.y)) {
			if (player == 1) {
				rol1 = WATER_CARRIER_ROLE;
				player = 2;
				return true;
			}
			else if (rol1 != WATER_CARRIER_ROLE) {	//If im player 2, I must check player 1 is not the same character.
				rol2 = WATER_CARRIER_ROLE;
				return false;
			}
			return true;		//Player 1 is already this type 
		}
		return true;
	}

	if (redraw && al_is_event_queue_empty(allegro->events_queue)) {
		updateScreen(allegro);
	}
	return stillPlaying;
}
void ChoosePlayer::updateScreen(ALL* allegro) {
	redraw = false;
	al_clear_to_color(al_map_rgb(0, 0, 0));
	al_draw_bitmap(allegro->fondo, 0, 0, 0);
	//Texts
	if (player == 1) { al_draw_text(allegro->gameFont, al_map_rgb(WHITE), 0, 0, ALLEGRO_ALIGN_LEFT, "Choose your adventurer: "); }
	else { al_draw_text(allegro->gameFont, al_map_rgb(WHITE), 0, 0, ALLEGRO_ALIGN_LEFT, "Choose your partner: "); }
	//Player Buttons
	archeologistButton->updateButton(allegro);
	explorerButton->updateButton(allegro);
	navigatorButton->updateButton(allegro);
	meteorologistButton->updateButton(allegro);
	climberButton->updateButton(allegro);
	waterCarrierButton->updateButton(allegro);
	if (archeologistButton->checkMouse(mouse.x, mouse.y, allegro->volume)) {
		al_draw_text(allegro->gameFont, al_map_rgb(WHITE), allegro->screenWidth / 2, allegro->screenHeight * 0.1, ALLEGRO_ALIGN_CENTRE, "Archeologist");
		al_draw_bitmap(allegro->rectangleImage[0], (allegro->screenWidth - al_get_bitmap_width(allegro->rectangleImage[0])) / 2, allegro->screenHeight * 16 / 20, 0);
	}
	if (climberButton->checkMouse(mouse.x, mouse.y, allegro->volume)) {
		al_draw_text(allegro->gameFont, al_map_rgb(WHITE), allegro->screenWidth / 2, allegro->screenHeight * 0.1, ALLEGRO_ALIGN_CENTRE, "Climber");
		al_draw_bitmap(allegro->rectangleImage[1], (allegro->screenWidth - al_get_bitmap_width(allegro->rectangleImage[1])) / 2, allegro->screenHeight * 16 / 20, 0);
	}
	if (explorerButton->checkMouse(mouse.x, mouse.y, allegro->volume)) {
		al_draw_text(allegro->gameFont, al_map_rgb(WHITE), allegro->screenWidth / 2, allegro->screenHeight * 0.1, ALLEGRO_ALIGN_CENTRE, "Explorer");
		al_draw_bitmap(allegro->rectangleImage[2], (allegro->screenWidth - al_get_bitmap_width(allegro->rectangleImage[2])) / 2, allegro->screenHeight * 16 / 20, 0);
	}
	if (navigatorButton->checkMouse(mouse.x, mouse.y, allegro->volume)) {
		al_draw_text(allegro->gameFont, al_map_rgb(WHITE), allegro->screenWidth / 2, allegro->screenHeight * 0.1, ALLEGRO_ALIGN_CENTRE, "Navigator");
		al_draw_bitmap(allegro->rectangleImage[3], (allegro->screenWidth - al_get_bitmap_width(allegro->rectangleImage[3])) / 2, allegro->screenHeight * 16 / 20, 0);
	}
	if (waterCarrierButton->checkMouse(mouse.x, mouse.y, allegro->volume)) {
		al_draw_text(allegro->gameFont, al_map_rgb(WHITE), allegro->screenWidth / 2, allegro->screenHeight * 0.1, ALLEGRO_ALIGN_CENTRE, "Water Carrier");
		al_draw_bitmap(allegro->rectangleImage[4], (allegro->screenWidth - al_get_bitmap_width(allegro->rectangleImage[4])) / 2, allegro->screenHeight * 16 / 20, 0);
	}
	if (meteorologistButton->checkMouse(mouse.x, mouse.y, allegro->volume)) {
		al_draw_text(allegro->gameFont, al_map_rgb(WHITE), allegro->screenWidth / 2, allegro->screenHeight * 0.1, ALLEGRO_ALIGN_CENTRE, "Meteorologist");
		al_draw_bitmap(allegro->rectangleImage[5], (allegro->screenWidth - al_get_bitmap_width(allegro->rectangleImage[5])) / 2, allegro->screenHeight * 16 / 20, 0);
	}
	al_flip_display();
}

bool ChoosePlayer::initializeAllegro(ALL* allegro) {
	bool state = true;
	//! Display
	//! CODE TO FULLSCREEN
#ifndef WINDOWED
	ALLEGRO_DISPLAY_MODE   disp_data;
	al_get_display_mode(al_get_num_display_modes() - 1, &disp_data);
	al_set_new_display_flags(ALLEGRO_FULLSCREEN);
	allegro->display = al_create_display(disp_data.width, disp_data.height);
	allegro->screenWidth = disp_data.width;
	allegro->screenHeight = disp_data.height;
#endif
	//! Code for windowed mode
#ifdef WINDOWED
	if (state) {
		state = false;
		if (allegro->display = al_create_display(SCREEN_X, SCREEN_Y)) {
			allegro->screenWidth = SCREEN_X;
			allegro->screenHeight = SCREEN_Y;
			//al_destroy_display(allegro->startMenuDisplay);
			al_register_event_source(allegro->events_queue, al_get_display_event_source(allegro->display));
			al_set_window_title(allegro->display, "Choose Character");
			state = true;
		}
		else { cout << "Failed to create Display" << endl; }
	}
#endif
	//Load Images
	if (state) {
		state = false;
		al_set_target_backbuffer(allegro->display);
		if (allegro->fondo = al_load_bitmap_resized("Resources/Scenario.jpg", allegro)) {
			if (allegro->mouse = al_load_bitmap_resized("Resources/mouse.png", allegro)) {
				state = true;
			}
			else { cout << "Failed to load mouse.png" << endl; }
		}
		else { cout << "Failed to load scenario.png" << endl; }
	}

	//Audio
	if (allegro->backgroundMusic != nullptr) {
		al_play_sample(allegro->backgroundMusic, 1, 0.0, 1.0, ALLEGRO_PLAYMODE_LOOP, &allegro->backgroundMusicID);
	}

	//Mouse Initialization
	if (allegro->mouse = al_load_bitmap_resized("Resources/mouse.png", allegro)) {
		if (allegro->cursor = al_create_mouse_cursor(allegro->mouse, 0, 0)) {
			al_set_mouse_cursor(allegro->display, allegro->cursor);
		}
	}
	al_clear_to_color(al_map_rgb(0, 0, 0));
	al_draw_bitmap(allegro->fondo, 0, 0, 0);
	al_flip_display();

	return state;
}

ChoosePlayer::~ChoosePlayer() {
	delete archeologistButton;
	delete explorerButton;
	delete navigatorButton;
	delete waterCarrierButton;
	delete meteorologistButton;
	delete climberButton;
}
</file>

<file path="src/ClimberButton.cpp">
#include "ClimberButton.hpp"

ClimberButton::ClimberButton() {}
ClimberButton::ClimberButton(int x0, int y0, const char *imageName, const char * nonSelectedImageName, ALL* allegro) : Button(x0, y0, imageName, nonSelectedImageName, allegro) {}

bool ClimberButton::buttonAction(int x, int y) {
	if (mouseOverButton) {
		cout << "Click on Climber Button" << endl;
		al_play_sample(selectCharSample, 1.0, 0.0, 1.0, ALLEGRO_PLAYMODE_ONCE, NULL);
		return true;
	}
	return false;
}
</file>

<file path="src/ClimberCharacter.cpp">
#include "ClimberCharacter.hpp"

ClimberCharacter::ClimberCharacter(int rowSet, int columnSet, Container info, ALL* allegro) : Character(rowSet, columnSet, info, allegro) {
	if(adventurerImage = al_load_bitmap_resized("Resources/Players/climberImage.png", allegro)){
		if (image = al_load_bitmap_resized("Resources/Players/Pawns/ClimberPawnImage.png", allegro)) {
			if (selectedImage = al_load_bitmap_resized("Resources/Players/ClimberButton/selectedImage.png", allegro)) {
				if(takeWithMeButton = new Button(allegro->screenWidth / 8, allegro->screenHeight / 2, "Resources/Players/ClimberButton/noMouseOverCheckBoxImage.png", "Resources/Players/ClimberButton/mouseOverCheckBoxImage.png", allegro)) {
					takeWithMe = false;
				} else { cerr << "Failed to load takeWithMeButton" << endl;}
			} else { cerr << "Failed to init selectedImage" << endl;}
		} else { cerr << "Failed to load Climber Pawn Image" << endl; }
	} else { cerr << "Failed to load climberImage.png" << endl; }
	//Sounds
	if (gettingCloseSound = al_load_sample("Resources/Sounds/MustBeGettingClose(Boy).wav")) {}
	else { cerr << "Failed to load Must be getting close Sound" << endl; }
}
ClimberCharacter::~ClimberCharacter(){
	al_destroy_bitmap(climberImage);
	al_destroy_bitmap(selectedImage);
	al_destroy_bitmap(unableToTakeCharacterWithMe);
	al_destroy_sample(gettingCloseSound);
	for (int i = 0; i < MAXOFWATERS; i++) { al_destroy_bitmap(watersImage[i]); }
	delete takeWithMeButton;
}
void ClimberCharacter::updateClimber(ALL* allegro) {
	if (takeWithMe) {
		al_draw_bitmap(selectedImage, allegro->screenWidth / 8, (allegro->screenHeight- al_get_bitmap_height(selectedImage)) / 2, 0); //Here, X and Y are the same as in the constructor of takeWithMeButton
	}
	takeWithMeButton->updateButton(allegro);
}
void ClimberCharacter::clickOnButton(int x, int y, double volume) {
	if (takeWithMeButton->checkMouse(x, y, volume)) {
		toogleTakeWithMe();
		cout << "Toogle take with me button to " << getTakeWithMe() << endl;
	}
}
</file>

<file path="src/ExplorerButton.cpp">
#include "ExplorerButton.hpp"

ExplorerButton::ExplorerButton() {}
ExplorerButton::ExplorerButton(int x0, int y0, const char *imageName, const char * nonSelectedImageName, ALL* allegro) : Button(x0, y0, imageName, nonSelectedImageName, allegro) {}
bool ExplorerButton::buttonAction(int x, int y) {
	if (mouseOverButton) {
		cout << "Click on Explorer Button" << endl;
		al_play_sample(selectCharSample, 1.0, 0.0, 1.0, ALLEGRO_PLAYMODE_ONCE, NULL);
		return true;
	}
	return false;
}
</file>

<file path="src/ExplorerCharacter.cpp">
#include "ExplorerCharacter.hpp"

ExplorerCharacter::ExplorerCharacter(int rowSet, int columnSet, Container info, ALL *allegro) : Character(rowSet, columnSet, info, allegro){
	if(adventurerImage = al_load_bitmap_resized("Resources/Players/explorerImage.png", allegro)){
		if (image = al_load_bitmap_resized("Resources/Players/Pawns/ExplorerPawnImage.png", allegro)) {
		}
		else { cout << "Failed to load Explorer Pawn Image" << endl; }
	}
	else { cout << "Failed to load explorerImage.png" << endl; }
	//Sounds
	if (gettingCloseSound = al_load_sample("Resources/Sounds/MustBeGettingClose(Boy).wav")) {}
	else { cout << "Failed to load Must be getting close Sound" << endl; }
}
void ExplorerCharacter::moveUpRightDiagonally() {
	if (column < 4 && row > 0 && numberOfMoves > 0) {
		column++;
		row--;
		decreseMoves();
	}
}
void ExplorerCharacter::moveUpLeftDiagonally() {
	if (column > 0 && row > 0 && numberOfMoves > 0) {
		column--;
		row--;
		decreseMoves();
	}
}
void ExplorerCharacter::moveDownRightDiagonally() {
	if (column < 4 && row < 4 && numberOfMoves > 0) {
		column++;
		row++;
		decreseMoves();
	}
}
void ExplorerCharacter::moveDownLeftDiagonally() {
	if (column > 0 && row < 4 && numberOfMoves > 0) {
		column--;
		row++;
		decreseMoves();
	}
}
void ExplorerCharacter::useDuneBlasterDiagonally(){
	//TODO: movimiento especial, hay que hacerlo todo, lo declaro ahora como para que estï¿½.
}
ExplorerCharacter::~ExplorerCharacter(){
	for (int i = 0; i < MAXOFWATERS; i++) { al_destroy_bitmap(watersImage[i]); }
	al_destroy_bitmap(explorerImage);
	al_destroy_sample(gettingCloseSound);
}
</file>

<file path="src/fsmInit.cpp">
#include "fsmInit.h"

FSMI::FSMI() {
    exit = false;    //Para que en principio entre al while
    state = IDLE;    //Estado inicial
    turnsort();
    nameready = false;    //Todavia sin nombre
}
void FSMI::turnsort() {
    turn = rand() % 2 +
           CLIENT;    // Turno aleatorio.  El define "CLIENT" es el offset del numero que se genera (0/1 + CLIENT)
}
void FSMI::start(ALL *allegro) {
    drawStartMenu(allegro);
    net.initializeNet(allegro);
    pck.connection = net.connection;

    // Step 1: Ask for Name of both...
    if (net.typeconn == SERVER) {    // Dependiendo si se empieza como server o como client:
        turn = CLIENT;
        state = ASK4NAME;
    } else {
        turn = SERVER;
        state = W4NAME;
    }
    while (state != END) {  // State machine of the communication.
        switch (state) {
            case ASK4NAME:
                pck.name();
                pck.sendPack();
                changestate(W4STRING);
                break;
            case W4NAME:
#ifdef __linux__
                usleep(300000);
#elif _WIN32
                Sleep(300);
#endif
                data = pck.receivePack();
                if (data.ID == NAME)
                    changestate(SENDNAME);
                break;
            case SENDNAME:
                ///HICE CAMBIOS ACA QUE NO ME GUSTARON.... VER!!!
                char *a;
                printAllegro(allegro, "Please, enter your name:");
                a = getcharAllegro(allegro, 8, HEIGHT * allegro->screenHeight / MAXRESOLUTION_Y / 2);

                pck.nameis(a);
                Informacion.addName(a);
                pck.sendPack();
                changestate(W4ACK);
                break;
            case W4STRING:
                printAllegro(allegro, "Waiting for your friend's name...");
#ifdef __linux__
                usleep(300000);
#elif _WIN32
                Sleep(300);
#endif
                data = pck.receivePack();
                Informacion.addFriendName(data.name);
                if (data.ID == NAME_IS) {
                    printAllegro(allegro, "Your friend's name is:  ");
#ifdef __linux__
                    usleep(1000000);
#elif _WIN32
                    Sleep(1000);
#endif
                    printAllegro(allegro, data.name);
#ifdef __linux__
                    usleep(1000000);
#elif _WIN32
                    Sleep(1000);
#endif
                    changestate(SENDACK);
                }
                break;
            case SENDACK:
                pck.ack();
                pck.sendPack();
                switch (prevstate) {
                    case W4STRING:
                        if (nameready == false) {
                            changestate(W4NAME);
                            nameready = true;
                        } else {
                            if (net.typeconn == CLIENT)
                                changestate(W4STARTINFO);
                            else
                                changestate(STARTINFO);
                        }
                        break;
                    case W4STARTINFO:
                        pck.ack();
                        pck.sendPack();
                        state = W4TURN;
                        break;
                }
            case W4ACK:
#ifdef __linux__
                usleep(300000);
#elif _WIN32
                Sleep(300);
#endif
                data = pck.receivePack();
                if (data.ID == ACK) {
                    switch (prevstate) {
                        case SENDNAME:
                            if (!nameready) {
                                changestate(ASK4NAME);
                                nameready = true;
                            } else if (net.typeconn == CLIENT)
                                changestate(W4STARTINFO);
                            else
                                changestate(STARTINFO);
                            break;
                        case STARTINFO:
                            changestate(TURN);
                            break;
                        case TURN:
                            changestate(END);
                            break;

                    }
                }
                break;
            case W4STARTINFO:
                data = pck.receivePack();       // Recibe
                Informacion.addInfo(data);      // Guardo informacion: tiles, roles, turno
                if (data.ID == START_INFO)
                    changestate(SENDACK);
                break;
            case STARTINFO:
                data = pck.startinfo(allegro);    // Here I use Choose Player !!!
                Informacion.addInfo(data);    //Guarda
                pck.sendPack();
                changestate(W4ACK);
                break;
            case TURN:  // Choose who start...
                if (turn == CLIENT) {
                    pck.youstart();
                    printAllegro(allegro, "You start");
                    Informacion.myTurn = I_START;
                } else {
                    pck.istart();
                    printAllegro(allegro, "Your friend starts");
                    Informacion.myTurn = YOU_START;
                }
                pck.sendPack();
                changestate(W4ACK);
                break;
            case W4TURN:
#ifdef __linux__
                usleep(300000);
#elif _WIN32
                Sleep(300);
#endif
                data = pck.receivePack();               //Recibo
                Informacion.myTurn = data.myTurn;       //Guardoo
                if (data.ID == I_START)
                    printAllegro(allegro, "You start");
                else
                    printAllegro(allegro, "Your friend starts");
                pck.ack();
                pck.sendPack();
                changestate(END);
                break;
            case END:
                //al_destroy_display(allegro->startMenuDisplay);
                return;
        }
    }
}

void FSMI::restart(ALL *allegro) {
    if (net.typeconn == SERVER) {
        data = pck.startinfo(allegro);
        Informacion.addInfo(data);
        pck.sendPack();
        pck.waitForAck(allegro);
    } else {
        do {
            data = pck.receivePack();
            pck.cleanBuffer();
        } while (data.ID != START_INFO);
        Informacion.addInfo(data);
        pck.ack();
        pck.sendPack();
    }
}
void FSMI::checkdata(void) {
    cout << "Turn:" << Informacion.myTurn << endl;
    cout << "Rol:" << Informacion.myRol << endl;
    cout << "Name:" << Informacion.name << endl;
    cout << "My friend's name is:" << Informacion.friendName << endl;
    print(Informacion);
}
Container FSMI::getInfo(void) {
    return Informacion;
}
void FSMI::print(Container ex) {
    for (int i = 0, k = 0; i < 5; i++) {
        for (int j = 0; j < 5; j++, k++) {
            cout << ex.tiles[k] << ' ';
        }
        cout << endl;
    }
}
void FSMI::changestate(char newstate) {
    prevstate = state;
    state = newstate;
}
</file>

<file path="src/Game.cpp">
#include "Game.hpp"
#include <cstdlib>
#include <array>
//Used to shuffle
#include <random>
#include <chrono>
#include <include/Game.hpp>

#define DRAW_CARD_SLEEP 600000

pos Game::getSpot(int row, int column, ALL *allegro, ALLEGRO_BITMAP *image) {
    /* returns the position (in pixels) according to the row and column.
	it uses the size of the image to make it flexible to diferent sizes of bitmaps.
	allegro is needed to know the size of the screen
	*/
    int n = allegro->screenWidth / 3.0;
    int yoffset = (allegro->screenHeight - n) / 2.0;
    int xoffset = n;
    pos tempPos;
    int l = abs((n - al_get_bitmap_width(image) * 5) /
                4);    //If the number is negative it souldn't run enyway... but at least it won't explote.
    tempPos.x = (column) * (al_get_bitmap_width(image) + l) + xoffset;
    tempPos.y = (row) * (al_get_bitmap_width(image) + l) + yoffset;
    return tempPos;
}

//! Decks Swap/Shuffle Methods
void Game::shuffleTiles() {
    /* This function automatically shuffles the tile Deck*/
    uint seed = static_cast<uint>(chrono::system_clock::now().time_since_epoch().count());    //Magic, its to make the suffle work, something about using a counter to set the value.
    shuffle(tilesDeck.begin(), tilesDeck.end(), default_random_engine(seed));

    for (uint i = 0; i < tilesDeck.size(); i++) { //Here I set the storm in the middle
        if (tilesDeck[i]->gettileType() == STORM) { swapTiles(i, 12); }
    }
}
void Game::swapTiles(int i, int j) {
    /* swap tile i with j */
    swap(tilesDeck[i], tilesDeck[j]);
}
void Game::swapStormCards(int i, int j) {
    /* swap storm card i with storm card j */
    swap(stormCardsDeck[i], stormCardsDeck[j]);
}
//! Perform Actions
void Game::performTileAction(TilesEnum tileEnum, int index, ALL *allegro) {
    /* When the tile gets excavated, this function is runned for it to perform the action of this particular tile
	Thats why an tileEnum must be passed to tell the function which tile was turned up.
	*/
    switch (tileEnum) {
        case WATER:
            al_play_sample(allegro->waterSound, allegro->volume, 0, 1, ALLEGRO_PLAYMODE_ONCE, NULL);
            if (character->getCardIndex() == index) {
                character->addWater();
                character->addWater();
            }
            if (character2->getCardIndex() == index) {
                character2->addWater();
                character2->addWater();
            }
            break;
        case GEAR1:
            drawEquipment(info.equipment[equipIndex]);
            break;
        case GEAR2:
            drawEquipment(info.equipment[equipIndex]);
            break;
        case GEAR3:
            drawEquipment(info.equipment[equipIndex]);
            break;
        case GEAR4:
            drawEquipment(info.equipment[equipIndex]);
            break;
        case GEAR5:
            drawEquipment(info.equipment[equipIndex]);
            break;
        case GEAR6:
            drawEquipment(info.equipment[equipIndex]);
            break;
        case GEAR7:
            drawEquipment(info.equipment[equipIndex]);
            break;
        case GEAR8:
            drawEquipment(info.equipment[equipIndex]);
            break;
        case PROPELLERCOLUMN:
            propeller->findColum(index / 5, allegro);
            break;
        case PROPELLERROW:
            propeller->findRow(index % 5, allegro);
            break;
        case SOLARCRYSCOLUMN:
            solarCrystal->findColum(index / 5, allegro);
            break;
        case SOLARCRYSROW:
            solarCrystal->findRow(index % 5, allegro);
            break;
        case NAVIGATIONCOLUMN:
            navigationDeck->findColum(index / 5, allegro);
            break;
        case NAVIGATIONROW:
            navigationDeck->findRow(index % 5, allegro);
            break;
        case ENGINECOLUMN:
            engine->findColum(index / 5, allegro);
            break;
        case ENGINEROW:
            engine->findRow(index % 5, allegro);
            break;
        case TUNNEL:
            drawEquipment(info.equipment[equipIndex]);
            break;
    }
}

void Game::performStormCardAction(ALL *allegro, StormCardsEnum cardEnum) {
    /* Similar to performTileAction. Gets the enum of the storm card and acts accordingly. */
    int i;
    switch (cardEnum) {
        case RIGHT3:
#ifdef DEBUG_GAME
            cout << "Right" << endl;
#endif
            i = 0;
            while (tilesDeck[i]->gettileType() != STORM) { i++; }
            if (i < 20) {
                if (character->getCardIndex() == i + 5) {
                    character->moveLeft();
                    character->resetNumberOfMoves();
                }
                if (character2->getCardIndex() == i + 5) {
                    character2->moveLeft();
                    character2->resetNumberOfMoves();
                }
                if (propeller->getCardIndex() == i + 5) { propeller->setCardIndex(i, allegro); }
                if (engine->getCardIndex() == i + 5) { engine->setCardIndex(i, allegro); }
                if (solarCrystal->getCardIndex() == i + 5) { solarCrystal->setCardIndex(i, allegro); }
                if (navigationDeck->getCardIndex() == i + 5) { navigationDeck->setCardIndex(i, allegro); }
                swapTiles(i, i + 5);
                tilesDeck[i]->increaseSand();
                SandMarkersLeft--;
            }
            updateScreen(allegro);
            stormCardsDeck[0]->showImage(allegro);
            usleep(DRAW_CARD_SLEEP);
        case RIGHT2:
#ifdef DEBUG_GAME
            cout << "Right" << endl;
#endif
            i = 0;
            while (tilesDeck[i]->gettileType() != STORM) { i++; }
            if (i < 20) {
                if (character->getCardIndex() == i + 5) {
                    character->moveLeft();
                    character->resetNumberOfMoves();
                }
                if (character2->getCardIndex() == i + 5) {
                    character2->moveLeft();
                    character2->resetNumberOfMoves();
                }
                if (propeller->getCardIndex() == i + 5) { propeller->setCardIndex(i, allegro); }
                if (engine->getCardIndex() == i + 5) { engine->setCardIndex(i, allegro); }
                if (solarCrystal->getCardIndex() == i + 5) { solarCrystal->setCardIndex(i, allegro); }
                if (navigationDeck->getCardIndex() == i + 5) { navigationDeck->setCardIndex(i, allegro); }
                swapTiles(i,
                          i + 5);            //NO need to use break right now, I make the iteration by not puting break
                tilesDeck[i]->increaseSand();
                SandMarkersLeft--;
            }
            updateScreen(allegro);
            stormCardsDeck[0]->showImage(allegro);
            usleep(DRAW_CARD_SLEEP);
        case RIGHT1:
#ifdef DEBUG_GAME
            cout << "Right" << endl;
#endif
            i = 0;
            while (tilesDeck[i]->gettileType() != STORM) { i++; }
            if (i < 20) {
                if (character->getCardIndex() == i + 5) {
                    character->moveLeft();
                    character->resetNumberOfMoves();
                }
                if (character2->getCardIndex() == i + 5) {
                    character2->moveLeft();
                    character2->resetNumberOfMoves();
                }
                if (propeller->getCardIndex() == i + 5) { propeller->setCardIndex(i, allegro); }
                if (engine->getCardIndex() == i + 5) { engine->setCardIndex(i, allegro); }
                if (solarCrystal->getCardIndex() == i + 5) { solarCrystal->setCardIndex(i, allegro); }
                if (navigationDeck->getCardIndex() == i + 5) { navigationDeck->setCardIndex(i, allegro); }
                swapTiles(i, i + 5);
                tilesDeck[i]->increaseSand();
                SandMarkersLeft--;
            }
            updateScreen(allegro);
            stormCardsDeck[0]->showImage(allegro);
            usleep(DRAW_CARD_SLEEP);
            break;
        case UP3:
#ifdef DEBUG_GAME
            cout << "Up" << endl;
#endif
            i = 0;
            while (tilesDeck[i]->gettileType() != STORM) { i++; }
            if (i % 5 != 0) {
                if (character->getCardIndex() == i - 1) {
                    character->moveDown();
                    character->resetNumberOfMoves();
                }
                if (character2->getCardIndex() == i - 1) {
                    character2->moveDown();
                    character2->resetNumberOfMoves();
                }
                if (propeller->getCardIndex() == i - 1) { propeller->setCardIndex(i, allegro); }
                if (engine->getCardIndex() == i - 1) { engine->setCardIndex(i, allegro); }
                if (solarCrystal->getCardIndex() == i - 1) { solarCrystal->setCardIndex(i, allegro); }
                if (navigationDeck->getCardIndex() == i - 1) { navigationDeck->setCardIndex(i, allegro); }
                swapTiles(i, i - 1);
                tilesDeck[i]->increaseSand();
                SandMarkersLeft--;
            }
            updateScreen(allegro);
            stormCardsDeck[0]->showImage(allegro);
            usleep(DRAW_CARD_SLEEP);
        case UP2:
#ifdef DEBUG_GAME
            cout << "Up" << endl;
#endif
            i = 0;
            while (tilesDeck[i]->gettileType() != STORM) { i++; }
            if (i % 5 != 0) {
                if (character->getCardIndex() == i - 1) {
                    character->moveDown();
                    character->resetNumberOfMoves();
                }
                if (character2->getCardIndex() == i - 1) {
                    character2->moveDown();
                    character2->resetNumberOfMoves();
                }
                if (propeller->getCardIndex() == i - 1) { propeller->setCardIndex(i, allegro); }
                if (engine->getCardIndex() == i - 1) { engine->setCardIndex(i, allegro); }
                if (solarCrystal->getCardIndex() == i - 1) { solarCrystal->setCardIndex(i, allegro); }
                if (navigationDeck->getCardIndex() == i - 1) { navigationDeck->setCardIndex(i, allegro); }
                swapTiles(i, i - 1);
                tilesDeck[i]->increaseSand();
                SandMarkersLeft--;
            }
            updateScreen(allegro);
            stormCardsDeck[0]->showImage(allegro);
            usleep(DRAW_CARD_SLEEP);
        case UP1:
#ifdef DEBUG_GAME
            cout << "Up" << endl;
#endif
            i = 0;
            while (tilesDeck[i]->gettileType() != STORM) { i++; }        //Search for the storm
            if (i % 5 != 0) {
                if (character->getCardIndex() == i - 1) {
                    character->moveDown();
                    character->resetNumberOfMoves();
                }
                if (character2->getCardIndex() == i - 1) {
                    character2->moveDown();
                    character2->resetNumberOfMoves();
                }
                if (propeller->getCardIndex() == i - 1) { propeller->setCardIndex(i, allegro); }
                if (engine->getCardIndex() == i - 1) { engine->setCardIndex(i, allegro); }
                if (solarCrystal->getCardIndex() == i - 1) { solarCrystal->setCardIndex(i, allegro); }
                if (navigationDeck->getCardIndex() == i - 1) { navigationDeck->setCardIndex(i, allegro); }
                swapTiles(i, i - 1);
                tilesDeck[i]->increaseSand();
                SandMarkersLeft--;
            }
            updateScreen(allegro);
            stormCardsDeck[0]->showImage(allegro);
            usleep(DRAW_CARD_SLEEP);
            break;
        case LEFT3:
#ifdef DEBUG_GAME
            cout << "Left" << endl;
#endif
            i = 0;
            while (tilesDeck[i]->gettileType() != STORM) { i++; }
            if (i > 4) {
                if (character->getCardIndex() == i - 5) {
                    character->moveRight();
                    character->resetNumberOfMoves();
                }
                if (character2->getCardIndex() == i - 5) {
                    character2->moveRight();
                    character2->resetNumberOfMoves();
                }
                if (propeller->getCardIndex() == i - 5) { propeller->setCardIndex(i, allegro); }
                if (engine->getCardIndex() == i - 5) { engine->setCardIndex(i, allegro); }
                if (solarCrystal->getCardIndex() == i - 5) { solarCrystal->setCardIndex(i, allegro); }
                if (navigationDeck->getCardIndex() == i - 5) { navigationDeck->setCardIndex(i, allegro); }
                swapTiles(i, i - 5);
                tilesDeck[i]->increaseSand();
                SandMarkersLeft--;
            }
            updateScreen(allegro);
            stormCardsDeck[0]->showImage(allegro);
            usleep(DRAW_CARD_SLEEP);
        case LEFT2:
#ifdef DEBUG_GAME
            cout << "Left" << endl;
#endif
            i = 0;
            while (tilesDeck[i]->gettileType() != STORM) { i++; }
            if (i > 4) {
                if (character->getCardIndex() == i - 5) {
                    character->moveRight();
                    character->resetNumberOfMoves();
                }
                if (character2->getCardIndex() == i - 5) {
                    character2->moveRight();
                    character2->resetNumberOfMoves();
                }
                if (propeller->getCardIndex() == i - 5) { propeller->setCardIndex(i, allegro); }
                if (engine->getCardIndex() == i - 5) { engine->setCardIndex(i, allegro); }
                if (solarCrystal->getCardIndex() == i - 5) { solarCrystal->setCardIndex(i, allegro); }
                if (navigationDeck->getCardIndex() == i - 5) { navigationDeck->setCardIndex(i, allegro); }
                swapTiles(i, i - 5);
                tilesDeck[i]->increaseSand();
                SandMarkersLeft--;
            }
            updateScreen(allegro);
            stormCardsDeck[0]->showImage(allegro);
            usleep(DRAW_CARD_SLEEP);
        case LEFT1:
#ifdef DEBUG_GAME
            cout << "Left" << endl;
#endif
            i = 0;
            while (tilesDeck[i]->gettileType() != STORM) { i++; }
            if (i > 4) {
                if (character->getCardIndex() == i - 5) {
                    character->moveRight();
                    character->resetNumberOfMoves();
                }
                if (character2->getCardIndex() == i - 5) {
                    character2->moveRight();
                    character2->resetNumberOfMoves();
                }
                if (propeller->getCardIndex() == i - 5) { propeller->setCardIndex(i, allegro); }
                if (engine->getCardIndex() == i - 5) { engine->setCardIndex(i, allegro); }
                if (solarCrystal->getCardIndex() == i - 5) { solarCrystal->setCardIndex(i, allegro); }
                if (navigationDeck->getCardIndex() == i - 5) { navigationDeck->setCardIndex(i, allegro); }
                swapTiles(i, i - 5);
                tilesDeck[i]->increaseSand();
                SandMarkersLeft--;
            }
            updateScreen(allegro);
            stormCardsDeck[0]->showImage(allegro);
            usleep(DRAW_CARD_SLEEP);
            break;
        case DOWN3:
#ifdef DEBUG_GAME
            cout << "Down" << endl;
#endif
            i = 0;
            while (tilesDeck[i]->gettileType() != STORM) { i++; }
            if (i % 5 < 4) {
                if (character->getCardIndex() == i + 1) {
                    character->moveUp();
                    character->resetNumberOfMoves();
                }
                if (character2->getCardIndex() == i + 1) {
                    character2->moveUp();
                    character2->resetNumberOfMoves();
                }
                if (propeller->getCardIndex() == i + 1) { propeller->setCardIndex(i, allegro); }
                if (engine->getCardIndex() == i + 1) { engine->setCardIndex(i, allegro); }
                if (solarCrystal->getCardIndex() == i + 1) { solarCrystal->setCardIndex(i, allegro); }
                if (navigationDeck->getCardIndex() == i + 1) { navigationDeck->setCardIndex(i, allegro); }
                swapTiles(i, i + 1);
                tilesDeck[i]->increaseSand();
                SandMarkersLeft--;
            }
            updateScreen(allegro);
            stormCardsDeck[0]->showImage(allegro);
            usleep(DRAW_CARD_SLEEP);
        case DOWN2:
#ifdef DEBUG_GAME
            cout << "Down" << endl;
#endif
            i = 0;
            while (tilesDeck[i]->gettileType() != STORM) { i++; }
            if (i % 5 < 4) {
                if (character->getCardIndex() == i + 1) {
                    character->moveUp();
                    character->resetNumberOfMoves();
                }
                if (character2->getCardIndex() == i + 1) {
                    character2->moveUp();
                    character2->resetNumberOfMoves();
                }
                if (propeller->getCardIndex() == i + 1) { propeller->setCardIndex(i, allegro); }
                if (engine->getCardIndex() == i + 1) { engine->setCardIndex(i, allegro); }
                if (solarCrystal->getCardIndex() == i + 1) { solarCrystal->setCardIndex(i, allegro); }
                if (navigationDeck->getCardIndex() == i + 1) { navigationDeck->setCardIndex(i, allegro); }
                swapTiles(i, i + 1);
                tilesDeck[i]->increaseSand();
                SandMarkersLeft--;
            }
            updateScreen(allegro);
            stormCardsDeck[0]->showImage(allegro);
            usleep(DRAW_CARD_SLEEP);
        case DOWN1:
#ifdef DEBUG_GAME
            cout << "Down" << endl;
#endif
            i = 0;
            while (tilesDeck[i]->gettileType() != STORM) { i++; }
            if (i % 5 < 4) {
                if (character->getCardIndex() == i + 1) {
                    character->moveUp();
                    character->resetNumberOfMoves();
                }
                if (character2->getCardIndex() == i + 1) {
                    character2->moveUp();
                    character2->resetNumberOfMoves();
                }
                if (propeller->getCardIndex() == i + 1) { propeller->setCardIndex(i, allegro); }
                if (engine->getCardIndex() == i + 1) { engine->setCardIndex(i, allegro); }
                if (solarCrystal->getCardIndex() == i + 1) { solarCrystal->setCardIndex(i, allegro); }
                if (navigationDeck->getCardIndex() == i + 1) { navigationDeck->setCardIndex(i, allegro); }
                swapTiles(i, i + 1);
                tilesDeck[i]->increaseSand();
                SandMarkersLeft--;
            }
            updateScreen(allegro);
            stormCardsDeck[0]->showImage(allegro);
            usleep(DRAW_CARD_SLEEP);
            break;
        case SUNBEATSDOWN:
#ifdef DEBUG_GAME
            cout << "Sun Beats Down" << endl;
#endif
            al_play_sample(allegro->sunBeatsDownSound, allegro->volume, 0, 1, ALLEGRO_PLAYMODE_ONCE, NULL);
            character->drinkWater();
            character2->drinkWater();
            if (character->shield) { //If player is being protected by the shield card or is inside a tunnel
                character->addWater();
                if (character->getColumn() == character2->getColumn() && character->getRow() == character2->getRow())
                    character2->addWater();
            } else if (tilesDeck[character->getCardIndex()]->gettileType() == TUNNEL &&
                       tilesDeck[character->getCardIndex()]->isTurned())
                character->addWater();
            if (character2->shield) {
                character2->addWater();
                if (character2->getRow() == character->getRow() && character2->getColumn() == character->getColumn())
                    character->addWater();
            } else if (tilesDeck[character2->getCardIndex()]->gettileType() == TUNNEL &&
                       tilesDeck[character2->getCardIndex()]->isTurned())
                character2->addWater();
            updateScreen(allegro);
            stormCardsDeck[0]->showImage(allegro);
            usleep(DRAW_CARD_SLEEP);
            break;
        case STORMUP:
#ifdef DEBUG_GAME
            cout << "Storm Pick Up" << endl;
#endif
            al_play_sample(allegro->stormSound, allegro->volume, 0, 1, ALLEGRO_PLAYMODE_ONCE, NULL);
            sandStormLevel++;
            updateScreen(allegro);
            stormCardsDeck[0]->showImage(allegro);
            usleep(DRAW_CARD_SLEEP);
    };

    rotate(stormCardsDeck.begin(), stormCardsDeck.begin() + 1, stormCardsDeck.end());
}

//! Initialize Methods
void Game::initializeBoard(ALL *allegro) {
#ifdef DEBUG_INIT
    cout << "Initialize Board" << endl;
    cout << "Set Tiles" << endl;
#endif
    //Set Tiles
    for (uint i = 0; i < tilesDeck.size(); i++) {
        tilesDeck[i] = new Tile(info.tiles[i], allegro);
    }
/*#ifdef DEBUG_INIT
    cout << "Set santds on the tiles" << endl;
#endif*/
    //Set the sands on the tiles
    for (int i = 1; i < 12; i++) {
        if (i != 6 && i != 10 && i != 2) {
            tilesDeck[2 * i]->setSand(1);
        }
    }
/*#ifdef DEBUG_INIT
    cout << "Ser characters over crash" << endl;
#endif*/
    //Set Character over crash site
    for (uint i = 0; i < tilesDeck.size(); i++) {
        if (tilesDeck[i]->gettileType() == CRASHSITE) {
            character->setPos(i % 5, i / 5);
            character2->setPos(i % 5, i / 5);
            tilesDeck[i]->setTurned(true);        // TURN CRASHSITE TO MAKE IT NO POSIBLE TO LOSE A MOVEMENT DIGGING IT.
            i = tilesDeck.size();
        }
    }
/*#ifdef DEBUG_INIT
    cout << "Reset Moves" << endl;
#endif*/
    character->resetNumberOfMoves();    // This is done because "initializeBoard" decreses the character number of moves by one
    character2->resetNumberOfMoves();
/*#ifdef DEBUG_INIT
    cout << "Board done!" << endl;
#endif*/
}
bool Game::initializeAllegro(ALL *allegro) {
    bool state = true;
#ifndef WINDOWED
    ALLEGRO_DISPLAY_MODE disp_data;
    al_get_display_mode(al_get_num_display_modes() - 1, &disp_data);
    al_set_new_display_flags(ALLEGRO_FULLSCREEN);
    allegro->display = al_create_display(disp_data.width, disp_data.height);
    allegro->screenWidth = disp_data.width;
    allegro->screenHeight = disp_data.height;
#endif
#ifdef WINDOWED
    if (state) {
        state = false;
        if (allegro->display = al_create_display(SCREEN_X, SCREEN_Y)) {
            allegro->screenWidth = SCREEN_X;
            allegro->screenHeight = SCREEN_Y;
            //if (allegro->startMenuDisplay != NULL) { al_destroy_display(allegro->startMenuDisplay); } //Just in case
            al_register_event_source(allegro->events_queue, al_get_display_event_source(allegro->display));
            state = true;
        } else { cerr << "Failed to create Display" << endl; }
    }
#endif
    //Load Images
    if (state) {
        state = false;
        al_set_target_backbuffer(allegro->display);
        if (allegro->fondo = al_load_bitmap_resized("Resources/PlayingBack.jpg", allegro)) {
            if (allegro->mouse = al_load_bitmap_resized("Resources/mouse.png", allegro)) {
                state = true;
            } else { cerr << "Failed to load mouse.png" << endl; }
        } else { cerr << "Failed to load scenario.png" << endl; }
    }

    //Audio
    al_stop_sample(&allegro->backgroundMusicID);        //Stop Current Song and play the new one
    allegro->backgroundMusic = al_load_sample("Resources/Sounds/desert.wav");
    if (allegro->backgroundMusic != NULL) {
        al_play_sample(allegro->backgroundMusic, allegro->volume / 2, 0.0, 1.0, ALLEGRO_PLAYMODE_LOOP,
                       &allegro->backgroundMusicID);
    } else { cerr << "Couldn't load desert.wav sample" << endl; }
    al_play_sample(allegro->startMusic, allegro->volume / 2, 0, 1, ALLEGRO_PLAYMODE_ONCE, NULL);
    //mouse
    if (allegro->mouse = al_load_bitmap_resized("Resources/mouse.png", allegro)) {
        if (allegro->cursor = al_create_mouse_cursor(allegro->mouse, 0, 0)) {
            al_set_mouse_cursor(allegro->display, allegro->cursor);
        }
    }
    al_clear_to_color(al_map_rgb(0, 0, 0));
    al_draw_bitmap(allegro->fondo, 0, 0, 0);
    al_flip_display();

    return state;
}
void Game::initializeStormCards(ALL *allegro) {
#ifdef DEBUG_INIT
    cout << "Initialize Storm Cards" << endl;
#endif
    // create storm cards Deck
    for (uint i = 0; i < stormCardsDeck.size(); i++) {
            stormCardsDeck[i] = new StormCard(info.storm[i], allegro);
    }
}
void Game::initializeCharacters(Container info, ALL *allegro) {
#ifdef DEBUG_INIT
    cout << "Initialize Characters" << endl;
#endif
    //Initailize both characters
    switch (info.myRol) {
        case ARCHEOLOGIST:
            character = new ArcheologistCharacter(0, 0, info, allegro);
            character->setName(info.name);
            break;
        case CLIMBER:
            character = new ClimberCharacter(0, 0, info, allegro);
            character->setName(info.name);
            break;
        case EXPLORER:
            character = new ExplorerCharacter(0, 0, info, allegro);
            character->setName(info.name);
            break;
        case METEOROLOGIST:
            character = new MeteorologistCharacter(0, 0, info, allegro);
            character->setName(info.name);
            break;
        case NAVIGATOR:
            character = new NavigatorCharacter(0, 0, info, allegro);
            character->setName(info.name);
            break;
        case WATER_CARRIER:
            character = new WaterCarrierCharacter(0, 0, info, allegro);
            character->setName(info.name);
            break;
    }
    switch (info.friendRol) {
        case ARCHEOLOGIST:
            character2 = new ArcheologistCharacter(0, 0, info, allegro);
            character2->setName(info.friendName);
            break;
        case CLIMBER:
            character2 = new ClimberCharacter(0, 0, info, allegro);
            character2->setName(info.friendName);
            break;
        case EXPLORER:
            character2 = new ExplorerCharacter(0, 0, info, allegro);
            character2->setName(info.friendName);
            break;
        case METEOROLOGIST:
            character2 = new MeteorologistCharacter(0, 0, info, allegro);
            character2->setName(info.friendName);
            break;
        case NAVIGATOR:
            character2 = new NavigatorCharacter(0, 0, info, allegro);
            character2->setName(info.friendName);
            break;
        case WATER_CARRIER:
            character2 = new WaterCarrierCharacter(0, 0, info, allegro);
            character2->setName(info.friendName);
            break;
    }
}
void Game::initializeButtons(ALL *allegro) {
#ifdef DEBUG_INIT
    cout << "Initialize Buttons" << endl;
#endif
    modesButtons[REMOVEBUTTON] = new Button(allegro->screenWidth * 0.68, allegro->screenHeight * 0.1037,
                                            "Resources/Buttons/Actions/noMouseRemoveSand.png",
                                            "Resources/Buttons/Actions/mouseRemoveSand.png", allegro);
    modesButtons[EXCAVATEBUTTON] = new Button(allegro->screenWidth * 0.68, allegro->screenHeight * 0.1343,
                                              "Resources/Buttons/Actions/noMouseExcavate.png",
                                              "Resources/Buttons/Actions/mouseExcavate.png", allegro);
    modesButtons[PICKUPBUTTON] = new Button(allegro->screenWidth * 0.68, allegro->screenHeight / 6,
                                            "Resources/Buttons/Actions/noMousePickUpPart.png",
                                            "Resources/Buttons/Actions/mousePickUpPart.png", allegro);
    modesButtons[OFFERWBUTTON] = new Button(allegro->screenWidth * 0.68, allegro->screenHeight * 0.1981,
                                            "Resources/Buttons/Actions/noMouseOfferWater.png",
                                            "Resources/Buttons/Actions/mouseOfferWater.png", allegro);
    modesButtons[OFFEREBUTTON] = new Button(allegro->screenWidth * 0.68, allegro->screenHeight * 0.2324,
                                            "Resources/Buttons/Actions/noMouseOfferEquipment.png",
                                            "Resources/Buttons/Actions/mouseOfferEquipment.png", allegro);
    modesButtons[REQUESTWBUTTON] = new Button(allegro->screenWidth * 0.68, allegro->screenHeight * 0.2639,
                                              "Resources/Buttons/Actions/noMouseRequestWater.png",
                                              "Resources/Buttons/Actions/mouseRequestWater.png", allegro);
    modesButtons[REQUESTEBUTTON] = new Button(allegro->screenWidth * 0.68, allegro->screenHeight * 0.2972,
                                              "Resources/Buttons/Actions/noMouseRequestEquipment.png",
                                              "Resources/Buttons/Actions/mouseRequestEquipment.png", allegro);
    endTurnButton = new Button(allegro->screenWidth - al_get_bitmap_width(
            al_load_bitmap_resized("Resources/Buttons/noMouseEndTurnButton.png", allegro)) * 5 / 4,
                               al_get_bitmap_height(
                                       al_load_bitmap_resized("Resources/Buttons/noMouseEndTurnButton.png", allegro)) *
                               3 / 2, "Resources/Buttons/noMouseEndTurnButton.png",
                               "Resources/Buttons/mouseEndTurnButton.png", allegro);
    muteButton = new Button(allegro->screenWidth / 4, al_get_bitmap_height(
            al_load_bitmap_resized("Resources/Buttons/noMouseEndTurnButton.png", allegro)) * 3 / 2,
                            "Resources/Buttons/muteButton.png", "Resources/Buttons/muteButton.png", allegro);
    noMuteButton = new Button(allegro->screenWidth / 4, al_get_bitmap_height(
            al_load_bitmap_resized("Resources/Buttons/noMouseEndTurnButton.png", allegro)) * 3 / 2,
                              "Resources/Buttons/noMuteButton.png", "Resources/Buttons/noMuteButton.png", allegro);
    // Special Buttons
    if (ALLEGRO_BITMAP *tempArrowImage = al_load_bitmap_resized("Resources/Buttons/Peep/nextPeepButton.png", allegro)) {
        previousButton = new Button(allegro->screenWidth / 2 - 300, allegro->screenHeight / 2,
                                    "Resources/Buttons/Peep/previousPeepButton.png",
                                    "Resources/Buttons/Peep/previousPeepButton.png", allegro);
        nextButton = new Button(allegro->screenWidth / 2 + 300 - al_get_bitmap_width(tempArrowImage),
                                allegro->screenHeight / 2, "Resources/Buttons/Peep/nextPeepButton.png",
                                "Resources/Buttons/Peep/nextPeepButton.png", allegro);
    } else { std::cerr << "Failed to arrow image" << endl; }
    initializeWaterButtons(allegro);
    initializeEquipmentCardButton(allegro);
    if (MeteorologistCharacter *meteorologistCharacter = dynamic_cast<MeteorologistCharacter *>(character)) {
        initializePeepButtons(allegro);
    }
}
void Game::initializeWaterButtons(ALL *allegro) {
    // Water Buttons
    if (ALLEGRO_BITMAP *offsetImage = al_load_bitmap_resized("Resources/Buttons/Waters/1waterButtonImage.png",
                                                             allegro)) {
        watersButton[2] = new Button(allegro->screenWidth * 0.5 - al_get_bitmap_width(offsetImage) / 2,
                                     allegro->screenHeight * 0.5 - al_get_bitmap_height(offsetImage) / 2,
                                     "Resources/Buttons/Waters/3watersButtonImage.png",
                                     "Resources/Buttons/Waters/3watersButtonSelectedImage.png", allegro);
        watersButton[1] = new Button(watersButton[2]->getInitialPos().x,
                                     watersButton[2]->getInitialPos().y - 10 - al_get_bitmap_height(offsetImage),
                                     "Resources/Buttons/Waters/2watersButtonImage.png",
                                     "Resources/Buttons/Waters/2watersButtonSelectedImage.png", allegro);
        watersButton[0] = new Button(watersButton[2]->getInitialPos().x,
                                     watersButton[1]->getInitialPos().y - 10 - al_get_bitmap_height(offsetImage),
                                     "Resources/Buttons/Waters/1waterButtonImage.png",
                                     "Resources/Buttons/Waters/1waterButtonSelectedImage.png", allegro);
        watersButton[3] = new Button(watersButton[2]->getInitialPos().x,
                                     watersButton[2]->getInitialPos().y + 10 + al_get_bitmap_height(offsetImage),
                                     "Resources/Buttons/Waters/4watersButtonImage.png",
                                     "Resources/Buttons/Waters/4watersButtonSelectedImage.png", allegro);
        watersButton[4] = new Button(watersButton[2]->getInitialPos().x,
                                     watersButton[3]->getInitialPos().y + 10 + al_get_bitmap_height(offsetImage),
                                     "Resources/Buttons/Waters/5watersButtonImage.png",
                                     "Resources/Buttons/Waters/5watersButtonSelectedImage.png", allegro);
    } else { cerr << "Couldn't load offset image" << endl; }
}
void Game::initializePeepButtons(ALL *allegro) {
    if (ALLEGRO_BITMAP *tempButtonImage = al_load_bitmap_resized("Resources/Buttons/Peep/putToBottomPeepImage.png",
                                                                 allegro)) {
        firstTimeUpdateScreenPeep = 0;
        selectPeepCard = new Button((allegro->screenWidth - al_get_bitmap_width(tempButtonImage)) / 2,
                                    allegro->screenHeight / 2 + 300, "Resources/Buttons/Peep/putToBottomPeepImage.png",
                                    "Resources/Buttons/Peep/putToBottomPeepImage.png", allegro);
    } else { std::cerr << "Failed to load Peep Button Select" << endl; }
}
void Game::initializeEquipmentCardButton(ALL *allegro) {
    if (ALLEGRO_BITMAP *tempButtonImage = al_load_bitmap_resized("Resources/Buttons/Peep/SelectImage.png", allegro)) {
        firstTimeUpdateScreenChooseEquipment = 0;
        selectEquipmentCard = new Button((allegro->screenWidth - al_get_bitmap_width(tempButtonImage)) / 2,
                                         allegro->screenHeight / 2 + 300, "Resources/Buttons/Peep/SelectImage.png",
                                         "Resources/Buttons/Peep/mouseOverSelectImage.png", allegro);
    } else { std::cerr << "Failed to load Peep Button Select" << endl; }
}
//! Key Methods
void Game::keyEscape() {
    // TODO: add more
    switch (modeEnum) {
        case DUNEBLASTERMODE:
            character->increaseDuneBlaster();
            break;
        case JETPACKMODE:
            character->increaseJetPack();
            break;
        case TERRASCOPEMODE:
            character->increaseTerrascope();
            break;
        case MOVEOTHER:
            if(NavigatorCharacter *navigatorCharacter = dynamic_cast<NavigatorCharacter *>(character)) {
                if (navigatorCharacter->usedPartnerMoves()) {
                    character2->resetNumberOfMoves();
                    navigatorCharacter->decreseMoves();
                }
            } else { cerr << "Error: move other not being a Navigator" << endl; }
    }
    modeEnum = NORMAL;
}
//! Mouse Methods

void Game::checkMouse(ALL *allegro) {
    switch (modeEnum) {
        case PEEPMODE:
            nextButton->checkMouse(mouse.x, mouse.y, allegro->volume);
            previousButton->checkMouse(mouse.x, mouse.y, allegro->volume);
            selectPeepCard->checkMouse(mouse.x, mouse.y, allegro->volume);
            break;
        case JETPACKMODE:    //This should be inside tileCheckMouse directamente
            for (int i = 0; i < TILEDECKNUMBER; i++) {
                bool climber = false;
                if (ClimberCharacter *climberCharacter = dynamic_cast<ClimberCharacter *>(character)) { climber = true; }
                if (tilesDeck[i]->canIMove(climber))
                    tilesDeck[i]->checkButton(mouse.x, mouse.y, allegro->volume);
            }
            break;
        case TERRASCOPEMODE:
            for (int i = 0; i < TILEDECKNUMBER; i++) {
                if (!tilesDeck[i]->isTurned())
                    tilesDeck[i]->checkButton(mouse.x, mouse.y, allegro->volume);
            }
            break;
        case OFFEREQUIPMENTMODE:
        case REQUESTEQUIPMENTMODE:
            nextButton->checkMouse(mouse.x, mouse.y, allegro->volume);
            previousButton->checkMouse(mouse.x, mouse.y, allegro->volume);
            selectEquipmentCard->checkMouse(mouse.x, mouse.y, allegro->volume);
            break;
        case OFFERWATERMODE:
        case REQUESTWATERMODE:
            for (int i = 0; i < min(character->getWaters(), MAXWATERS - character2->getWaters() - 1); i++) {
                watersButton[i]->checkMouse(mouse.x, mouse.y, allegro->volume);
            }
            break;
        default:
            endTurnButton->checkMouse(mouse.x, mouse.y, allegro->volume);
            character->checkButton(SECRETWATERRESERVE, mouse.x, mouse.y, allegro->volume);
            for (int i = 0; i < MODEBUTTONSNUMBER; i++) {
                modesButtons[i]->checkMouse(mouse.x, mouse.y, allegro->volume);
            }
            checkTilesButtons(allegro->volume);
            //allegro->volume Buttons
            if (allegro->volume == 0) { muteButton->checkMouse(mouse.x, mouse.y, allegro->volume); }
            else { noMuteButton->checkMouse(mouse.x, mouse.y, allegro->volume); }
            //Character special Buttons
            if (MeteorologistCharacter *meteorologistCharacter = dynamic_cast<MeteorologistCharacter *>(character)) {
                meteorologistCharacter->checkMouseOverButton(mouse.x, mouse.y, allegro->volume);
            } else if (ClimberCharacter *climberCharacter = dynamic_cast<ClimberCharacter *>(character)) {    //I do a else if for the program to work faster
                climberCharacter->checkMouseOverButton(mouse.x, mouse.y, allegro->volume);
            } else if (WaterCarrierCharacter *waterCarrierCharacter = dynamic_cast<WaterCarrierCharacter *>(character)) {
                if (tilesDeck[character->getCardIndex()]->gettileType() == WATER &&
                    tilesDeck[character->getCardIndex()]->isTurned()) {
                    waterCarrierCharacter->checkMouseOverButton(mouse.x, mouse.y, allegro->volume);
                }
            } else if (NavigatorCharacter *navigatorCharacter = dynamic_cast<NavigatorCharacter *>(character)) {
                navigatorCharacter->checkMouseOverButton(mouse.x, mouse.y, modeEnum == MOVEOTHER, allegro->volume);
            }
    }
}
void Game::clickEquipmentButtons(ALL *allegro) {
    if (character->checkButton(DUNEBLAST, mouse.x, mouse.y, allegro->volume)) {
#ifdef DEBUG_GAME
        cout << " Secret Dune Blaster Button Clicked" << endl;
#endif
        al_play_sample(allegro->clickOnButtonSound, allegro->volume, 0, 1, ALLEGRO_PLAYMODE_ONCE, NULL);
        if (character->haveDuneBlaster())
            performEquipmentsAction(DUNEBLAST, allegro);
    }
    if (character->checkButton(SECRETWATERRESERVE, mouse.x, mouse.y, allegro->volume)) {
#ifdef DEBUG_GAME
        cout << " Secret Water Reserve Button Clicked" << endl;
#endif
        al_play_sample(allegro->clickOnButtonSound, allegro->volume, 0, 1, ALLEGRO_PLAYMODE_ONCE, NULL);
        if (character->haveWaterReserve())
            performEquipmentsAction(SECRETWATERRESERVE, allegro);
    }
    if (character->checkButton(JETPACK, mouse.x, mouse.y, allegro->volume)) {
#ifdef DEBUG_GAME
        cout << " Secret JetPack Button Clicked" << endl;
#endif
        al_play_sample(allegro->clickOnButtonSound, allegro->volume, 0, 1, ALLEGRO_PLAYMODE_ONCE, NULL);
        if (character->haveJetPack())
            performEquipmentsAction(JETPACK, allegro);
    }
    if (character->checkButton(SOLARSHIELD, mouse.x, mouse.y, allegro->volume)) {
#ifdef DEBUG_GAME
        cout << "Solar Shield Button Clicked" << endl;
#endif
        al_play_sample(allegro->clickOnButtonSound, allegro->volume, 0, 1, ALLEGRO_PLAYMODE_ONCE, NULL);
        if (character->haveSolarShield())
            performEquipmentsAction(SOLARSHIELD, allegro);
    }
    if (character->checkButton(TERRASCOPE, mouse.x, mouse.y, allegro->volume)) {
#ifdef DEBUG_GAME
        cout << "Terrascope Button clicked" << endl;
#endif
        al_play_sample(allegro->clickOnButtonSound, allegro->volume, 0, 1, ALLEGRO_PLAYMODE_ONCE, NULL);
        if (character->haveTerrascope())
            performEquipmentsAction(TERRASCOPE, allegro);
    }
    if (character->checkButton(TIMETHROTTLE, mouse.x, mouse.y, allegro->volume)) {
#ifdef DEBUG_GAME
        cout << "Time Throttle Button Clicked" << endl;
#endif
        al_play_sample(allegro->clickOnButtonSound, allegro->volume, 0, 1, ALLEGRO_PLAYMODE_ONCE, NULL);
        if (character->haveTimeThrottle())
            performEquipmentsAction(TIMETHROTTLE, allegro);
    }
}
//! Next and Previous Methods
void Game::nextEquipCard() {
    Character *tempCharacter;
    if (modeEnum == OFFEREQUIPMENTMODE) tempCharacter = character;
    else if (modeEnum == REQUESTEQUIPMENTMODE) tempCharacter = character2;
    switch (equipOffset) {
        case DUNEBLAST:
            if (tempCharacter->haveJetPack()) { equipOffset = JETPACK; }
            else if (tempCharacter->haveSolarShield()) { equipOffset = SOLARSHIELD; }
            else if (tempCharacter->haveTerrascope()) { equipOffset = TERRASCOPE; }
            else if (tempCharacter->haveWaterReserve()) { equipOffset = SECRETWATERRESERVE; }
            else if (tempCharacter->haveTimeThrottle()) { equipOffset = TIMETHROTTLE; }
            break;
        case JETPACK:
            if (tempCharacter->haveSolarShield()) { equipOffset = SOLARSHIELD; }
            else if (tempCharacter->haveTerrascope()) { equipOffset = TERRASCOPE; }
            else if (tempCharacter->haveWaterReserve()) { equipOffset = SECRETWATERRESERVE; }
            else if (tempCharacter->haveTimeThrottle()) { equipOffset = TIMETHROTTLE; }
            else if (tempCharacter->haveDuneBlaster()) { equipOffset = DUNEBLAST; }
            break;
        case SOLARSHIELD:
            if (tempCharacter->haveTerrascope()) { equipOffset = TERRASCOPE; }
            else if (tempCharacter->haveWaterReserve()) { equipOffset = SECRETWATERRESERVE; }
            else if (tempCharacter->haveTimeThrottle()) { equipOffset = TIMETHROTTLE; }
            else if (tempCharacter->haveDuneBlaster()) { equipOffset = DUNEBLAST; }
            else if (tempCharacter->haveJetPack()) { equipOffset = JETPACK; }
            break;
        case TERRASCOPE:
            if (tempCharacter->haveWaterReserve()) { equipOffset = SECRETWATERRESERVE; }
            else if (tempCharacter->haveTimeThrottle()) { equipOffset = TIMETHROTTLE; }
            else if (tempCharacter->haveDuneBlaster()) { equipOffset = DUNEBLAST; }
            else if (tempCharacter->haveJetPack()) { equipOffset = JETPACK; }
            else if (tempCharacter->haveSolarShield()) { equipOffset = SOLARSHIELD; }
            break;
        case SECRETWATERRESERVE:
            if (tempCharacter->haveTimeThrottle()) { equipOffset = TIMETHROTTLE; }
            else if (tempCharacter->haveDuneBlaster()) { equipOffset = DUNEBLAST; }
            else if (tempCharacter->haveJetPack()) { equipOffset = JETPACK; }
            else if (tempCharacter->haveSolarShield()) { equipOffset = SOLARSHIELD; }
            else if (tempCharacter->haveTerrascope()) { equipOffset = TERRASCOPE; }
            break;
        case TIMETHROTTLE:
            if (tempCharacter->haveDuneBlaster()) { equipOffset = DUNEBLAST; }
            else if (tempCharacter->haveJetPack()) { equipOffset = JETPACK; }
            else if (tempCharacter->haveSolarShield()) { equipOffset = SOLARSHIELD; }
            else if (tempCharacter->haveTerrascope()) { equipOffset = TERRASCOPE; }
            else if (tempCharacter->haveWaterReserve()) { equipOffset = SECRETWATERRESERVE; }
            break;
    }
}
void Game::previousEquipCard() {
    Character *tempCharacter;
    if (modeEnum == OFFEREQUIPMENTMODE) tempCharacter = character;
    else if (modeEnum == REQUESTEQUIPMENTMODE) tempCharacter = character2;
    switch (equipOffset) {
        case DUNEBLAST:
            if (tempCharacter->haveTimeThrottle()) { equipOffset = TIMETHROTTLE; }
            else if (tempCharacter->haveWaterReserve()) { equipOffset = SECRETWATERRESERVE; }
            else if (tempCharacter->haveTerrascope()) { equipOffset = TERRASCOPE; }
            else if (tempCharacter->haveSolarShield()) { equipOffset = SOLARSHIELD; }
            else if (tempCharacter->haveJetPack()) { equipOffset = JETPACK; }
            break;
        case JETPACK:
            if (tempCharacter->haveDuneBlaster()) { equipOffset = DUNEBLAST; }
            else if (tempCharacter->haveTimeThrottle()) { equipOffset = TIMETHROTTLE; }
            else if (tempCharacter->haveWaterReserve()) { equipOffset = SECRETWATERRESERVE; }
            else if (tempCharacter->haveTerrascope()) { equipOffset = TERRASCOPE; }
            else if (tempCharacter->haveSolarShield()) { equipOffset = SOLARSHIELD; }
            break;
        case SOLARSHIELD:
            if (tempCharacter->haveJetPack()) { equipOffset = JETPACK; }
            else if (tempCharacter->haveDuneBlaster()) { equipOffset = DUNEBLAST; }
            else if (tempCharacter->haveTimeThrottle()) { equipOffset = TIMETHROTTLE; }
            else if (tempCharacter->haveWaterReserve()) { equipOffset = SECRETWATERRESERVE; }
            else if (tempCharacter->haveTerrascope()) { equipOffset = TERRASCOPE; }
            break;
        case TERRASCOPE:
            if (tempCharacter->haveSolarShield()) { equipOffset = SOLARSHIELD; }
            else if (tempCharacter->haveJetPack()) { equipOffset = JETPACK; }
            else if (tempCharacter->haveDuneBlaster()) { equipOffset = DUNEBLAST; }
            else if (tempCharacter->haveTimeThrottle()) { equipOffset = TIMETHROTTLE; }
            else if (tempCharacter->haveWaterReserve()) { equipOffset = SECRETWATERRESERVE; }
            break;
        case SECRETWATERRESERVE:
            if (tempCharacter->haveTerrascope()) { equipOffset = TERRASCOPE; }
            else if (tempCharacter->haveSolarShield()) { equipOffset = SOLARSHIELD; }
            else if (tempCharacter->haveJetPack()) { equipOffset = JETPACK; }
            else if (tempCharacter->haveDuneBlaster()) { equipOffset = DUNEBLAST; }
            else if (tempCharacter->haveTimeThrottle()) { equipOffset = TIMETHROTTLE; }
            break;
        case TIMETHROTTLE:
            if (tempCharacter->haveWaterReserve()) { equipOffset = SECRETWATERRESERVE; }
            else if (tempCharacter->haveTerrascope()) { equipOffset = TERRASCOPE; }
            else if (tempCharacter->haveSolarShield()) { equipOffset = SOLARSHIELD; }
            else if (tempCharacter->haveJetPack()) { equipOffset = JETPACK; }
            else if (tempCharacter->haveDuneBlaster()) { equipOffset = DUNEBLAST; }
            break;
    }
}
void Game::nextPeepStormCard() {
    if (peepOffset < sandStormLevel - 1) { peepOffset++; }
    else { peepOffset = 0; }
}
void Game::previousPeepStormCard() {
    if (peepOffset != 0) { peepOffset--; }
    else { peepOffset = sandStormLevel - 1; }
}

Game::~Game() {
    delete character;
    delete character2;
    for (int i = 0; i < CANTOFSTORM; i++) { delete stormCardsDeck[i]; }
    for (int i = 0; i < TILEDECKNUMBER; i++) { delete tilesDeck[i]; }
    for (int i = 0; i < MODEBUTTONSNUMBER; i++) { delete modesButtons[i]; }
    for (int i = 0; i < MAXWATERS; i++) { delete watersButton[i]; }
    delete endTurnButton;
    delete nextButton;
    delete previousButton;
    delete selectEquipmentCard;
    delete engine;
    delete solarCrystal;
    delete propeller;
    delete navigationDeck;
    if (system("CLS")) system("clear");
}
</file>

<file path="src/main.cpp">
#pragma warning(disable: 4996)
#include "def.hpp"
#include "allegro.hpp"

#include "ChoosePlayer.hpp"
//#include "Game.hpp"
#include "SinglePlayerGame.hpp"
#include "MultiPlayerGame.hpp"

/* ------------------- TODO -----------------------
 * TODO: poner numero de carta en peep mode
 * TODO: Priority: request water no anda
 * TODO: Not windowed mode just stops
 *
 *
5. Para poder declarar variables armï¿½ constructores por defecto vacios... estarï¿½a bueno borrarlos y ponerle argumentos por defecto (diapositiva 10-Administraciï¿½n de memoria, pagina 8)
*/

/*BUG REPORT
1.Al utilizar los vinoculares, se da vuelta la carta a espiar en la pantalla del jugador que lo utiliza, pero no se muestra al segundo jugador.
Luego de espiar esa carta, para volver a colocarla boca abajo, se pone boca abajo la ï¿½ltima carta dada vuelta, pero para AMBOS jugadores.
Dado que esa carta nunca se muestra para el segundo jugador, a este se le da vuelta la ï¿½ltima carta explorada, generando una desinconizaciï¿½n
entre las cartas de los jugadores. Esto se soluciona haciedno que la carta espiada con vinoculares se muestre a ambos jugadores, o cuidandose de 
no voltear la ï¿½ltima carta jugada en el jugador quyo turno no estï¿½ en proceso.

2.Tuve un problema con offer water, pero es porque no se hacer bien la lï¿½gica de la condiciï¿½n de que se puede hacer adyacente.

3.Al utilizar el tunel, el programa no se fija si los turnos llegaron a cero, permitiendo el jugador tener un numero negativo de turnos restantes
viajando de un lado hacia el otro del tunel repetidas veces. (Creo que arreglado, hice que se fijara si puede hacer setPos utilizando decreseMoves que devuelva bool)
*/

int main() {
    //Allegro initialization
    ALL allegroData = {0, 0, 0, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr};
    ALL *allegro = &allegroData;
    if (!init_allegro(allegro)) {
        cerr << "Failed to initialize allegro. Closing Forbidden Desert." << endl;
    }
    FSMI *gameNetwork = nullptr;
    bool stillPlaying;
    bool chooseMode = true;
    bool singlePlayer;

    auto *startMenu = new StartMenu(allegro);
    while (chooseMode) {
        chooseMode = startMenu->eventHandler(allegro);
    }
    al_destroy_display(allegro->startMenuDisplay);
    singlePlayer = startMenu->get_player_mode();
    delete startMenu;

    Container *info = new Container();
    if (singlePlayer) {
        cout << "Single Player Mode" << endl;
        stillPlaying = true;
        ChoosePlayer *choosePlayer;
        choosePlayer = new ChoosePlayer(allegro);
        while (stillPlaying) {
            stillPlaying = choosePlayer->eventHandler(allegro);
        }
        char rol1 = static_cast<char>(choosePlayer->get_p1_role());
        char rol2 = static_cast<char>(choosePlayer->get_p2_role());
        cout << "Roles chosen: " << RolesNames[(roles) rol1] << " & " << RolesNames[(roles) rol2] << endl;
        info->startinfo((roles) rol1, (roles) rol2);

        //Destroy allegro's things that were initialize in ChoosePlayer
        al_unregister_event_source(allegro->events_queue, al_get_display_event_source(allegro->display));
        al_destroy_display(allegro->display);
        delete choosePlayer;
    }
    else {
        cout << "Multi Player Mode" << endl;
        do { //Connection
            if (gameNetwork != nullptr)
                delete gameNetwork;
            gameNetwork = new FSMI;
            gameNetwork->start(allegro);
            al_destroy_display(allegro->startMenuDisplay);
        } while (gameNetwork->net.abort);
    }
	//Game
	cout << "Players chosen. Ready to start game" << endl;
	Game *game = nullptr;
	do {
		if (game != nullptr) {  // New game?
			delete game;
            cout << "Play again" << endl;
			if(!singlePlayer) { gameNetwork->restart(allegro); }
		}
		if (singlePlayer) {
		    game = new SinglePlayerGame(allegro, info);
		}
		else {
            game = new MultiPlayerGame(allegro, gameNetwork);
		}
		stillPlaying = true;
		while (stillPlaying) {
			stillPlaying = game->eventHandler(allegro);
		}
		al_destroy_display(allegro->display); // If not I'll end up with 2 displays
	} while (game->getPlayAgain() && !game->getGameOver()); // TODO: make them visible
    cout << "End game. Thank you for playing" << endl;
	if(!singlePlayer) {
        delete gameNetwork;
    }
	delete game;
	destroyAll(allegro);

	return 0;
}
</file>

<file path="src/MeteorologistButton.cpp">
#include "MeteorologistButton.hpp"

MeteorologistButton::MeteorologistButton() {

}

MeteorologistButton::MeteorologistButton (int x0, int y0, const char *imageName, const char * nonSelectedImageName, ALL* allegro) : Button(x0, y0, imageName, nonSelectedImageName, allegro) {}


bool MeteorologistButton::buttonAction(int x, int y) {
	if (mouseOverButton) {
		cout << "Click on Meteorologist Button" << endl;
		al_play_sample(selectCharSample, 1.0, 0.0, 1.0, ALLEGRO_PLAYMODE_ONCE, NULL);
		return true;
	}
	return false;
}
</file>

<file path="src/MultiPlayerGame.cpp">
//
// Created by barrachina on 12/21/18.
//

#include "MultiPlayerGame.hpp"

/**
 * Multiplayer Constructor
 * */
MultiPlayerGame::MultiPlayerGame(ALL *allegro, FSMI *gameNetwork) {
    this->gameNetwork = gameNetwork;
    info = gameNetwork->getInfo();
    //Conection
    turn = (gameNetwork->getInfo().myTurn == I_START);
    gamePack.connection = gameNetwork->net.connection;    //Guardo conexion en el paquete actual
    //allegro->volume = 1;
    if (initializeAllegro(allegro)) {
        //Characters
        initializeCharacters(info, allegro);
        //Buttons
        initializeButtons(allegro);
        //Cards and Decks
        initializeBoard(allegro);
        initializeStormCards(allegro);
        //Parts
        engine = new Part("Resources/Parts/engineImage.png");
        solarCrystal = new Part("Resources/Parts/solarCrystalImage.png");
        propeller = new Part("Resources/Parts/propellerImage.png");
        navigationDeck = new Part("Resources/Parts/navegationDeckImage.png");
        //Indexes
        equipIndex = 0;            //TODO: eliminar esto en un futuro
        peepOffset = 0;
        //Data
        SandMarkersLeft = 40;
        sandStormLevel = 3; //TODO: CUAL ERA EL NUMERO REAL? (era 3 jaja igual no cuesta NADA dejar a el jugador elegir la dificultad y queda mas copado)

        mouse.x = static_cast<int>(allegro->screenWidth / 2.0);
        mouse.y = static_cast<int>(allegro->screenHeight / 2.0);
        redraw = true;
        gameOver = false;
        playAgain = false;

        modeEnum = NORMAL;
    } else { cout << "Couldn't initialize allegro" << endl; }
}

/**------------------------------------------------------------------------------------------------------------------
* eventHandler:																										*
*			Core of the class, waits for events from keyboard, mouse, etc. Uses allegro events and acts acordingly.	*
* Practically the only function available (public) of the class.													*
*	Recomended Use:																									*
//Game																												*
stillPlaying = true;																								*
Game game = Game(allegro, &gameNetwork);																			*
while (stillPlaying) {																								*
	stillPlaying = game.eventHandler(allegro);																		*
}																													*
--------------------------------------------------------------------------------------------------------------------*/
bool MultiPlayerGame::eventHandler(ALL *allegro) {
    bool stillPlaying = true;
    ALLEGRO_EVENT ev;
    al_wait_for_event(allegro->events_queue, &ev);
/*#ifdef DEBUG_GAME
    cout << "EventHandler called "<< endl;
#endif*/

    if (ev.type == ALLEGRO_EVENT_TIMER) { redraw = true; }
    else if (ev.type == ALLEGRO_EVENT_DISPLAY_CLOSE) {
        gamePack.quit();
        gamePack.sendPack();
        gamePack.waitForAck(allegro);
        stillPlaying = false;
    } else if (ev.type == ALLEGRO_EVENT_MOUSE_AXES || ev.type == ALLEGRO_EVENT_MOUSE_ENTER_DISPLAY) {
        mouse.x = ev.mouse.x;
        mouse.y = ev.mouse.y;
        checkMouse(allegro);
    } else if (ev.type == ALLEGRO_EVENT_MOUSE_BUTTON_UP) {
        if (ev.mouse.button == SECONDARY_BUTTON) { keyEscape(); }
        else click(allegro);
    } else if (ev.type == ALLEGRO_EVENT_KEY_UP) {
        if (turn) { //Check if is my turn tu play... else... do nothing... just wait ^^
            switch (ev.keyboard.keycode) {
                case ALLEGRO_KEY_ESCAPE: //In case you want to cancel any mode you've played before.
                    keyEscape();
                    modeEnum = NORMAL;
                    break;
                case ALLEGRO_KEY_UP:
                    keyUp(allegro);
                    if (modeEnum != MOVEOTHER) { modeEnum = NORMAL; }
                    break;
                case ALLEGRO_KEY_DOWN:
                    keyDown(allegro);
                    if (modeEnum != MOVEOTHER) { modeEnum = NORMAL; }
                    break;
                case ALLEGRO_KEY_LEFT:
                    keyLeft(allegro);
                    if (modeEnum == REMOVESAND) { modeEnum = NORMAL; }
                    break;
                case ALLEGRO_KEY_RIGHT:
                    keyRight(allegro);
                    if (modeEnum == REMOVESAND) { modeEnum = NORMAL; }
                    break;
                case ALLEGRO_KEY_E:
                    keyE(allegro);
                    modeEnum = NORMAL;
                    break;
                case ALLEGRO_KEY_P:
                    keyP(allegro);
                    modeEnum = NORMAL;
                    break;
                case ALLEGRO_KEY_R:
                    keyR(allegro);
                    if (auto *explorerCharacter = dynamic_cast<ArcheologistCharacter *>(character)) {
                        if (modeEnum == REMOVESAND) {
                            if (tilesDeck[character->getCardIndex()]->haveSand()) {
                                tilesDeck[character->getCardIndex()]->removeSand();
                            }
                        }
                    }
                    if (modeEnum == NORMAL) { modeEnum = REMOVESAND; }
                    else { modeEnum = NORMAL; }
                    break;
                case ALLEGRO_KEY_W:
                    if (modeEnum == NORMAL &&
                        character2->getWaters() < MAXWATERS) {    //TODO: cambiar cuando haga el water carrier
                        modeEnum = OFFERWATERMODE;
                    } else { modeEnum = NORMAL; }
                    break;
                case ALLEGRO_KEY_O:
                    if (modeEnum == NORMAL) {
                        if (character->getCardIndex() == character2->getCardIndex()) {
                            if (character->haveDuneBlaster() || character->haveJetPack() ||
                                character->haveSolarShield() || character->haveTerrascope() ||
                                character->haveTimeThrottle()) {
                                modeEnum = OFFEREQUIPMENTMODE;
                                firstTimeUpdateScreenChooseEquipment = 0;
                            }
                        }
                    } else { modeEnum = NORMAL; }
                    break;
                default:
                    break;
            }
        }
    }
    //this 'if' checks if the other player I'm moving has already moved 3 spaces... if so... get out of the move other mode
    if (modeEnum == MOVEOTHER) {
        if (auto *navigatorCharacter = dynamic_cast<NavigatorCharacter *>(character)) {
            if (!navigatorCharacter->havePartnersMovesLeft()) {
                modeEnum = NORMAL;
                character2->resetNumberOfMoves();
                navigatorCharacter->decreseMoves();
            }
        } else { cout << "Error: was in moveother mode without being a Navigator" << endl; }
    }
    //checks if win or lose
    if (redraw && al_is_event_queue_empty(allegro->events_queue)) {
/*#ifdef DEBUG_GAME
        cout << "Redraw"<< endl;
#endif*/
        if (turn) {
            if (lose(allegro)) { stillPlaying = false; }
            else if (win(allegro)) { stillPlaying = false; }
        } else { stillPlaying = receiveHandler(allegro); }        //Handler of polonet
        updateScreen(allegro);
    }
    if (!turn) { stillPlaying = receiveHandler(allegro); } //Redundance make it more difficult to lose a command.
    return stillPlaying;
}
/**
* reciveHandler takes care of the connecion part. While in recibe handler it will check if there was an package sent by polonet and act acordingly.
*		Similar to eventHandler. But takes care of polonet insted of allegro. Between both functions they take care of all the events in the game class.
*/
bool MultiPlayerGame::receiveHandler(ALL *allegro) {
    int backup;
    Container temp;
    do {
        gamePack.cleanBuffer();
        temp = gamePack.receivePack();
        //gamePack.cleanBuffer();
        switch (temp.ID) {
            case MOVE://ANDA BIEN
                //cout << "move" << endl;
                character2->setPos(temp.Slot1, temp.Slot2);
                gamePack.ack();
                gamePack.sendPack();
                return true;
            case REMOVE://ANDA BIEN
                cout << "remove" << endl;
                if (character2->removeSand()) {
                    if (tilesDeck[5 * temp.Slot2 + temp.Slot1]->haveSand()) {
                        tilesDeck[5 * temp.Slot2 + temp.Slot1]->removeSand();
                        SandMarkersLeft++;
                        cout << "Sand Marker ++" << endl;
                        if (ArcheologistCharacter *explorerCharacter = dynamic_cast<ArcheologistCharacter *>(character2)) {
                            if (tilesDeck[5 * temp.Slot2 + temp.Slot1]->haveSand()) {
                                tilesDeck[5 * temp.Slot2 + temp.Slot1]->removeSand();
                                SandMarkersLeft++;
                                cout << "Sand Marker ++" << endl;
                            }
                        }
                        gamePack.ack();
                        gamePack.sendPack();
                        temp.ID = NOEVENT;
                    } else { cout << "My partner told me to remove sand where it was no sand" << endl; }
                    return true;
                } else {
                    cout << "Big mistake! tell me to remove sand when char 2 had no moves left!" << endl;
                    return false;
                }
            case OFFER_EQUIPMENT://ANDA BIEN
                cout << "offer equipment" << endl;
                chooseOption(allegro, temp);
                gamePack.cleanBuffer();
                return true;
            case OFFER_WATER://ANDA BIEN
                cout << "offer water" << endl;
                chooseOption(allegro, temp);
                gamePack.cleanBuffer();
                return true;
            case REQUEST_EQUIPMENT:
                cout << "request equipment" << endl;
                chooseOption(allegro, temp);
                gamePack.cleanBuffer();
                return true;
            case REQUEST_WATER:
                cout << "request water" << endl;
                chooseOption(allegro, temp);
                gamePack.cleanBuffer();
                return true;
            case REQUEST_MOVE:
                cout << "Request Move" << endl;
                //character->resetNumberOfMoves();		//To make sure it set the position
                character->setPos(temp.Slot1, temp.Slot2);
                gamePack.ack();
                gamePack.sendPack();
                return true;
            case PLAY_EQUIPMENT:
                switch (temp.Slot1) {
                    case DUNEBLAST:
                        character2->decreaseDuneBlaster(); //TODO: te deja hacerlo aunque no haya sands? darÃ­a bronca errarle al tile
                        while (tilesDeck[5 * temp.Slot3 + temp.Slot2]->haveSand()) {
                            tilesDeck[5 * temp.Slot3 + temp.Slot2]->removeSand();
                            SandMarkersLeft++;
                            cout << "Sand Marker ++" << endl;;
                        }
                        gamePack.ack();
                        gamePack.sendPack();
                        break;
                    case JETPACK:
                        character2->decreaseJetPack();
                        character2->setPos(temp.Slot2, temp.Slot3);
                        character2->increaseMoves();
                        gamePack.ack();
                        gamePack.sendPack();
                        break;
                    case SOLARSHIELD:
                        character2->decreaseSolarShield();
                        character2->shield = true;
                        gamePack.ack();
                        gamePack.sendPack();
                        break;
                    case TERRASCOPE:
                        character2->decreaseTerrascope();
                        backup = tilesDeck[character2->getCardIndex()]->getSand();
                        tilesDeck[character2->getCardIndex()]->turnTerrascopeTile();
                        //tilesDeck[character2->getCardIndex()]->updateTile(allegro); //TODO: why this? I update Below
                        al_flip_display();
                        gamePack.ack();
                        gamePack.sendPack();
                        usleep(TIME_TERRASCOPE);
                        tilesDeck[character2->getCardIndex()]->setSand(backup);
                        tilesDeck[character2->getCardIndex()]->setTurned(false);
                        break;
                    case SECRETWATERRESERVE:
                        cout << "Received SecretWaterReserve" << endl;
                        character2->decreaseWaterReserve();
                        character2->addWater();
                        character2->addWater();
                        if (character->getRow() == character2->getRow() && character->getColumn() == character2->getColumn()) {
                            character->addWater();
                            character->addWater();
                        }
                        gamePack.ack();
                        gamePack.sendPack();
                        break;
                    case TIMETHROTTLE:
                        character2->decreaseTimeThrottle();
                        character2->increaseMoves();
                        character2->increaseMoves();
                        break;
                }
                return true;
            case PEEP:
                gamePack.ack();
                gamePack.sendPack();
                for (int i = 0; i < temp.Slot1; i++) { swapStormCards(temp.Slot1 - i - 1, temp.Slot1 - i); }
                rotate(stormCardsDeck.begin(), stormCardsDeck.begin() + 1, stormCardsDeck.end());
                if (MeteorologistCharacter *meteorologistCharacter = dynamic_cast<MeteorologistCharacter *>(character2)) { meteorologistCharacter->peep(); }
                else { cout << "My partner send me a peep without being a Meteorologist" << endl; }
                return true;
            case EXCAVATE:
                if (character2->dig()) {
                    tilesDeck[character2->getCardIndex()]->turnTile();
                    performTileAction(tilesDeck[character2->getCardIndex()]->gettileType(), character2->getCardIndex(),
                                      allegro);
                    gamePack.ack();
                    gamePack.sendPack();
                    return true;
                } else {
                    cout << "Big Mistake! they told me to dig while player 2 had no movements left!" << endl;
                    return false;
                }
            case PICKUP:
                pickUpAction();
                gamePack.ack();
                gamePack.sendPack();
                return true;
            case TAKE_WATER:
                if (WaterCarrierCharacter *waterCarrierCharacter = dynamic_cast<WaterCarrierCharacter *>(character2)) {
                    waterCarrierCharacter->getWatersFromWell();
                    gamePack.ack();
                    gamePack.sendPack();
                } else { cout << "I've received TakeWater whithout be character2 a waterCarrier" << endl; }
                return true;
            case PASS:
                gamePack.ack();
                gamePack.sendPack();
                drawStormCards(allegro);
                turn = true; //must go after drawStormCards
                character2->resetNumberOfMoves(); //must go after drawStormCards
                character->resetNumberOfMoves();
                character->shield = false;
                return true;
            case GAME_OVER:
                playAgain = false;
                gameOver = true;
                return false;
            case PLAY_AGAIN:
                playAgain = true;
                gameOver = false;
                return false;
            case WE_WON:
                wannaPlay(allegro, WE_WON);
                return true;
            case WE_LOST:
                wannaPlay(allegro, WE_LOST);
                return true;
            case QUIT:
                cout << "Quit" << endl;
                playAgain = false;
                gameOver = true;
                gamePack.ack();
                gamePack.sendPack();
                return false;
        }
    } while (temp.ID != NOEVENT);

    return true;
}

void MultiPlayerGame::pickUpAction() {
    /*	Picks up the part in question. The function use the character acording to whose turn is it and then checks if its posible to pick up
	the part. If it is, picks up the correct part
	*/
    Character *tempChar;            //pointer to character. it will point to character 1 or 2 acording to whose turn is it.
    if (turn) { tempChar = character; }
    else { tempChar = character2; }
    // This code makes the player be able to pick up multiple items at once if they are at the same place
    if (tempChar->getRow() == engine->getRow() && tempChar->getColumn() == engine->getColumn()) {
        if (engine->getFoundState()) {            //Only able to pick it up if I found it
            if (tilesDeck[tempChar->getCardIndex()]->isTurned()) {
                if (tilesDeck[tempChar->getCardIndex()]->canIMove(false)) {
                    if (tempChar->pickUpPart()) { engine->pickUpPart(); }
                }
            }
        }
    }
    if (tempChar->getRow() == solarCrystal->getRow() && tempChar->getColumn() == solarCrystal->getColumn()) {
        if (solarCrystal->getFoundState()) {
            if (tilesDeck[tempChar->getCardIndex()]->isTurned()) {
                if (tilesDeck[tempChar->getCardIndex()]->canIMove(false)) {
                    if (tempChar->pickUpPart()) { solarCrystal->pickUpPart(); }
                }
            }
        }
    }
    if (tempChar->getRow() == propeller->getRow() && tempChar->getColumn() == propeller->getColumn()) {
        if (propeller->getFoundState()) {
            if (tilesDeck[tempChar->getCardIndex()]->isTurned()) {
                if (tilesDeck[tempChar->getCardIndex()]->canIMove(false)) {
                    if (tempChar->pickUpPart()) { propeller->pickUpPart(); }
                }
            }
        }
    }
    if (navigationDeck->getRow() == tempChar->getRow() && tempChar->getColumn() == navigationDeck->getColumn()) {
        if (navigationDeck->getFoundState()) {
            if (tilesDeck[tempChar->getCardIndex()]->isTurned()) {
                if (tilesDeck[tempChar->getCardIndex()]->canIMove(false)) {
                    if (tempChar->pickUpPart()) { navigationDeck->pickUpPart(); }
                }
            }
        }
    }
}

bool MultiPlayerGame::win(ALL *allegro) {
    /*Used to check if the players won*/
    if (engine->getPickedState() && solarCrystal->getPickedState() && propeller->getPickedState() &&
        navigationDeck->getPickedState()) {
        character->playGettingCloseSound();
        if (tilesDeck[character->getCardIndex()]->gettileType() == LAUNCHPAD) {
            if (tilesDeck[character2->getCardIndex()]->gettileType() == LAUNCHPAD) {
                al_draw_bitmap(allegro->menuBackgroundImage, 0, 0, 0);
                al_draw_text(allegro->gameFont, al_map_rgb(WHITE), allegro->screenWidth / 2,
                             allegro->screenHeight * 0.4, ALLEGRO_ALIGN_CENTRE, "WE WON");
                al_flip_display();
                gamePack.wewon();
                gamePack.sendPack();
                char wait;
                do {
                    wait = gamePack.receivePack().ID;
                    gamePack.cleanBuffer();
                } while (wait != PLAY_AGAIN && wait != GAME_OVER);

                if (wait == PLAY_AGAIN) {
                    wannaPlay(allegro, WE_WON);
                    //playAgain = true;
                } else if (wait == GAME_OVER) {
                    playAgain = false;
                    gameOver = true;
                }
                return true;
            }
        }
    }
    return false;
}

bool MultiPlayerGame::lose(ALL *allegro) {
    /* Lose: used to check if the players lose*/
    if (sandStormLevel < 15) {
        if (SandMarkersLeft > 0) {
            if (character->haveWater()) {
                if (character2->haveWater()) {
                    return false;
                } else {
                    al_draw_text(allegro->gameFont, al_map_rgb(WHITE), allegro->screenWidth / 2,
                                 allegro->screenHeight * 0.9, ALLEGRO_ALIGN_CENTRE,
                                 "Your partner has died from thirst");
                    cout << "Your partner has died from thirst" << endl;
                }
            } else {
                al_draw_text(allegro->gameFont, al_map_rgb(WHITE), allegro->screenWidth / 2,
                             allegro->screenHeight * 0.9, ALLEGRO_ALIGN_CENTRE, "You have died from thirst");
                cout << "You have died from thirst" << endl;
            }
        } else {
            al_draw_text(allegro->gameFont, al_map_rgb(WHITE), allegro->screenWidth / 2, allegro->screenHeight * 0.9,
                         ALLEGRO_ALIGN_CENTRE, "You habe been burried by the sand");
            cout << "You have been burried by the sand" << endl;
        }
    } else {
        al_draw_text(allegro->gameFont, al_map_rgb(WHITE), allegro->screenWidth / 2, allegro->screenHeight * 0.9,
                     ALLEGRO_ALIGN_CENTRE, "You have been killed by the storm");
        cout << "You have been killed by the storm" << endl;
    }
    //If i'm here, it's because I lose.
    al_draw_bitmap(allegro->menuBackgroundImage, 0, 0, 0);
    al_draw_text(allegro->gameFont, al_map_rgb(WHITE), allegro->screenWidth / 2, allegro->screenHeight * 0.4,
                 ALLEGRO_ALIGN_CENTRE, "WE LOST");
    al_flip_display();
    gamePack.welost();
    gamePack.sendPack();
    char wait;
    do {
        wait = gamePack.receivePack().ID;
        gamePack.cleanBuffer();
    } while (wait != PLAY_AGAIN && wait != GAME_OVER);

    if (wait == PLAY_AGAIN) {
        wannaPlay(allegro, WE_LOST);
    } else if (wait == GAME_OVER) {
        gamePack.gameover();
        gamePack.sendPack();
        gamePack.waitForAck(allegro);
        playAgain = false;
        gameOver = true;
    }
    return true;
}

void MultiPlayerGame::wannaPlay(ALL *allegro, char ID) {
    ALLEGRO_EVENT ev;
    ALLEGRO_EVENT_QUEUE *tempQueue;
    if (tempQueue = al_create_event_queue()) {
        al_register_event_source(tempQueue, al_get_mouse_event_source());
        Button *playAgainButton, *gameOverButton;
        playAgainButton = new Button(allegro->screenWidth * 0.25, allegro->screenHeight * 0.65,
                                     "Resources/Buttons/playAgainButton.png",
                                     "Resources/Buttons/playAgainSelectedButton.png", allegro);
        gameOverButton = new Button(allegro->screenWidth * 0.65, allegro->screenHeight * 0.65,
                                    "Resources/Buttons/gameOverButton.png",
                                    "Resources/Buttons/gameOverSelectedButton.png", allegro);
        bool run = true;
        al_draw_bitmap(allegro->menuBackgroundImage, 0, 0, 0);
        if (ID == WE_LOST) {
            al_draw_text(allegro->gameFont, al_map_rgb(WHITE), allegro->screenWidth / 2, allegro->screenHeight * 0.4,
                         ALLEGRO_ALIGN_CENTRE, "WE LOST");
        } else if (ID == WE_WON) {
            al_draw_text(allegro->gameFont, al_map_rgb(WHITE), allegro->screenWidth / 2, allegro->screenHeight * 0.4,
                         ALLEGRO_ALIGN_CENTRE, "WE WON");
        }
        while (run) {
            playAgainButton->updateButton(allegro);
            gameOverButton->updateButton(allegro);
            al_flip_display();
            al_wait_for_event(tempQueue, &ev);
            if (ev.type == ALLEGRO_EVENT_MOUSE_AXES) {
                playAgainButton->checkMouse(ev.mouse.x, ev.mouse.y, allegro->volume);
                gameOverButton->checkMouse(ev.mouse.x, ev.mouse.y, allegro->volume);
            } else if (ev.type == ALLEGRO_EVENT_MOUSE_BUTTON_UP) {
                if (playAgainButton->checkMouse(ev.mouse.x, ev.mouse.y, allegro->volume)) {
                    playAgain = true;
                    gameOver = false;
                    gamePack.playagain();
                    gamePack.sendPack();
                    run = false;
                } else if (gameOverButton->checkMouse(ev.mouse.x, ev.mouse.y, allegro->volume)) {
                    gameOver = true;
                    playAgain = false;
                    gamePack.gameover();
                    gamePack.sendPack();
                    run = false;
                }
            }

        }
        delete playAgainButton;
        delete gameOverButton;
        al_destroy_event_queue(tempQueue);
    } else { cout << "Could not initialize tempQueue" << endl; }
}

void MultiPlayerGame::performEquipmentsAction(EquipmentsEnum equipEnum, ALL *allegro) {
    /* Similar to performTileAction. gets the enum of the equipment and acts accordingly */
    bool run = true;
    switch (equipEnum) {
        case DUNEBLAST:
            character->decreaseDuneBlaster();
            modeEnum = DUNEBLASTERMODE;
            break;
        case JETPACK:
            character->decreaseJetPack();
            modeEnum = JETPACKMODE;
            break;
        case SOLARSHIELD:
            character->decreaseSolarShield();
            character->shield = true;
            gamePack.playequipment(SOLARSHIELD, character->getRow(), character->getColumn());
            gamePack.sendPack();
            gamePack.waitForAck(allegro);
            break;
        case TERRASCOPE:
            character->decreaseTerrascope();
            al_play_sample(allegro->curiositySound, allegro->volume, 0, 1, ALLEGRO_PLAYMODE_ONCE, NULL);
            modeEnum = TERRASCOPEMODE;
            break;
        case SECRETWATERRESERVE:
            //2 waters for each player
            character->decreaseWaterReserve();
            character->addWater();
            character->addWater();
            al_play_sample(allegro->waterSound, allegro->volume, 0, 1, ALLEGRO_PLAYMODE_ONCE, NULL);
            if (character->getRow() == character2->getRow() && character->getColumn() == character2->getColumn()) {
                character2->addWater();
                character2->addWater();
            }
            gamePack.playequipment(SECRETWATERRESERVE, character->getRow(), character->getColumn());
            gamePack.sendPack();
            gamePack.waitForAck(allegro);
            break;
        case TIMETHROTTLE:
            character->decreaseTimeThrottle();
            character->increaseMoves();
            character->increaseMoves();
            gamePack.playequipment(TIMETHROTTLE, character->getRow(), character->getColumn());
            gamePack.sendPack();
            gamePack.waitForAck(allegro);
            break;
        default:
            break;
    }
}

void MultiPlayerGame::keyUp(ALL *allegro) {
    /* Used when the kuy up was pressed, it does what it needs to be done after it happens */
    if (modeEnum != MOVEOTHER) {
        if (character->getCardIndex() > 0) {
            if (modeEnum == NORMAL) {
                bool climber = false;
                if (ClimberCharacter *climberCharacter = dynamic_cast<ClimberCharacter *>(character)) { climber = true; }
                if (tilesDeck[character->getCardIndex() - 1]->canIMove(climber)) { //If I'm not on top... move up
                    if (tilesDeck[character->getCardIndex()]->canIMove(climber)) {
                        if (character->moveUp()) {
                            if (ClimberCharacter *climberCharacter = dynamic_cast<ClimberCharacter *>(character)) {
                                if (climberCharacter->getTakeWithMe() &&
                                    character2->getCardIndex() - 1 == character->getCardIndex()) {
                                    character2->moveUp();
                                    gamePack.requestmove(character2->getRow(), character2->getColumn());
                                    gamePack.sendPack();
                                    gamePack.waitForAck(allegro);
                                    usleep(100);
                                    gamePack.move(character->getRow(), character->getColumn());
                                    gamePack.sendPack();
                                    gamePack.waitForAck(allegro);
                                }
                            }
                            //Connection
                            gamePack.move(character->getRow(), character->getColumn());
                            gamePack.sendPack();
                            gamePack.waitForAck(allegro);
                        }
                    }
                }
            } else if (modeEnum == REMOVESAND) {
                if (tilesDeck[character->getCardIndex() - 1]->haveSand()) {
                    if (character->removeSand()) {
                        tilesDeck[character->getCardIndex() - 1]->removeSand();
                        if (ArcheologistCharacter *explorerCharacter = dynamic_cast<ArcheologistCharacter *>(character)) {
                            if (tilesDeck[character->getCardIndex() - 1]->haveSand()) {
                                tilesDeck[character->getCardIndex() - 1]->removeSand();
                                SandMarkersLeft++;
                                cout << "Sand Marker ++" << endl;
                            }
                        }
                        gamePack.remove(character->getRow() - 1, character->getColumn());
                        gamePack.sendPack();
                        gamePack.waitForAck(allegro);
                        SandMarkersLeft++;
                        cout << "Sand Marker ++" << endl;
                    }
                }
            } else if (modeEnum == DUNEBLASTERMODE) {
                while (tilesDeck[character->getCardIndex() - 1]->haveSand()) {
                    tilesDeck[character->getCardIndex() - 1]->removeSand();
                    SandMarkersLeft++;
                    cout << "Sand Marker ++" << endl;
                }
                gamePack.playequipment(DUNEBLAST, character->getRow() - 1, character->getColumn());
                gamePack.sendPack();
                gamePack.waitForAck(allegro);
            }
        }
    } else {
        if (NavigatorCharacter *navigatorCharacter = dynamic_cast<NavigatorCharacter *>(character)) {
            if (character2->getCardIndex() > 0) {
                if (navigatorCharacter->havePartnersMovesLeft()) {
                    bool climber = false;
                    if (ClimberCharacter *climberCharacter = dynamic_cast<ClimberCharacter *>(character2)) { climber = true; }
                    if (tilesDeck[character2->getCardIndex() - 1]->canIMove(climber)) { //If I'm not on top... move up
                        if (tilesDeck[character2->getCardIndex()]->canIMove(climber)) {
                            if (character2->moveUp() && navigatorCharacter->decresePartnerMoves()) {
                                if (ClimberCharacter *climberCharacter = dynamic_cast<ClimberCharacter *>(character2)) {
                                    if (climberCharacter->getTakeWithMe() &&
                                        character->getCardIndex() - 1 == character2->getCardIndex()) {
                                        character->moveUp(); //TODO: this is not working yet, the other computer never knows if climber has its take with me active
                                    }
                                }
                                gamePack.requestmove(character2->getRow(), character2->getColumn());
                                gamePack.sendPack();
                                gamePack.waitForAck(allegro);
                            } else { cout << "Error: no moves left even though I was supposed to have" << endl; }
                        }
                    }
                }
            }
        } else { cout << "Error: Move Other mode without being a navigator character" << endl; }
    }
}
void MultiPlayerGame::keyDown(ALL *allegro) {
    if (modeEnum != MOVEOTHER) {
        if (character->getCardIndex() < tilesDeck.size() - 1) {
            if (modeEnum == NORMAL) {
                bool climber = false;
                if (ClimberCharacter *climberCharacter = dynamic_cast<ClimberCharacter *>(character)) { climber = true; }
                if (tilesDeck[character->getCardIndex() + 1]->canIMove(climber)) {
                    if (tilesDeck[character->getCardIndex()]->canIMove(climber)) {
                        if (character->moveDown()) {
                            if (ClimberCharacter *climberCharacter = dynamic_cast<ClimberCharacter *>(character)) {
                                if (climberCharacter->getTakeWithMe() &&
                                    character2->getCardIndex() + 1 == character->getCardIndex()) {
                                    character2->moveDown();
                                    gamePack.requestmove(character2->getRow(), character2->getColumn());
                                    gamePack.sendPack();
                                    gamePack.waitForAck(allegro);
                                    usleep(100);
                                    gamePack.move(character->getRow(), character->getColumn());
                                    gamePack.sendPack();
                                    gamePack.waitForAck(allegro);
                                }
                            }
                            gamePack.move(character->getRow(), character->getColumn());
                            gamePack.sendPack();
                            gamePack.waitForAck(allegro);
                        }
                    }
                }
            } else if (modeEnum == REMOVESAND) {
                if (tilesDeck[character->getCardIndex() + 1]->haveSand()) {
                    if (character->removeSand()) {
                        tilesDeck[character->getCardIndex() + 1]->removeSand();
                        if (ArcheologistCharacter *explorerCharacter = dynamic_cast<ArcheologistCharacter *>(character)) {
                            if (tilesDeck[character->getCardIndex() + 1]->haveSand()) {
                                tilesDeck[character->getCardIndex() + 1]->removeSand();
                                SandMarkersLeft++;
                                cout << "Sand Marker ++" << endl;
                            }
                        }
                        SandMarkersLeft++;
                        cout << "Sand Marker ++" << endl;
                        gamePack.remove(character->getRow() + 1, character->getColumn());
                        gamePack.sendPack();
                        gamePack.waitForAck(allegro);
                    }
                }
            } else if (modeEnum == DUNEBLASTERMODE) {
                while (tilesDeck[character->getCardIndex() + 1]->haveSand()) {
                    tilesDeck[character->getCardIndex() + 1]->removeSand();
                    SandMarkersLeft++;
                    cout << "Sand Marker ++" << endl;
                }
                gamePack.playequipment(DUNEBLAST, character->getRow() + 1, character->getColumn());
                gamePack.sendPack();
                gamePack.waitForAck(allegro);
            }
        }
    } else {
        if (NavigatorCharacter *navigatorCharacter = dynamic_cast<NavigatorCharacter *>(character)) {
            if (character2->getCardIndex() < tilesDeck.size() - 1) {
                if (navigatorCharacter->havePartnersMovesLeft()) {
                    bool climber = false;
                    if (ClimberCharacter *climberCharacter = dynamic_cast<ClimberCharacter *>(character2)) { climber = true; }
                    if (tilesDeck[character2->getCardIndex() + 1]->canIMove(climber)) {
                        if (tilesDeck[character2->getCardIndex()]->canIMove(climber)) {
                            if (character2->moveDown() && navigatorCharacter->decresePartnerMoves()) {
                                if (ClimberCharacter *climberCharacter = dynamic_cast<ClimberCharacter *>(character2)) {
                                    if (climberCharacter->getTakeWithMe() &&
                                        character->getCardIndex() + 1 == character2->getCardIndex()) {
                                        character->moveDown();
                                    }
                                }
                                gamePack.requestmove(character2->getRow(), character2->getColumn());
                                gamePack.sendPack();
                                gamePack.waitForAck(allegro);
                            } else { cout << "Error: no moves left even though I was supposed to have" << endl; }
                        }
                    }
                }
            }
        } else { cout << "Error: Move Other mode without being a navigator character" << endl; }
    }
}
void MultiPlayerGame::keyRight(ALL *allegro) {
    if (modeEnum == OFFEREQUIPMENTMODE || modeEnum == REQUESTEQUIPMENTMODE) { nextEquipCard(); }
    else if (modeEnum == PEEPMODE) { nextPeepStormCard(); }

    if (modeEnum != MOVEOTHER) {
        if (character->getCardIndex() < tilesDeck.size() - 5) {
            if (modeEnum == NORMAL) {
                bool climber = false;
                if (ClimberCharacter *climberCharacter = dynamic_cast<ClimberCharacter *>(character)) { climber = true; }
                if (tilesDeck[character->getCardIndex() + 5]->canIMove(climber)) {
                    if (tilesDeck[character->getCardIndex()]->canIMove(climber)) {
                        if (character->moveRight()) {
                            if (ClimberCharacter *climberCharacter = dynamic_cast<ClimberCharacter *>(character)) {
                                if (climberCharacter->getTakeWithMe() &&
                                    character2->getCardIndex() + 5 == character->getCardIndex()) {
                                    character2->moveRight();
                                    gamePack.requestmove(character2->getRow(), character2->getColumn());
                                    gamePack.sendPack();
                                    gamePack.waitForAck(allegro);
                                    usleep(100);
                                    gamePack.move(character->getRow(), character->getColumn());
                                    gamePack.sendPack();
                                    gamePack.waitForAck(allegro);
                                }
                            }
                            gamePack.move(character->getRow(), character->getColumn());
                            gamePack.sendPack();
                            gamePack.waitForAck(allegro);
                        }
                    }
                }
            } else if (modeEnum == REMOVESAND) {
                if (tilesDeck[character->getCardIndex() + 5]->haveSand()) {
                    if (character->removeSand()) {
                        tilesDeck[character->getCardIndex() + 5]->removeSand();
                        if (ArcheologistCharacter *explorerCharacter = dynamic_cast<ArcheologistCharacter *>(character)) {
                            if (tilesDeck[character->getCardIndex() + 5]->haveSand()) {
                                tilesDeck[character->getCardIndex() + 5]->removeSand();
                                SandMarkersLeft++;
                                cout << "Sand Marker ++" << endl;
                            }
                        }
                        gamePack.remove(character->getRow(), character->getColumn() + 1);
                        gamePack.sendPack();
                        gamePack.waitForAck(allegro);
                        SandMarkersLeft++;
                        cout << "Sand Marker ++" << endl;
                    }
                }
            } else if (modeEnum == DUNEBLASTERMODE) {
                while (tilesDeck[character->getCardIndex() + 5]->haveSand()) {
                    tilesDeck[character->getCardIndex() + 5]->removeSand();
                    SandMarkersLeft++;
                    cout << "Sand Marker ++" << endl;
                }
                gamePack.playequipment(DUNEBLAST, character->getRow(), character->getColumn() + 1);
                gamePack.sendPack();
                gamePack.waitForAck(allegro);
            }
        }
    } else {
        if (NavigatorCharacter *navigatorCharacter = dynamic_cast<NavigatorCharacter *>(character)) {
            if (character2->getCardIndex() < tilesDeck.size() - 5) {
                if (navigatorCharacter->havePartnersMovesLeft()) {
                    bool climber = false;
                    if (ClimberCharacter *climberCharacter = dynamic_cast<ClimberCharacter *>(character2)) { climber = true; }
                    if (tilesDeck[character2->getCardIndex() + 5]->canIMove(climber)) { //If I'm not on top... move up
                        if (tilesDeck[character2->getCardIndex()]->canIMove(climber)) {
                            if (character2->moveRight() && navigatorCharacter->decresePartnerMoves()) {
                                if (ClimberCharacter *climberCharacter = dynamic_cast<ClimberCharacter *>(character2)) {
                                    if (climberCharacter->getTakeWithMe() &&
                                        character->getCardIndex() + 5 == character2->getCardIndex()) {
                                        character->moveRight();
                                    }
                                }
                                gamePack.requestmove(character2->getRow(), character2->getColumn());
                                gamePack.sendPack();
                                gamePack.waitForAck(allegro);
                            } else { cout << "Error: no moves left even though I was supposed to have" << endl; }
                        }
                    }
                }
            }
        } else { cout << "Error: Move Other mode without being a navigator character" << endl; }
    }
}
void MultiPlayerGame::keyLeft(ALL *allegro) {
    if (modeEnum == OFFEREQUIPMENTMODE || modeEnum == REQUESTEQUIPMENTMODE) { previousEquipCard(); }
    else if (modeEnum == PEEPMODE) { previousPeepStormCard(); }

    if (modeEnum != MOVEOTHER) {
        if (character->getCardIndex() > 4) {
            if (modeEnum == NORMAL) {
                bool climber = false;
                if (ClimberCharacter *climberCharacter = dynamic_cast<ClimberCharacter *>(character)) { climber = true; }
                if (tilesDeck[character->getCardIndex() - 5]->canIMove(climber)) {
                    if (tilesDeck[character->getCardIndex()]->canIMove(climber)) {
                        if (character->moveLeft()) {
                            if (ClimberCharacter *climberCharacter = dynamic_cast<ClimberCharacter *>(character)) {
                                if (climberCharacter->getTakeWithMe() &&
                                    character2->getCardIndex() - 5 == character->getCardIndex()) {
                                    character2->moveLeft();
                                    gamePack.requestmove(character2->getRow(), character2->getColumn());
                                    gamePack.sendPack();
                                    gamePack.waitForAck(allegro);
                                    usleep(100);
                                    gamePack.move(character->getRow(), character->getColumn());
                                    gamePack.sendPack();
                                    gamePack.waitForAck(allegro);
                                }
                            }
                            gamePack.move(character->getRow(), character->getColumn());
                            gamePack.sendPack();
                            gamePack.waitForAck(allegro);
                        }
                    }
                }
            } else if (modeEnum == REMOVESAND) {
                if (tilesDeck[character->getCardIndex() - 5]->haveSand()) {
                    if (character->removeSand()) {
                        tilesDeck[character->getCardIndex() - 5]->removeSand();
                        if (ArcheologistCharacter *explorerCharacter = dynamic_cast<ArcheologistCharacter *>(character)) {
                            if (tilesDeck[character->getCardIndex() - 5]->haveSand()) {
                                tilesDeck[character->getCardIndex() - 5]->removeSand();
                                SandMarkersLeft++;
                                cout << "Sand Marker ++" << endl;
                            }
                        }
                        SandMarkersLeft++;
                        cout << "Sand Marker ++" << endl;
                        gamePack.remove(character->getRow(), character->getColumn() - 1);
                        gamePack.sendPack();
                        gamePack.waitForAck(allegro);
                    }
                }
            } else if (modeEnum == DUNEBLASTERMODE) {
                while (tilesDeck[character->getCardIndex() - 5]->haveSand()) {
                    tilesDeck[character->getCardIndex() - 5]->removeSand();
                    SandMarkersLeft++;
                    cout << "Sand Marker ++" << endl;
                }
                gamePack.playequipment(DUNEBLAST, character->getRow(), character->getColumn() - 1);
                gamePack.sendPack();
                gamePack.waitForAck(allegro);
            }
        }
    } else {
        if (NavigatorCharacter *navigatorCharacter = dynamic_cast<NavigatorCharacter *>(character)) {
            if (character2->getCardIndex() > 4) {
                if (navigatorCharacter->havePartnersMovesLeft()) {
                    bool climber = false;
                    if (ClimberCharacter *climberCharacter = dynamic_cast<ClimberCharacter *>(character2)) { climber = true; }
                    if (tilesDeck[character2->getCardIndex() - 5]->canIMove(climber)) {
                        if (tilesDeck[character2->getCardIndex()]->canIMove(climber)) {
                            if (character2->moveLeft() && navigatorCharacter->decresePartnerMoves()) {
                                if (ClimberCharacter *climberCharacter = dynamic_cast<ClimberCharacter *>(character2)) {
                                    if (climberCharacter->getTakeWithMe() &&
                                        character->getCardIndex() - 5 == character2->getCardIndex()) {
                                        character->moveLeft();
                                    }
                                }
                                gamePack.requestmove(character2->getRow(), character2->getColumn());
                                gamePack.sendPack();
                                gamePack.waitForAck(allegro);
                            }
                        }
                    }
                }
            }
        } else { cout << "Error: Move Other mode without being a navigator character" << endl; }
    }
}
void MultiPlayerGame::keyE(ALL *allegro) {
    if (modeEnum == NORMAL) {
        if (!(tilesDeck[character->getCardIndex()]->isTurned())) {
            if (!tilesDeck[character->getCardIndex()]->haveSand()) {
                if (character->dig()) {
                    al_play_sample(allegro->excavateSound, allegro->volume, 0, 1, ALLEGRO_PLAYMODE_ONCE, NULL);
                    tilesDeck[character->getCardIndex()]->turnTile();
                    performTileAction(tilesDeck[character->getCardIndex()]->gettileType(), character->getCardIndex(),
                                      allegro);
                    gamePack.excavate();
                    gamePack.sendPack();
                    gamePack.waitForAck(allegro);
                }
            }
        }
    }
}
void MultiPlayerGame::keyP(ALL *allegro) {
    if (modeEnum == NORMAL) {
        pickUpAction();
        gamePack.pickup();
        gamePack.sendPack();
        gamePack.waitForAck(allegro);
    }
}
void MultiPlayerGame::keyR(ALL *allegro) {
    if (modeEnum == REMOVESAND) {
        if (tilesDeck[character->getCardIndex()]->haveSand()) {
            if (character->removeSand()) {
                if (ArcheologistCharacter *explorerCharacter = dynamic_cast<ArcheologistCharacter *>(character)) {
                    if (tilesDeck[character->getCardIndex()]->haveSand()) {
                        tilesDeck[character->getCardIndex()]->removeSand();
                        SandMarkersLeft++;
                        cout << "Sand Marker ++" << endl;
                    }
                }
                tilesDeck[character->getCardIndex()]->removeSand();
                SandMarkersLeft++;
                cout << "Sand Marker ++" << endl;
                gamePack.remove(character->getRow(), character->getColumn());
                gamePack.sendPack();
                gamePack.waitForAck(allegro);
            }
        }
    }
}

void MultiPlayerGame::chooseOption(ALL *allegro, Container temp) {
    ALLEGRO_EVENT ev;
    ALLEGRO_EVENT_QUEUE *tempQueue;
    Button *disagreeButton, *agreeButton;
    if (tempQueue = al_create_event_queue()) {
        al_register_event_source(tempQueue, al_get_mouse_event_source());
        if (ALLEGRO_BITMAP *offsetImage = al_load_bitmap_resized("Resources/Buttons/agreeButton.png", allegro)) {
            disagreeButton = new Button((int) allegro->screenWidth * 0.55, (int) allegro->screenHeight * 0.52,
                                        "Resources/Buttons/disagreeButton.png",
                                        "Resources/Buttons/disagreeButtonSelected.png", allegro);
            agreeButton = new Button((int) allegro->screenWidth * 0.45 - al_get_bitmap_width(offsetImage),
                                     (int) allegro->screenHeight * 0.52, "Resources/Buttons/agreeButton.png",
                                     "Resources/Buttons/agreeButtonSelected.png", allegro);
            al_destroy_bitmap(offsetImage);
            al_draw_bitmap(allegro->menuBackgroundImage, 0, 0, 0);
            switch (temp.ID) {
                case OFFER_WATER:
                case REQUEST_WATER:
                    if (temp.ID == OFFER_WATER)
                        al_draw_textf(allegro->font, al_map_rgb(WHITE), 0.5 * allegro->screenWidth,
                                      0.45 * allegro->screenHeight, ALLEGRO_ALIGN_CENTRE, "Offer %d waters",
                                      temp.Slot1);
                    else
                        al_draw_textf(allegro->font, al_map_rgb(WHITE), 0.5 * allegro->screenWidth,
                                      0.45 * allegro->screenHeight, ALLEGRO_ALIGN_CENTRE, "Request %d waters",
                                      temp.Slot1);
                    break;
                case OFFER_EQUIPMENT:
                case REQUEST_EQUIPMENT:
                    switch (temp.Slot1) {
                        case DUNEBLAST:
                            if (temp.ID == OFFER_EQUIPMENT)
                                al_draw_text(allegro->font, al_map_rgb(WHITE), 0.5 * allegro->screenWidth,
                                             0.45 * allegro->screenHeight, ALLEGRO_ALIGN_CENTRE, "Offer a duneblast");
                            else
                                al_draw_text(allegro->font, al_map_rgb(WHITE), 0.5 * allegro->screenWidth,
                                             0.45 * allegro->screenHeight, ALLEGRO_ALIGN_CENTRE, "Request a duneblast");
                            break;
                        case JETPACK:
                            if (temp.ID == OFFER_EQUIPMENT)
                                al_draw_text(allegro->font, al_map_rgb(WHITE), 0.5 * allegro->screenWidth,
                                             0.45 * allegro->screenHeight, ALLEGRO_ALIGN_CENTRE, "Offer a jetpack");
                            else
                                al_draw_text(allegro->font, al_map_rgb(WHITE), 0.5 * allegro->screenWidth,
                                             0.45 * allegro->screenHeight, ALLEGRO_ALIGN_CENTRE, "Request a jetpack");
                            break;
                        case SOLARSHIELD:
                            if (temp.ID == OFFER_EQUIPMENT)
                                al_draw_text(allegro->font, al_map_rgb(WHITE), 0.5 * allegro->screenWidth,
                                             0.45 * allegro->screenHeight, ALLEGRO_ALIGN_CENTRE, "Offer a solarshield");
                            else
                                al_draw_text(allegro->font, al_map_rgb(WHITE), 0.5 * allegro->screenWidth,
                                             0.45 * allegro->screenHeight, ALLEGRO_ALIGN_CENTRE,
                                             "Request a solarshield");
                            break;
                        case TERRASCOPE:
                            if (temp.ID == OFFER_EQUIPMENT)
                                al_draw_text(allegro->font, al_map_rgb(WHITE), 0.5 * allegro->screenWidth,
                                             0.45 * allegro->screenHeight, ALLEGRO_ALIGN_CENTRE, "Offer a terrascope");
                            else
                                al_draw_text(allegro->font, al_map_rgb(WHITE), 0.5 * allegro->screenWidth,
                                             0.45 * allegro->screenHeight, ALLEGRO_ALIGN_CENTRE,
                                             "Request a terrascope");
                            break;
                        case SECRETWATERRESERVE:
                            if (temp.ID == OFFER_EQUIPMENT)
                                al_draw_text(allegro->font, al_map_rgb(WHITE), 0.5 * allegro->screenWidth,
                                             0.45 * allegro->screenHeight, ALLEGRO_ALIGN_CENTRE,
                                             "Offer a secret water reserve");
                            else
                                al_draw_text(allegro->font, al_map_rgb(WHITE), 0.5 * allegro->screenWidth,
                                             0.45 * allegro->screenHeight, ALLEGRO_ALIGN_CENTRE,
                                             "Request a secret water reserve");
                            break;
                        case TIMETHROTTLE:
                            if (temp.ID == OFFER_EQUIPMENT)
                                al_draw_text(allegro->font, al_map_rgb(WHITE), 0.5 * allegro->screenWidth,
                                             0.45 * allegro->screenHeight, ALLEGRO_ALIGN_CENTRE,
                                             "Offer a time throttle");
                            else
                                al_draw_text(allegro->font, al_map_rgb(WHITE), 0.5 * allegro->screenWidth,
                                             0.45 * allegro->screenHeight, ALLEGRO_ALIGN_CENTRE,
                                             "Request a time throttle");
                            break;
                    }
                    break;
            }

            bool run = true;
            while (run) {
                agreeButton->updateButton(allegro);
                disagreeButton->updateButton(allegro);
                al_flip_display();
                al_wait_for_event(tempQueue, &ev);
                if (ev.type == ALLEGRO_EVENT_MOUSE_AXES) {
                    mouse.x = ev.mouse.x;
                    mouse.y = ev.mouse.y;
                    agreeButton->checkMouse(mouse.x, mouse.y, allegro->volume);
                    disagreeButton->checkMouse(mouse.x, mouse.y, allegro->volume);
                }
                if (ev.type == ALLEGRO_EVENT_MOUSE_BUTTON_UP) {
                    if (agreeButton->checkMouse(mouse.x, mouse.y, allegro->volume)) {
                        modeEnum = NORMAL;
                        gamePack.agree();
                        gamePack.sendPack();
                        run = false;
                        if (temp.ID == OFFER_WATER) {
                            for (int i = 1; i <= temp.Slot1; i++) {
                                character2->drinkWater();
                                character->addWater();
                            }
                        } else if (temp.ID == REQUEST_WATER) {
                            for (int i = 1; i <= temp.Slot1; i++) {
                                character->drinkWater();
                                character2->addWater();
                            }
                        } else if (temp.ID == OFFER_EQUIPMENT || temp.ID == REQUEST_EQUIPMENT) {
                            switch (temp.Slot1) {
                                case DUNEBLAST:
                                    if (temp.ID == OFFER_EQUIPMENT) {
                                        character->increaseDuneBlaster();
                                        character2->decreaseDuneBlaster();
                                    } else {
                                        character2->increaseDuneBlaster();
                                        character->decreaseDuneBlaster();
                                    }
                                    break;
                                case JETPACK:
                                    if (temp.ID == OFFER_EQUIPMENT) {
                                        character->increaseJetPack();
                                        character2->decreaseJetPack();
                                    } else {
                                        character2->increaseJetPack();
                                        character->decreaseJetPack();
                                    }
                                    break;
                                case SOLARSHIELD:
                                    if (temp.ID == OFFER_EQUIPMENT) {
                                        character->increaseSolarShield();
                                        character2->decreaseSolarShield();
                                    } else {
                                        character2->increaseSolarShield();
                                        character->decreaseSolarShield();
                                    }
                                    break;
                                case TERRASCOPE:
                                    if (temp.ID == OFFER_EQUIPMENT) {
                                        character->increaseTerrascope();
                                        character2->decreaseTerrascope();
                                    } else {
                                        character2->increaseTerrascope();
                                        character->decreaseTerrascope();
                                    }
                                    break;
                                case SECRETWATERRESERVE:
                                    if (temp.ID == OFFER_EQUIPMENT) {
                                        character->increaseWaterReserve();
                                        character2->decreaseWaterReserve();
                                    } else {
                                        character2->increaseWaterReserve();
                                        character->decreaseWaterReserve();
                                    }
                                    break;
                                case TIMETHROTTLE:
                                    if (temp.ID == OFFER_EQUIPMENT) {
                                        character->increaseTimeThrottle();
                                        character2->decreaseTimeThrottle();
                                    } else {
                                        character2->increaseTimeThrottle();
                                        character->decreaseTimeThrottle();
                                    }
                                    break;
                            }
                        }
                    } else if (disagreeButton->checkMouse(mouse.x, mouse.y, allegro->volume)) {
                        modeEnum = NORMAL;
                        if (ClimberCharacter *climberCharacter = dynamic_cast<ClimberCharacter *>(character)) {
                            al_play_sample(allegro->rejectWaterBoySound, allegro->volume, 0, 1, ALLEGRO_PLAYMODE_ONCE,
                                           NULL);    //TODO: HAY FORMA DE SABER SI ES WATER O EQUIP?
                        }
                        if (ArcheologistCharacter *archeologistWater = dynamic_cast<ArcheologistCharacter *>(character)) {
                            al_play_sample(allegro->rejectWaterGirlSound, allegro->volume, 0, 1, ALLEGRO_PLAYMODE_ONCE,
                                           NULL);
                        }
                        if (WaterCarrierCharacter *waterCarrierCharacter = dynamic_cast<WaterCarrierCharacter *>(character)) {
                            al_play_sample(allegro->rejectWaterGirlSound, allegro->volume, 0, 1, ALLEGRO_PLAYMODE_ONCE,
                                           NULL);
                        }
                        if (NavigatorCharacter *navigatorCharacter = dynamic_cast<NavigatorCharacter *>(character)) {
                            al_play_sample(allegro->rejectWaterGirlSound, allegro->volume, 0, 1, ALLEGRO_PLAYMODE_ONCE,
                                           NULL);
                        }
                        if (ExplorerCharacter *explorerCharacter = dynamic_cast<ExplorerCharacter *>(character)) {
                            al_play_sample(allegro->rejectWaterBoySound, allegro->volume, 0, 1, ALLEGRO_PLAYMODE_ONCE,
                                           NULL);
                        }
                        if (MeteorologistCharacter *meteorologistCharacter = dynamic_cast<MeteorologistCharacter *>(character)) {
                            al_play_sample(allegro->rejectWaterBoySound, allegro->volume, 0, 1, ALLEGRO_PLAYMODE_ONCE,
                                           NULL);
                        }
                        gamePack.disagree();
                        gamePack.sendPack();
                        run = false;
                    }
                }
            }
            //al_destroy_event_queue(tempQueue);
        } else { cout << "Couldn't load offsetImage in chooseOption" << endl; }
        al_destroy_event_queue(tempQueue);
        delete agreeButton;
        delete disagreeButton;
    } else { cout << "Could't initialize tempQueue" << endl; }
}

void MultiPlayerGame::click(ALL *allegro) {
    /* Runs the click depending in which state i'm in */
    //Volume Buttons
    if (allegro->volume == 0) {
        if (muteButton->checkMouse(mouse.x, mouse.y, allegro->volume)) {
            allegro->volume = 1;
            al_play_sample(allegro->backgroundMusic, allegro->volume / 2, 0.0, 1.0, ALLEGRO_PLAYMODE_LOOP,
                           &allegro->backgroundMusicID);
        }
    } else {
        if (noMuteButton->checkMouse(mouse.x, mouse.y, allegro->volume)) {
            allegro->volume = 0;
            al_stop_sample(&allegro->backgroundMusicID);
        }
    }
    if (turn) {
        switch (modeEnum) {
            case PEEPMODE:
                clickOnPeepMode(allegro);
                break;
            case JETPACKMODE:
                clickOnJetPackMode(allegro);
                break;
            case TERRASCOPEMODE:
                clickOnTerrascopeMode(allegro);
                break;
            case OFFEREQUIPMENTMODE:
                clickOnOfferEquipmentMode(allegro);
                break;
            case REQUESTEQUIPMENTMODE:
                clickOnRequestEquipmentMode(allegro);
                break;
            case OFFERWATERMODE:
                clickOnOfferWaterMode(allegro);
                break;
            case REQUESTWATERMODE:
                clickOnRequestWaterMode(allegro);
                break;
            default:
                clickOnDefaultMode(allegro);
        }
    }
}
void MultiPlayerGame::clickOnPeepMode(ALL *allegro) {
    /* Click while in peep mode */
    if (MeteorologistCharacter *meteorologistCharacter = dynamic_cast<MeteorologistCharacter *>(character)) {
        if (nextButton->checkMouse(mouse.x, mouse.y, allegro->volume)) { nextPeepStormCard(); }
        if (previousButton->checkMouse(mouse.x, mouse.y, allegro->volume)) { previousPeepStormCard(); }
        if (selectPeepCard->checkMouse(mouse.x, mouse.y, allegro->volume)) {
            for (int i = 0; i < peepOffset; i++) {
                swapStormCards(peepOffset - i - 1, peepOffset - i);
            } //Move the card to the front by saping with each card
            std::rotate(stormCardsDeck.begin(), stormCardsDeck.begin() + 1,
                        stormCardsDeck.end());        //Rotate to take it to the bottom.
            //meteorologistCharacter->peep();
            gamePack.peep(peepOffset);
            gamePack.sendPack();
            gamePack.waitForAck(allegro);
            modeEnum = NORMAL;
            resetPeepOffset();
        }
    } else { cout << "Enter in 'click on peep mode' without being an meteorologist" << endl; }
}
void MultiPlayerGame::clickOnJetPackMode(ALL *allegro) {
    for (int i = 0; i < TILEDECKNUMBER; i++) {
        bool climber = false;
        //The climber's ability doesn't affect movement by Jetpack.
        //if (ClimberCharacter* climberCharacter = dynamic_cast<ClimberCharacter*>(character)) { climber = true; }
        if (tilesDeck[i]->canIMove(false)) {
            if (tilesDeck[i]->checkButton(mouse.x, mouse.y, allegro->volume)) {
                character->setPos(i % 5, i / 5);
                character->increaseMoves();
                al_play_sample(allegro->teleportSound, allegro->volume, 0, 1, ALLEGRO_PLAYMODE_ONCE, NULL);
                //Polonet
                gamePack.playequipment(JETPACK, character->getRow(), character->getColumn());
                gamePack.sendPack();
                gamePack.waitForAck(allegro);
                modeEnum = NORMAL;
            }
        }
    }
}
void MultiPlayerGame::clickOnTerrascopeMode(ALL *allegro) {
    for (int i = 0; i < TILEDECKNUMBER; i++) {
        if (tilesDeck[i]->checkButton(mouse.x, mouse.y, allegro->volume)) {
            int backup = tilesDeck[i]->getSand();
            tilesDeck[i]->turnTerrascopeTile();
            tilesDeck[i]->updateTile(allegro);
            al_flip_display();
            gamePack.playequipment(TERRASCOPE, i % 5, i / 5);
            gamePack.sendPack();
            usleep(3500);
            tilesDeck[i]->setSand(backup);
            tilesDeck[i]->setTurned(false);
            //Polonet
            gamePack.waitForAck(allegro);
            modeEnum = NORMAL;
        }
    }
}
void MultiPlayerGame::clickOnOfferWaterMode(ALL *allegro) {
    for (int i = 0; i < min(character->getWaters(), MAXWATERS - character2->getWaters() - 1); i++) {
        if (watersButton[i]->checkMouse(mouse.x, mouse.y, allegro->volume)) {  // && character->getWaters() > (i + 1)) {
            modeEnum = NORMAL;
            updateScreen(allegro);
            cout << "Send Offer Water" << endl;
            gamePack.offerwater(i + 1);// "+1" Because the array starts with 0.
            gamePack.sendPack();
            char wait;
            do {
                wait = gamePack.receivePack().ID;
                gamePack.cleanBuffer();
            } while (wait != AGREE && wait != DISAGREE);
            if (wait == AGREE) {
                for (int c = 0; c < i + 1; c++) {
                    character->drinkWater();
                    character2->addWater();
                }
            } else { //if disagree, play the not thirsty sound
                if (ClimberCharacter *climberCharacter = dynamic_cast<ClimberCharacter *>(character2)) {
                    al_play_sample(allegro->rejectWaterBoySound, allegro->volume, 0, 1, ALLEGRO_PLAYMODE_ONCE,
                                   NULL);    //TODO: HAY FORMA DE SABER SI ES WATER O EQUIP?
                }
                if (ArcheologistCharacter *archeologistWater = dynamic_cast<ArcheologistCharacter *>(character2)) {
                    al_play_sample(allegro->rejectWaterGirlSound, allegro->volume, 0, 1, ALLEGRO_PLAYMODE_ONCE, NULL);
                }
                if (WaterCarrierCharacter *waterCarrierCharacter = dynamic_cast<WaterCarrierCharacter *>(character2)) {
                    al_play_sample(allegro->rejectWaterGirlSound, allegro->volume, 0, 1, ALLEGRO_PLAYMODE_ONCE, NULL);
                }
                if (NavigatorCharacter *navigatorCharacter = dynamic_cast<NavigatorCharacter *>(character2)) {
                    al_play_sample(allegro->rejectWaterGirlSound, allegro->volume, 0, 1, ALLEGRO_PLAYMODE_ONCE, NULL);
                }
                if (ExplorerCharacter *explorerCharacter = dynamic_cast<ExplorerCharacter *>(character2)) {
                    al_play_sample(allegro->rejectWaterBoySound, allegro->volume, 0, 1, ALLEGRO_PLAYMODE_ONCE, NULL);
                }
                if (MeteorologistCharacter *meteorologistCharacter = dynamic_cast<MeteorologistCharacter *>(character2)) {
                    al_play_sample(allegro->rejectWaterBoySound, allegro->volume, 0, 1, ALLEGRO_PLAYMODE_ONCE, NULL);
                }
            }
        }
    }
}
void MultiPlayerGame::clickOnRequestWaterMode(ALL *allegro) {
    for (int i = 0; i < MAXWATERS; i++) {
        if (watersButton[i]->checkMouse(mouse.x, mouse.y, allegro->volume) && character2->getWaters() > (i + 1)) {
            modeEnum = NORMAL;
            updateScreen(allegro);
            cout << "Send Request Water" << endl;
            gamePack.requestwater(i + 1);// "+1" Because the array starts with 0.
            gamePack.sendPack();
            //Polonet
            char wait;
            //al_start_timer(allegro->timeout);
            do {
                wait = gamePack.receivePack().ID;
                gamePack.cleanBuffer();
            } while (wait != AGREE && wait != DISAGREE);
            if (wait == AGREE) {
                for (int c = 0; c < i + 1; c++) {
                    character2->drinkWater();
                    character->addWater();
                }
            }
        }
    }
}
void MultiPlayerGame::clickOnOfferEquipmentMode(ALL *allegro) {
    if (nextButton->checkMouse(mouse.x, mouse.y, allegro->volume)) { nextEquipCard(); }
    if (previousButton->checkMouse(mouse.x, mouse.y, allegro->volume)) { previousEquipCard(); }
    if (selectEquipmentCard->checkMouse(mouse.x, mouse.y, allegro->volume)) {
        modeEnum = NORMAL;
        updateScreen(allegro);
        gamePack.offerequipment(equipOffset);
        gamePack.sendPack();
        char wait;
        do {
            wait = gamePack.receivePack().ID;
            gamePack.cleanBuffer();
        } while (wait != AGREE && wait != DISAGREE);
        if (wait == AGREE) {
            switch (equipOffset) {
                case DUNEBLAST:
                    character->decreaseDuneBlaster();
                    character2->increaseDuneBlaster();
                    break;
                case JETPACK:
                    character->decreaseJetPack();
                    character2->increaseJetPack();
                    break;
                case SOLARSHIELD:
                    character->decreaseSolarShield();
                    character2->increaseSolarShield();
                    break;
                case TERRASCOPE:
                    character->decreaseTerrascope();
                    character2->increaseTerrascope();
                    break;
                case SECRETWATERRESERVE:
                    character->decreaseWaterReserve();
                    character2->increaseWaterReserve();
                    break;
                case TIMETHROTTLE:
                    character->decreaseTimeThrottle();
                    character2->increaseTimeThrottle();
                    break;
            }
        } else {
            if (ClimberCharacter *climberCharacter = dynamic_cast<ClimberCharacter *>(character2)) {
                al_play_sample(allegro->rejectEquipmentBoySound, allegro->volume, 0, 1, ALLEGRO_PLAYMODE_ONCE,
                               NULL);    //TODO: HAY FORMA DE SABER SI ES WATER O EQUIP?
            }
            if (ArcheologistCharacter *archeologistWater = dynamic_cast<ArcheologistCharacter *>(character2)) {
                al_play_sample(allegro->rejectEquipmentGirlSound, allegro->volume, 0, 1, ALLEGRO_PLAYMODE_ONCE, NULL);
            }
            if (WaterCarrierCharacter *waterCarrierCharacter = dynamic_cast<WaterCarrierCharacter *>(character2)) {
                al_play_sample(allegro->rejectEquipmentGirlSound, allegro->volume, 0, 1, ALLEGRO_PLAYMODE_ONCE, NULL);
            }
            if (NavigatorCharacter *navigatorCharacter = dynamic_cast<NavigatorCharacter *>(character2)) {
                al_play_sample(allegro->rejectEquipmentGirlSound, allegro->volume, 0, 1, ALLEGRO_PLAYMODE_ONCE, NULL);
            }
            if (ExplorerCharacter *explorerCharacter = dynamic_cast<ExplorerCharacter *>(character2)) {
                al_play_sample(allegro->rejectEquipmentBoySound, allegro->volume, 0, 1, ALLEGRO_PLAYMODE_ONCE, NULL);
            }
            if (MeteorologistCharacter *meteorologistCharacter = dynamic_cast<MeteorologistCharacter *>(character2)) {
                al_play_sample(allegro->rejectEquipmentBoySound, allegro->volume, 0, 1, ALLEGRO_PLAYMODE_ONCE, NULL);
            }
        }
    }
}
void MultiPlayerGame::clickOnRequestEquipmentMode(ALL *allegro) {
    if (nextButton->checkMouse(mouse.x, mouse.y, allegro->volume)) { nextEquipCard(); }
    if (previousButton->checkMouse(mouse.x, mouse.y, allegro->volume)) { previousEquipCard(); }
    if (selectEquipmentCard->checkMouse(mouse.x, mouse.y, allegro->volume)) {
        modeEnum = NORMAL;
        updateScreen(allegro);
        gamePack.requestequipment(equipOffset);
        gamePack.sendPack();
        char wait;
        do {
            wait = gamePack.receivePack().ID;
            gamePack.cleanBuffer();
        } while (wait != AGREE && wait != DISAGREE);
        if (wait == AGREE) {
            switch (equipOffset) {
                case DUNEBLAST:
                    character2->decreaseDuneBlaster();
                    character->increaseDuneBlaster();
                    break;
                case JETPACK:
                    character2->decreaseJetPack();
                    character->increaseJetPack();
                    break;
                case SOLARSHIELD:
                    character2->decreaseSolarShield();
                    character->increaseSolarShield();
                    break;
                case TERRASCOPE:
                    character2->decreaseTerrascope();
                    character->increaseTerrascope();
                    break;
                case SECRETWATERRESERVE:
                    character2->decreaseWaterReserve();
                    character->increaseWaterReserve();
                    break;
                case TIMETHROTTLE:
                    character2->decreaseTimeThrottle();
                    character->increaseTimeThrottle();
                    break;
            }
        }
    }
}
void MultiPlayerGame::clickOnDefaultMode(ALL *allegro) {
    clickModesButtons(allegro);
    clickEquipmentButtons(allegro);
    clickTilesButtons(allegro);
    /*if (tilesDeck[character->getCardIndex()]->checkButton(mouse.x, mouse.y, allegro->volume)) {
		keyR(allegro);
		modeEnum = NORMAL;
	}*/
    if (endTurnButton->checkMouse(mouse.x, mouse.y,
                                  allegro->volume)) {            //If there whas a selected character, then return true, else return false
        al_play_sample(allegro->clickOnButtonSound, allegro->volume, 0, 1, ALLEGRO_PLAYMODE_ONCE, NULL);
        gamePack.pass();
        gamePack.sendPack();
        gamePack.waitForAck(allegro);
        drawStormCards(allegro);
        character->resetNumberOfMoves();        //This has to go after draw cards. Because if you are a meteorologist you may be able to draw fewer cards.
        character2->resetNumberOfMoves();
        turn = !turn;
        character2->shield = false;
    }
    if (MeteorologistCharacter *meteorologistCharacter = dynamic_cast<MeteorologistCharacter *>(character)) {
        if (meteorologistCharacter->checkMouseOverButton(mouse.x, mouse.y, allegro->volume)) {
            al_play_sample(allegro->clickOnButtonSound, allegro->volume, 0, 1, ALLEGRO_PLAYMODE_ONCE, NULL);
            cout << "PEEP" << endl;
            if (meteorologistCharacter->peep()) {
                modeEnum = PEEPMODE;
                peepOffset = 0;
                firstTimeUpdateScreenPeep = 0;
            }
        }
    } else if (ClimberCharacter *climberCharacter = dynamic_cast<ClimberCharacter *>(character)) {
        climberCharacter->clickOnButton(mouse.x, mouse.y, allegro->volume);
    } else if (WaterCarrierCharacter *waterCarrierCharacter = dynamic_cast<WaterCarrierCharacter *>(character)) {
        if (tilesDeck[character->getCardIndex()]->gettileType() == WATER &&
            tilesDeck[character->getCardIndex()]->isTurned()) {
            if (waterCarrierCharacter->checkMouseOverButton(mouse.x, mouse.y, allegro->volume)) {
                al_play_sample(allegro->clickOnButtonSound, allegro->volume, 0, 1, ALLEGRO_PLAYMODE_ONCE, NULL);
                waterCarrierCharacter->getWatersFromWell();
                al_play_sample(allegro->waterSound, allegro->volume, 0, 1, ALLEGRO_PLAYMODE_ONCE, NULL);
                gamePack.takewater();
                gamePack.sendPack();
                gamePack.waitForAck(allegro);
            }
        }
    } else if (NavigatorCharacter *navigatorCharacter = dynamic_cast<NavigatorCharacter *>(character)) {
        if (navigatorCharacter->checkMouseOverButton(mouse.x, mouse.y, modeEnum == MOVEOTHER, allegro->volume)) {
            cout << "Click on special navigator button" << endl;
            al_play_sample(allegro->clickOnButtonSound, allegro->volume, 0, 1, ALLEGRO_PLAYMODE_ONCE, NULL);
            if (modeEnum == MOVEOTHER) {
                modeEnum = NORMAL;
                character2->resetNumberOfMoves();
                navigatorCharacter->decreseMoves();
            } else {
                if (navigatorCharacter->haveMoves()) {
                    modeEnum = MOVEOTHER;
                    navigatorCharacter->resetPartnerMoves();
                    character2->resetNumberOfMoves();    //I reset them to be able to move him
                }
            }
        }
    }
}
void MultiPlayerGame::clickTilesButtons(ALL *allegro) {
    if (modeEnum != MOVEOTHER) {
        // Click on the tile I'm on
        if (turn &&
            (tilesDeck[character->getCardIndex()]->haveSand() || !tilesDeck[character->getCardIndex()]->isTurned())) {
            if (tilesDeck[character->getCardIndex()]->checkButton(mouse.x, mouse.y, allegro->volume)) {
                if (modeEnum == DUNEBLASTERMODE) {
                    while (tilesDeck[character->getCardIndex()]->haveSand()) {
                        tilesDeck[character->getCardIndex()]->removeSand();
                        SandMarkersLeft++;
                        cout << "Sand Marker ++" << endl;
                    }
                    gamePack.playequipment(DUNEBLAST, character->getRow(), character->getColumn());
                    gamePack.sendPack();
                    gamePack.waitForAck(allegro);
                } else if (tilesDeck[character->getCardIndex()]->haveSand()) {
                    if (character->removeSand()) {
                        tilesDeck[character->getCardIndex()]->removeSand();
                        SandMarkersLeft++;
                        cout << "Sand Marker ++" << endl;
                        if (ArcheologistCharacter *archeologistCharacter = dynamic_cast<ArcheologistCharacter *>(character)) {
                            if (tilesDeck[character->getCardIndex()]->haveSand()) {
                                tilesDeck[character->getCardIndex()]->removeSand();
                                SandMarkersLeft++;
                                cout << "Sand Marker ++" << endl;
                            }
                        }
                        gamePack.remove(character->getRow(), character->getColumn());
                        gamePack.sendPack();
                        gamePack.waitForAck(allegro);
                    }
                } else {
                    if (!(tilesDeck[character->getCardIndex()]->isTurned()))
                        if (character->dig()) {
                            al_play_sample(allegro->excavateSound, allegro->volume, 0, 1, ALLEGRO_PLAYMODE_ONCE, NULL);
                            tilesDeck[character->getCardIndex()]->turnTile();
                            performTileAction(tilesDeck[character->getCardIndex()]->gettileType(),
                                              character->getCardIndex(), allegro);
                            gamePack.excavate();
                            gamePack.sendPack();
                            gamePack.waitForAck(allegro);
                        }
                }
            }
        }
        //Click on Adyacent Tiles
        if (character->getCardIndex() > 0) {
            if (tilesDeck[character->getCardIndex() - 1]->checkButton(mouse.x, mouse.y, allegro->volume)) {
                keyUp(allegro);
                modeEnum = NORMAL;
            }
        }
        if (character->getCardIndex() < TILEDECKNUMBER - 1) {
            if (tilesDeck[character->getCardIndex() + 1]->checkButton(mouse.x, mouse.y, allegro->volume)) {
                keyDown(allegro);
                modeEnum = NORMAL;
            }
        }
        if (character->getCardIndex() > 4) {
            if (tilesDeck[character->getCardIndex() - 5]->checkButton(mouse.x, mouse.y, allegro->volume)) {
                keyLeft(allegro);
                modeEnum = NORMAL;
            }
        }
        if (character->getCardIndex() < TILEDECKNUMBER - 5) {
            if (tilesDeck[character->getCardIndex() + 5]->checkButton(mouse.x, mouse.y, allegro->volume)) {
                keyRight(allegro);
                modeEnum = NORMAL;
            }
        }
        //Tunnel Tile
        bool climber = false;
        if (ClimberCharacter *climberCharacter = dynamic_cast<ClimberCharacter *>(character)) { climber = true; }
        if (tilesDeck[character->getCardIndex()]->gettileType() == TUNNEL &&
            tilesDeck[character->getCardIndex()]->isTurned()) {
            for (uint i = 0; i < tilesDeck.size(); i++) {
                if (tilesDeck[i]->gettileType() == TUNNEL && i != character->getCardIndex() &&
                    tilesDeck[i]->isTurned()) { //TUNNEL not the same I'm in, it's discovered
                    if (tilesDeck[i]->canIMove(climber)) {
                        if (tilesDeck[i]->checkButton(mouse.x, mouse.y, allegro->volume)) {
                            character->setPos(i % 5, i / 5);
                            gamePack.move(character->getRow(), character->getColumn());
                            gamePack.sendPack();
                            gamePack.waitForAck(allegro);
                        }
                    }
                }
            }
        }
        //If I'm Explorer, click on diagonally adyacent tiles
        if (ExplorerCharacter *explorerCharacter = dynamic_cast<ExplorerCharacter *>(character)) {
            bool climber = false;
            if (ClimberCharacter *explorerCharacter = dynamic_cast<ClimberCharacter *>(character)) {
                climber = true;
                cout << "Error: character is both explorer and climber" << endl;
            }
            if (character->getCardIndex() > 5 && character->getCardIndex() % 5 != 0) {
                if (tilesDeck[character->getCardIndex() - 6]->checkButton(mouse.x, mouse.y, allegro->volume)) {
                    if (modeEnum == NORMAL) {
                        if (tilesDeck[character->getCardIndex() - 6]->canIMove(
                                climber)) {    //Here climber will always be false
                            explorerCharacter->moveUpLeftDiagonally();
                            gamePack.move(character->getRow(), character->getColumn());
                            gamePack.sendPack();
                            gamePack.waitForAck(allegro);
                        }
                    } else if (modeEnum == REMOVESAND) {
                        if (tilesDeck[character->getCardIndex() - 6]->haveSand()) {
                            if (character->removeSand()) { //this time there is no need to check if its an archeologist because its an explorer
                                tilesDeck[character->getCardIndex() - 6]->removeSand();
                                SandMarkersLeft++;
                                cout << "Sand Marker ++" << endl;
                                gamePack.remove(character->getRow() - 1, character->getColumn() - 1);
                                gamePack.sendPack();
                                gamePack.waitForAck(allegro);
                            }
                        }
                    } else if (modeEnum == DUNEBLASTERMODE) {
                        while (tilesDeck[character->getCardIndex() - 6]->haveSand()) {
                            tilesDeck[character->getCardIndex() - 6]->removeSand();
                            SandMarkersLeft++;
                            cout << "Sand Marker ++" << endl;
                        }
                        gamePack.playequipment(DUNEBLAST, character->getRow() - 1, character->getColumn() - 1);
                        gamePack.sendPack();
                        gamePack.waitForAck(allegro);
                    }
                    modeEnum = NORMAL;
                }
            }
            if (character->getCardIndex() > 4 && character->getCardIndex() % 5 != 4) {
                if (tilesDeck[character->getCardIndex() - 4]->checkButton(mouse.x, mouse.y, allegro->volume)) {
                    if (modeEnum == NORMAL) {
                        if (tilesDeck[character->getCardIndex() - 4]->canIMove(climber)) {
                            explorerCharacter->moveDownLeftDiagonally();
                            gamePack.move(character->getRow(), character->getColumn());
                            gamePack.sendPack();
                            //Polonet
                            gamePack.waitForAck(allegro);
                        }
                    } else if (modeEnum == REMOVESAND) {
                        if (tilesDeck[character->getCardIndex() - 4]->haveSand()) {
                            if (character->removeSand()) {
                                tilesDeck[character->getCardIndex() - 4]->removeSand();
                                SandMarkersLeft++;
                                cout << "Sand Marker ++" << endl;
                                gamePack.remove(character->getRow(), character->getColumn() + 1);
                                gamePack.sendPack();
                                gamePack.waitForAck(allegro);
                            }
                        }

                    } else if (modeEnum == DUNEBLASTERMODE) {
                        while (tilesDeck[character->getCardIndex() - 4]->haveSand()) {
                            tilesDeck[character->getCardIndex() - 4]->removeSand();
                            SandMarkersLeft++;
                            cout << "Sand Marker ++" << endl;
                        }
                        gamePack.playequipment(DUNEBLAST, character->getRow() + 1, character->getColumn() - 1);
                        gamePack.sendPack();
                        gamePack.waitForAck(allegro);
                    }
                    modeEnum = NORMAL;
                }
            }
            if (character->getCardIndex() < TILEDECKNUMBER - 4 && character->getCardIndex() % 5 != 0) {
                if (tilesDeck[character->getCardIndex() + 4]->checkButton(mouse.x, mouse.y, allegro->volume)) {
                    if (modeEnum == NORMAL) {
                        if (tilesDeck[character->getCardIndex() + 4]->canIMove(climber)) {
                            explorerCharacter->moveUpRightDiagonally();
                            gamePack.move(character->getRow(), character->getColumn());
                            gamePack.sendPack();
                            gamePack.waitForAck(allegro);
                        }
                    } else if (modeEnum == REMOVESAND) {
                        if (tilesDeck[character->getCardIndex() + 4]->haveSand()) {
                            if (character->removeSand()) {
                                tilesDeck[character->getCardIndex() + 4]->removeSand();
                                SandMarkersLeft++;
                                cout << "Sand Marker ++" << endl;
                                gamePack.remove(character->getRow(), character->getColumn() + 1);
                                gamePack.sendPack();
                                gamePack.waitForAck(allegro);
                            }
                        }
                    } else if (modeEnum == DUNEBLASTERMODE) {
                        while (tilesDeck[character->getCardIndex() + 4]->haveSand()) {
                            tilesDeck[character->getCardIndex() + 4]->removeSand();
                            SandMarkersLeft++;
                            cout << "Sand Marker ++" << endl;
                        }
                        gamePack.playequipment(DUNEBLAST, character->getRow() - 1, character->getColumn() + 1);
                        gamePack.sendPack();
                        gamePack.waitForAck(allegro);
                    }
                    modeEnum = NORMAL;
                }
            }
            if (character->getCardIndex() < TILEDECKNUMBER - 6 && character->getCardIndex() % 5 != 4) {
                if (tilesDeck[character->getCardIndex() + 6]->checkButton(mouse.x, mouse.y, allegro->volume)) {
                    if (modeEnum == NORMAL) {
                        if (tilesDeck[character->getCardIndex() + 6]->canIMove(climber)) {
                            explorerCharacter->moveDownRightDiagonally();
                            gamePack.move(character->getRow(), character->getColumn());
                            gamePack.sendPack();
                            gamePack.waitForAck(allegro);
                        }
                    } else if (modeEnum == REMOVESAND) {
                        if (tilesDeck[character->getCardIndex() + 6]->haveSand()) {
                            if (character->removeSand()) {
                                tilesDeck[character->getCardIndex() + 6]->removeSand();
                                SandMarkersLeft++;
                                cout << "Sand Marker ++" << endl;
                                gamePack.remove(character->getRow(), character->getColumn() + 1);
                                gamePack.sendPack();
                                gamePack.waitForAck(allegro);
                            }
                        }
                    } else if (modeEnum == DUNEBLASTERMODE) {
                        while (tilesDeck[character->getCardIndex() + 6]->haveSand()) {
                            tilesDeck[character->getCardIndex() + 6]->removeSand();
                            SandMarkersLeft++;
                            cout << "Sand Marker ++" << endl;
                        }
                        gamePack.playequipment(DUNEBLAST, character->getRow() + 1, character->getColumn() + 1);
                        gamePack.sendPack();
                        gamePack.waitForAck(allegro);
                    }
                    modeEnum = NORMAL;
                }
            }
        }
    } else {
        //Click on Adyacent Tiles
        if (character2->getCardIndex() > 0) {
            if (tilesDeck[character2->getCardIndex() - 1]->checkButton(mouse.x, mouse.y, allegro->volume)) {
                keyUp(allegro);
            }
        }
        if (character2->getCardIndex() < TILEDECKNUMBER - 1) {
            if (tilesDeck[character2->getCardIndex() + 1]->checkButton(mouse.x, mouse.y, allegro->volume)) {
                keyDown(allegro);
            }
        }
        if (character2->getCardIndex() > 4) {
            if (tilesDeck[character2->getCardIndex() - 5]->checkButton(mouse.x, mouse.y, allegro->volume)) {
                keyLeft(allegro);
            }
        }
        if (character2->getCardIndex() < TILEDECKNUMBER - 5) {
            if (tilesDeck[character2->getCardIndex() + 5]->checkButton(mouse.x, mouse.y, allegro->volume)) {
                keyRight(allegro);
            }
        }
        //Tunnel Tile
        bool climber = false;
        if (ClimberCharacter *climberCharacter = dynamic_cast<ClimberCharacter *>(character2)) { climber = true; }
        if (tilesDeck[character2->getCardIndex()]->gettileType() == TUNNEL &&
            tilesDeck[character2->getCardIndex()]->isTurned()) {
            for (uint i = 0; i < tilesDeck.size(); i++) {
                if (tilesDeck[i]->gettileType() == TUNNEL && i != character2->getCardIndex() &&
                    tilesDeck[i]->isTurned()) {
                    if (tilesDeck[i]->canIMove(climber)) {
                        if (tilesDeck[i]->checkButton(mouse.x, mouse.y, allegro->volume)) {
                            character2->setPos(i % 5, i / 5);
                            gamePack.requestmove(character2->getRow(), character2->getColumn());
                            gamePack.sendPack();
                            gamePack.waitForAck(allegro);
                        }
                    }
                }
            }
        }
        //If I'm Explorer, click on diagonally adyacent tiles
        if (ExplorerCharacter *explorerCharacter = dynamic_cast<ExplorerCharacter *>(character2)) {
            if (NavigatorCharacter *navigatorCharacter = dynamic_cast<NavigatorCharacter *>(character)) {
                bool climber = false;
                if (ClimberCharacter *explorerCharacter = dynamic_cast<ClimberCharacter *>(character2)) {
                    climber = true;
                    cout << "Error: character is both explorer and climber" << endl;
                }
                if (character2->getCardIndex() > 5 && character2->getCardIndex() % 5 != 0) {
                    if (tilesDeck[character2->getCardIndex() - 6]->checkButton(mouse.x, mouse.y, allegro->volume)) {
                        if (navigatorCharacter->havePartnersMovesLeft()) {
                            if (tilesDeck[character2->getCardIndex() - 6]->canIMove(
                                    climber)) {    //Here climber will always be false
                                explorerCharacter->moveUpLeftDiagonally();
                                navigatorCharacter->decresePartnerMoves();
                                //Conection
                            }
                        }
                    }
                }
                if (character2->getCardIndex() > 4 && character2->getCardIndex() % 5 != 4) {
                    if (tilesDeck[character2->getCardIndex() - 4]->checkButton(mouse.x, mouse.y, allegro->volume)) {
                        if (navigatorCharacter->havePartnersMovesLeft()) {
                            if (tilesDeck[character2->getCardIndex() - 4]->canIMove(climber)) {
                                explorerCharacter->moveDownLeftDiagonally();
                                navigatorCharacter->decresePartnerMoves();
                            }
                        }
                    }
                }
                if (character2->getCardIndex() < TILEDECKNUMBER - 4 && character2->getCardIndex() % 5 != 0) {
                    if (tilesDeck[character2->getCardIndex() + 4]->checkButton(mouse.x, mouse.y, allegro->volume)) {
                        if (navigatorCharacter->havePartnersMovesLeft()) {
                            if (tilesDeck[character2->getCardIndex() + 4]->canIMove(climber)) {
                                explorerCharacter->moveUpRightDiagonally();
                                navigatorCharacter->decresePartnerMoves();
                            }
                        }
                    }
                }
                if (character2->getCardIndex() < TILEDECKNUMBER - 6 && character->getCardIndex() % 5 != 4) {
                    if (tilesDeck[character2->getCardIndex() + 6]->checkButton(mouse.x, mouse.y, allegro->volume)) {
                        if (navigatorCharacter->havePartnersMovesLeft()) {
                            if (tilesDeck[character2->getCardIndex() + 6]->canIMove(climber)) {
                                explorerCharacter->moveDownRightDiagonally();
                                navigatorCharacter->decresePartnerMoves();
                            }
                        }
                    }
                }
            }
        }
    }
}
void MultiPlayerGame::clickModesButtons(ALL *allegro) {
    if (modesButtons[REMOVEBUTTON]->checkMouse(mouse.x, mouse.y, allegro->volume)) {
        cout << "Remove Sand Button Clicked" << endl;
        al_play_sample(allegro->clickOnButtonSound, allegro->volume, 0, 1, ALLEGRO_PLAYMODE_ONCE, NULL);
        if (modeEnum == REMOVESAND) {
            if (tilesDeck[character->getCardIndex()]->haveSand()) {
                if (character->removeSand()) {
                    tilesDeck[character->getCardIndex()]->removeSand();
                    if (ArcheologistCharacter *explorerCharacter = dynamic_cast<ArcheologistCharacter *>(character)) {
                        if (tilesDeck[character->getCardIndex()]->haveSand()) {
                            tilesDeck[character->getCardIndex()]->removeSand();
                            SandMarkersLeft++;
                            cout << "Sand Marker ++" << endl;
                        }
                    }
                    SandMarkersLeft++;
                    cout << "Sand Marker ++" << endl;
                    gamePack.remove(character->getRow(), character->getColumn());
                    gamePack.sendPack();
                    gamePack.waitForAck(allegro);
                }
            }
            modeEnum = NORMAL;
        } else { modeEnum = REMOVESAND; }
    } else if (modesButtons[EXCAVATEBUTTON]->checkMouse(mouse.x, mouse.y,
                                                        allegro->volume)) {    //I use else if because it will take less time for the computer to check the buttons
        cout << "Excavate Button Clicked" << endl;
        al_play_sample(allegro->clickOnButtonSound, allegro->volume, 0, 1, ALLEGRO_PLAYMODE_ONCE, NULL);
        keyE(allegro);
        modeEnum = NORMAL;
    } else if (modesButtons[PICKUPBUTTON]->checkMouse(mouse.x, mouse.y, allegro->volume)) {
        cout << "Pick Up Part Button Clicked" << endl;
        al_play_sample(allegro->clickOnButtonSound, allegro->volume, 0, 1, ALLEGRO_PLAYMODE_ONCE, NULL);
        keyP(allegro);
        modeEnum = NORMAL;
    } else if (modesButtons[OFFERWBUTTON]->checkMouse(mouse.x, mouse.y, allegro->volume)) {
        cout << "Offer Water Button Clicked" << endl;
        al_play_sample(allegro->clickOnButtonSound, allegro->volume, 0, 1, ALLEGRO_PLAYMODE_ONCE, NULL);
        if (WaterCarrierCharacter *waterCarrierCharacter = dynamic_cast<WaterCarrierCharacter *>(character)) {
            if (character->getRow() == character2->getRow()) {
                if (character2->getColumn() >= character->getColumn() - 1 &&
                    character2->getColumn() <= character->getColumn() + 1) {
                    if (min(character->getWaters(), MAXWATERS - character2->getWaters() - 1) !=
                        0) { modeEnum = OFFERWATERMODE; }
                }
            } else if (character->getColumn() == character2->getColumn()) {
                if (character2->getColumn() == character->getColumn() - 1 ||
                    character2->getColumn() == character->getColumn() + 1) {
                    if (min(character->getWaters(), MAXWATERS - character2->getWaters() - 1) !=
                        0) { modeEnum = OFFERWATERMODE; }
                }
            }
        } else if (character->getRow() == character2->getRow() && character->getColumn() == character2->getColumn()) {
            if (min(character->getWaters(), MAXWATERS - character2->getWaters() - 1) !=
                0) { modeEnum = OFFERWATERMODE; }
        }
    } else if (modesButtons[OFFEREBUTTON]->checkMouse(mouse.x, mouse.y, allegro->volume)) {
        cout << "Offer Equipment Button Clicked" << endl;
        al_play_sample(allegro->clickOnButtonSound, allegro->volume, 0, 1, ALLEGRO_PLAYMODE_ONCE, NULL);
        //if the player does not have any equipment...
        if (character->getCardIndex() == character2->getCardIndex()) {
            if (character->haveDuneBlaster() || character->haveJetPack() || character->haveSolarShield() ||
                character->haveTerrascope() || character->haveTimeThrottle()) {
                modeEnum = OFFEREQUIPMENTMODE;
                firstTimeUpdateScreenChooseEquipment = 0;
            }
        }
    } else if (modesButtons[REQUESTWBUTTON]->checkMouse(mouse.x, mouse.y, allegro->volume)) {
        al_play_sample(allegro->clickOnButtonSound, allegro->volume, 0, 1, ALLEGRO_PLAYMODE_ONCE, NULL);
        if (WaterCarrierCharacter *waterCarrierCharacter = dynamic_cast<WaterCarrierCharacter *>(character2)) {
            if (character->getRow() == character2->getRow()) {
                if (character->getColumn() >= character2->getColumn() - 1 &&
                    character->getColumn() <= character2->getColumn() + 1) {
                    if (min(character2->getWaters(), MAXWATERS - character->getWaters() - 1) !=
                        0) { modeEnum = REQUESTWATERMODE; }
                }
            } else if (character->getColumn() == character2->getColumn()) {
                if (character2->getColumn() == character->getColumn() - 1 ||
                    character2->getColumn() == character->getColumn() + 1) {
                    if (min(character2->getWaters(), MAXWATERS - character->getWaters() - 1) !=
                        0) { modeEnum = REQUESTWATERMODE; }
                }
            }
        } else if (character->getColumn() == character2->getColumn() && character->getRow() == character2->getRow()) {
            if (min(character2->getWaters(), MAXWATERS - character->getWaters() - 1) !=
                0) { modeEnum = REQUESTWATERMODE; }
        }
    } else if (modesButtons[REQUESTEBUTTON]->checkMouse(mouse.x, mouse.y, allegro->volume)) {
        al_play_sample(allegro->clickOnButtonSound, allegro->volume, 0, 1, ALLEGRO_PLAYMODE_ONCE, NULL);
        if (character->getCardIndex() == character2->getCardIndex()) {
            if (character2->haveDuneBlaster() || character2->haveJetPack() || character2->haveSolarShield() ||
                character2->haveTerrascope() || character2->haveTimeThrottle()) {
                modeEnum = REQUESTEQUIPMENTMODE;
                firstTimeUpdateScreenChooseEquipment = 0;
            }
        }
    }
}
void MultiPlayerGame::checkTilesButtons(double volume) { //TODO: cuando el jetPack actualiza todos los tiles tendrÃ­a que ser acÃ¡.
    int tempIndex;
    bool climber = false;
    if (modeEnum == MOVEOTHER) {
        tempIndex = character2->getCardIndex();
        if (ClimberCharacter *climberCharacter = dynamic_cast<ClimberCharacter *>(character2)) { climber = true; }
    } else {
        tempIndex = character->getCardIndex();
        if (turn && (tilesDeck[tempIndex]->haveSand() || !tilesDeck[tempIndex]->isTurned())) {
            tilesDeck[tempIndex]->checkButton(mouse.x, mouse.y, volume);
        }
        if (ClimberCharacter *climberCharacter = dynamic_cast<ClimberCharacter *>(character)) { climber = true; }
    }
    if (turn && tilesDeck[tempIndex]->canIMove(climber)) {
        if (modeEnum == NORMAL || modeEnum == MOVEOTHER) {
            if (tempIndex > 0) {
                if (tilesDeck[tempIndex - 1]->canIMove(climber) && tempIndex % 5 != 0) {
                    tilesDeck[tempIndex - 1]->checkButton(mouse.x, mouse.y, volume);
                }
            }
            if (tempIndex < TILEDECKNUMBER - 1) {
                if (tilesDeck[tempIndex + 1]->canIMove(climber) && tempIndex % 5 != 4) {
                    tilesDeck[tempIndex + 1]->checkButton(mouse.x, mouse.y, volume);
                }
            }
            if (tempIndex > 4) {
                if (tilesDeck[tempIndex - 5]->canIMove(climber)) {
                    tilesDeck[tempIndex - 5]->checkButton(mouse.x, mouse.y, volume);
                }
            }
            if (tempIndex < TILEDECKNUMBER - 5) {
                if (tilesDeck[tempIndex + 5]->canIMove(climber)) {
                    tilesDeck[tempIndex + 5]->checkButton(mouse.x, mouse.y, volume);
                }
            }
            //Tunnel Tile
            if (tilesDeck[tempIndex]->gettileType() == TUNNEL && tilesDeck[tempIndex]->isTurned()) {
                for (uint i = 0; i < tilesDeck.size(); i++) {
                    if (tilesDeck[i]->gettileType() == TUNNEL && i != tempIndex && tilesDeck[i]->isTurned()) {
                        if (tilesDeck[i]->canIMove(climber)) { tilesDeck[i]->checkButton(mouse.x, mouse.y, volume); }
                    }
                }
            }
            // Explorer Move Diagonally
            if (modeEnum == NORMAL) {
                if (ExplorerCharacter *explorerCharacter = dynamic_cast<ExplorerCharacter *>(character)) { //TODO: fix this for character2
                    if (tempIndex > 5 && tempIndex % 5 != 0) {
                        if (tilesDeck[tempIndex - 6]->canIMove(climber)) {
                            tilesDeck[tempIndex - 6]->checkButton(mouse.x, mouse.y, volume);
                        }
                    }
                    if (tempIndex > 5 && tempIndex % 5 != 4) {
                        if (tilesDeck[tempIndex - 4]->canIMove(climber)) {
                            tilesDeck[tempIndex - 4]->checkButton(mouse.x, mouse.y, volume);
                        }
                    }
                    if (tempIndex < TILEDECKNUMBER - 4 && tempIndex % 5 != 0) {
                        if (tilesDeck[tempIndex + 4]->canIMove(climber)) {
                            tilesDeck[tempIndex + 4]->checkButton(mouse.x, mouse.y, volume);
                        }
                    }
                    if (tempIndex < TILEDECKNUMBER - 6 && tempIndex % 5 != 4) {
                        if (tilesDeck[tempIndex + 6]->canIMove(climber)) {
                            tilesDeck[tempIndex + 6]->checkButton(mouse.x, mouse.y, volume);
                        }
                    }
                }
            } else if (modeEnum == MOVEOTHER) {
                if (ExplorerCharacter *explorerCharacter = dynamic_cast<ExplorerCharacter *>(character2)) {
                    if (tempIndex > 5 && tempIndex % 5 != 0) {
                        if (tilesDeck[tempIndex - 6]->canIMove(climber)) {
                            tilesDeck[tempIndex - 6]->checkButton(mouse.x, mouse.y, volume);
                        }
                    }
                    if (tempIndex > 5 && tempIndex % 5 != 4) {
                        if (tilesDeck[tempIndex - 4]->canIMove(climber)) {
                            tilesDeck[tempIndex - 4]->checkButton(mouse.x, mouse.y, volume);
                        }
                    }
                    if (tempIndex < TILEDECKNUMBER - 4 && tempIndex % 5 != 0) {
                        if (tilesDeck[tempIndex + 4]->canIMove(climber)) {
                            tilesDeck[tempIndex + 4]->checkButton(mouse.x, mouse.y, volume);
                        }
                    }
                    if (tempIndex < TILEDECKNUMBER - 6 && tempIndex % 5 != 4) {
                        if (tilesDeck[tempIndex + 6]->canIMove(climber)) {
                            tilesDeck[tempIndex + 6]->checkButton(mouse.x, mouse.y, volume);
                        }
                    }
                }
            }
        }
        if (modeEnum == REMOVESAND || modeEnum ==
                                      DUNEBLASTERMODE) { //I pass always true because in this mode I only don't want not to be marked if its the storm
            if (tempIndex > 0) {
                if (tilesDeck[tempIndex - 1]->haveSand() && tempIndex % 5 != 0) {
                    tilesDeck[tempIndex - 1]->checkButton(mouse.x, mouse.y, volume);
                }
            }
            if (tempIndex < TILEDECKNUMBER - 1) {
                if (tilesDeck[tempIndex + 1]->haveSand() && tempIndex % 5 != 4) {
                    tilesDeck[tempIndex + 1]->checkButton(mouse.x, mouse.y, volume);
                }
            }
            if (tempIndex > 4) {
                if (tilesDeck[tempIndex - 5]->haveSand()) {
                    tilesDeck[tempIndex - 5]->checkButton(mouse.x, mouse.y, volume);
                }
            }
            if (tempIndex < TILEDECKNUMBER - 5) {
                if (tilesDeck[tempIndex + 5]->haveSand()) {
                    tilesDeck[tempIndex + 5]->checkButton(mouse.x, mouse.y, volume);
                }
            }
            // Explorer Move Diagonally
            if (ExplorerCharacter *explorerCharacter = dynamic_cast<ExplorerCharacter *>(character)) {
                if (tempIndex > 5 && tempIndex % 5 != 0) {
                    if (tilesDeck[tempIndex - 6]->haveSand()) {
                        tilesDeck[tempIndex - 6]->checkButton(mouse.x, mouse.y, volume);
                    }
                }
                if (tempIndex > 5 && tempIndex % 5 != 4) {
                    if (tilesDeck[tempIndex - 4]->haveSand()) {
                        tilesDeck[tempIndex - 4]->checkButton(mouse.x, mouse.y, volume);
                    }
                }
                if (tempIndex < TILEDECKNUMBER - 4 && tempIndex % 5 != 0) {
                    if (tilesDeck[tempIndex + 4]->haveSand()) {
                        tilesDeck[tempIndex + 4]->checkButton(mouse.x, mouse.y, volume);
                    }
                }
                if (tempIndex < TILEDECKNUMBER - 6 && tempIndex % 5 != 4) {
                    if (tilesDeck[tempIndex + 6]->haveSand()) {
                        tilesDeck[tempIndex + 6]->checkButton(mouse.x, mouse.y, volume);
                    }
                }
            }
        }
    }
}

//! Draw Methods
void MultiPlayerGame::drawEquipment(EquipmentsEnum equipEnum) {
    /* Gets the equipment and adds it to the player */
    switch (equipEnum) {
        case DUNEBLAST:
            if (turn) { character->increaseDuneBlaster(); }
            else { character2->increaseDuneBlaster(); }
            break;
        case JETPACK:
            if (turn) { character->increaseJetPack(); }
            else { character2->increaseJetPack(); }
            break;
        case SOLARSHIELD:
            if (turn) { character->increaseSolarShield(); }
            else { character2->increaseSolarShield(); }
            break;
        case TERRASCOPE:
            if (turn) { character->increaseTerrascope(); }
            else { character2->increaseTerrascope(); }
            break;
        case SECRETWATERRESERVE:
            if (turn) { character->increaseWaterReserve(); }
            else { character2->increaseWaterReserve(); }
            break;
        case TIMETHROTTLE:
            if (turn) { character->increaseTimeThrottle(); }
            else { character2->increaseTimeThrottle(); }
            break;
    }
    if (equipIndex == 11) { equipIndex = 0; }
    else { equipIndex++; }
}
void MultiPlayerGame::drawStormCards(ALL *allegro) {
    /* This function runs after the end of a turn...
	It uses the sandStormLevel and draw the correct number of storm cards running its action with performStormCardAction*/
    //The sandStormLevel does not indicate the number of stormCards to be drawn
    int discount = 0;        //Sometimes, if meteorologist is playing, it may be a discount on how many cards to draw
    if (turn) {
        if (MeteorologistCharacter *meteorologistCharacter = dynamic_cast<MeteorologistCharacter *>(character)) {
            discount = character->getNumberOfMoves();
        }
    } else if (MeteorologistCharacter *meteorologistCharacter = dynamic_cast<MeteorologistCharacter *>(character2)) {
        discount = character2->getNumberOfMoves();
    }
    character->resetNumberOfMoves();
    character2->resetNumberOfMoves();
    if (sandStormLevel < 6) {
        if (discount < 3) {
            for (int i = 0; i < 3 - discount; i++) {
                cout << "Pick Up One Storm Card" << endl;
                this->performStormCardAction(allegro, stormCardsDeck[0]->getStormCardType());
            }
        }
    } else if (sandStormLevel >= 6 && sandStormLevel < 10) {
        if (discount != 4) {
            for (int i = 0; i < 4 - discount; i++) {
                cout << "Pick Up One Storm Card" << endl;
                this->performStormCardAction(allegro, stormCardsDeck[0]->getStormCardType());
            }
        }
    } else if (sandStormLevel >= 10 && sandStormLevel < 13) {
        for (int i = 0; i < 5 - discount; i++) {
            cout << "Pick Up One Storm Card" << endl;
            this->performStormCardAction(allegro, stormCardsDeck[0]->getStormCardType());
        }
    } else if (sandStormLevel >= 13 && sandStormLevel < 15) {
        for (int i = 0; i < 6 - discount; i++) {
            cout << "Pick Up One Storm Card" << endl;
            this->performStormCardAction(allegro, stormCardsDeck[0]->getStormCardType());
        }
    }
}

//! Update Methods
void MultiPlayerGame::updateScreen(ALL *allegro) {
#ifdef DEBUG_UPDATE_SCREEN
    cout << "Update Screen" << endl;
#endif
    /* Updates the screen */
    redraw = false;
    switch (modeEnum) {
        case PEEPMODE:
            if (firstTimeUpdateScreenPeep == 0) {
                al_draw_bitmap(allegro->menuBackgroundImage, 0, 0, 0);
                firstTimeUpdateScreenPeep++;
            }
            stormCardsDeck[peepOffset]->peepShowImage(allegro);
            nextButton->updateButton(allegro);
            previousButton->updateButton(allegro);
            selectPeepCard->updateButton(allegro);
            break;
        case OFFEREQUIPMENTMODE:
            if (firstTimeUpdateScreenChooseEquipment == 0) {
                al_draw_bitmap(allegro->menuBackgroundImage, 0, 0, 0);
                firstTimeUpdateScreenChooseEquipment++;
                if (character->haveDuneBlaster())
                    equipOffset = DUNEBLAST;
                else if (character->haveJetPack())
                    equipOffset = JETPACK;
                else if (character->haveSolarShield())
                    equipOffset = SOLARSHIELD;
                else if (character->haveTerrascope())
                    equipOffset = TERRASCOPE;
                else if (character->haveTimeThrottle())
                    equipOffset = TIMETHROTTLE;
            }
            al_draw_bitmap(allegro->equipmentCards[equipOffset - 1],
                           (allegro->screenWidth - al_get_bitmap_width(allegro->equipmentCards[equipOffset - 1])) / 2,
                           (allegro->screenHeight - al_get_bitmap_height(allegro->equipmentCards[equipOffset - 1])) / 2,
                           0);
            nextButton->updateButton(allegro);
            previousButton->updateButton(allegro);
            selectEquipmentCard->updateButton(allegro);
            break;
        case REQUESTEQUIPMENTMODE:
            if (firstTimeUpdateScreenChooseEquipment == 0) {
                al_draw_bitmap(allegro->menuBackgroundImage, 0, 0, 0);
                firstTimeUpdateScreenChooseEquipment++;
                if (character2->haveDuneBlaster())
                    equipOffset = DUNEBLAST;
                else if (character2->haveJetPack())
                    equipOffset = JETPACK;
                else if (character2->haveSolarShield())
                    equipOffset = SOLARSHIELD;
                else if (character2->haveTerrascope())
                    equipOffset = TERRASCOPE;
                else if (character2->haveTimeThrottle())
                    equipOffset = TIMETHROTTLE;
            }
            al_draw_bitmap(allegro->equipmentCards[equipOffset - 1],
                           (allegro->screenWidth - al_get_bitmap_width(allegro->equipmentCards[equipOffset - 1])) / 2,
                           (allegro->screenHeight - al_get_bitmap_height(allegro->equipmentCards[equipOffset - 1])) / 2,
                           0);
            nextButton->updateButton(allegro);
            previousButton->updateButton(allegro);
            selectEquipmentCard->updateButton(allegro);
            break;
        default:
#ifdef DEBUG_UPDATE_SCREEN
            cout << "Default case" << endl;
#endif
            al_clear_to_color(al_map_rgb(0, 0, 0));
            al_draw_bitmap(allegro->fondo, 0, 0, 0);
            //Update Tiles
#ifdef DEBUG_UPDATE_SCREEN
            cout << "Update Tiles" << endl;
#endif
            pos tempPos;
            for (uint i = 0; i < tilesDeck.size(); i++) {
                tempPos = getSpot(i % 5, i / 5, allegro, tilesDeck[i]->getTileBackImage());
                tilesDeck[i]->setCoord(tempPos);
            }
            for (auto &i : tilesDeck) {
                i->updateTile(allegro);
            }
            //End of Turn Button
#ifdef DEBUG_UPDATE_SCREEN
            cout << "Update End of Turn Button" << endl;
#endif
            endTurnButton->updateButton(allegro);
            if (allegro->volume == 0) { muteButton->updateButton(allegro); }
            else { noMuteButton->updateButton(allegro); }
            //Tiles Buttons
#ifdef DEBUG_UPDATE_SCREEN
            cout << "Update Tiles Button" << endl;
#endif
            if (turn) { updateTilesButton(allegro); } //Don't let the player think he can still move
            //Update Characters
#ifdef DEBUG_UPDATE_SCREEN
            cout << "Update Characters" << endl;
#endif
            if (turn) {
                character->updateChar(allegro, 1, endTurnButton->getMiddleOfX(),
                                      endTurnButton->getMiddleOfY()); //Character must be after Tiles
                character2->updateChar(allegro, 2);
            } else {
                character->updateChar(allegro, 1);
                character2->updateChar(allegro, 2, endTurnButton->getMiddleOfX(), endTurnButton->getMiddleOfY());
            }
            //Update Parts
#ifdef DEBUG_UPDATE_SCREEN
            cout << "Update Parts" << endl;
#endif
            propeller->updatePart(allegro);
            solarCrystal->updatePart(allegro);
            navigationDeck->updatePart(allegro);
            engine->updatePart(allegro);
            int i = 0;
            if (engine->getPickedState()) {
                al_draw_bitmap(allegro->partsImages[i], allegro->screenWidth / 4, allegro->screenHeight / 5 + i *
                                                                                                              al_get_bitmap_height(allegro->partsImages[i]), 0);
            } else {
                al_draw_bitmap(allegro->partsImages[i + 4], allegro->screenWidth / 4,
                               allegro->screenHeight / 5 + i * al_get_bitmap_height(allegro->partsImages[i]), 0);
            }
            i++;
            if (navigationDeck->getPickedState()) {
                al_draw_bitmap(allegro->partsImages[i], allegro->screenWidth / 4, allegro->screenHeight / 5 + i *
                                                                                                              al_get_bitmap_height(allegro->partsImages[i]), 0);
            } else {
                al_draw_bitmap(allegro->partsImages[i + 4], allegro->screenWidth / 4,
                               allegro->screenHeight / 5 + i * al_get_bitmap_height(allegro->partsImages[i]), 0);
            }
            i++;
            if (propeller->getPickedState()) {
                al_draw_bitmap(allegro->partsImages[i], allegro->screenWidth / 4, allegro->screenHeight / 5 + i *
                                                                                                              al_get_bitmap_height(allegro->partsImages[i]), 0);
            } else {
                al_draw_bitmap(allegro->partsImages[i + 4], allegro->screenWidth / 4,
                               allegro->screenHeight / 5 + i * al_get_bitmap_height(allegro->partsImages[i]), 0);
            }
            i++;
            if (solarCrystal->getPickedState()) {
                al_draw_bitmap(allegro->partsImages[i], allegro->screenWidth / 4, allegro->screenHeight / 5 + i *
                                                                                                              al_get_bitmap_height(allegro->partsImages[i]), 0);
            } else {
                al_draw_bitmap(allegro->partsImages[i + 4], allegro->screenWidth / 4,
                               allegro->screenHeight / 5 + i * al_get_bitmap_height(allegro->partsImages[i]), 0);
            }
            //Buttons
            for (int i = 0; i < MODEBUTTONSNUMBER; i++) {
                modesButtons[i]->updateButton(allegro);
            }
            if (MeteorologistCharacter *meteorologistCharacter = dynamic_cast<MeteorologistCharacter *>(character)) {
                meteorologistCharacter->updateMeteorologistButton(allegro);    //Only display the button for the one who can use it... XD
            } else if (ClimberCharacter *climberCharacter = dynamic_cast<ClimberCharacter *>(character)) {
                climberCharacter->updateClimber(allegro);
            } else if (WaterCarrierCharacter *waterCarrierCharacter = dynamic_cast<WaterCarrierCharacter *>(character)) {
                bool imOnTurnedWell = (tilesDeck[character->getCardIndex()]->gettileType() == WATER &&
                                       tilesDeck[character->getCardIndex()]->isTurned());
                waterCarrierCharacter->updateGetWatersFromWell(imOnTurnedWell, allegro);
            } else if (NavigatorCharacter *navigatorCharacter = dynamic_cast<NavigatorCharacter *>(character)) {
                navigatorCharacter->updateNavigator(allegro, modeEnum == MOVEOTHER);
            }
            //Sand Storm Level Meter
            if (sandStormLevel < 15) {
                al_draw_bitmap(allegro->stormMeter[sandStormLevel], allegro->screenWidth * 12 / 17,
                               allegro->screenHeight - al_get_bitmap_height(allegro->stormMeter[sandStormLevel]), 0);
            }
            //Sand Markers Left (TEXT)
            if (SandMarkersLeft < 0) { SandMarkersLeft = 0; }
            al_draw_textf(allegro->gameFont, al_map_rgb(BLACK), allegro->screenWidth * 30 / 34,
                          allegro->screenHeight * 25 / 32, ALLEGRO_ALIGN_LEFT, "%d", SandMarkersLeft);
#ifdef DEBUG_UPDATE_SCREEN
            cout << "Default case done" << endl;
#endif
    }
    if (modeEnum == OFFERWATERMODE || modeEnum == REQUESTWATERMODE) {
        al_draw_bitmap(allegro->menuBackgroundImage, 0, 0, 0);
        al_draw_text(allegro->font, al_map_rgb(WHITE), allegro->screenWidth * 0.5,
                     watersButton[0]->getInitialPos().y - 55, ALLEGRO_ALIGN_CENTRE, "How many waters?");
        if (modeEnum == OFFERWATERMODE) {
            for (int i = 0; i < min(character->getWaters(), MAXWATERS - character2->getWaters() - 1); i++)
                watersButton[i]->updateButton(allegro);//update all the waters Button
        } else if (modeEnum == REQUESTWATERMODE) {
            for (int i = 0; i < min((MAXWATERS - character->getWaters() - 1), character2->getWaters()); i++)
                watersButton[i]->updateButton(allegro);//update all the waters Button
        }
    }
    al_flip_display();
#ifdef DEBUG_UPDATE_SCREEN
    cout << "Update Done" << endl;
#endif
}
void MultiPlayerGame::updateTilesButton(ALL *allegro) {
#ifdef DEBUG_UPDATE_SCREEN
    cout << "Update Tiles Button" << endl;
#endif
    //Equipments Mode
    if (modeEnum == JETPACKMODE) {
        for (int i = 0; i < TILEDECKNUMBER; i++) {
            if (tilesDeck[i]->canIMove(false)) {
                tilesDeck[i]->updateButton(allegro);
            }
        }
    } else if (modeEnum == TERRASCOPEMODE) {
        for (int i = 0; i < TILEDECKNUMBER; i++)
            if (tilesDeck[i]->gettileType() != STORM) {
                tilesDeck[i]->updateButton(allegro);
            }
    } else {
        int tempIndex;
        bool climber = false;
        //Normal Movements
        if (modeEnum == MOVEOTHER) {
            tempIndex = character2->getCardIndex();
            if (ClimberCharacter *climberCharacter = dynamic_cast<ClimberCharacter *>(character2)) { climber = true; }
        } else {
            tempIndex = character->getCardIndex();
            if (turn && (tilesDeck[tempIndex]->haveSand() ||
                         !tilesDeck[tempIndex]->isTurned())) { tilesDeck[tempIndex]->updateButton(allegro); }
            if (ClimberCharacter *climberCharacter = dynamic_cast<ClimberCharacter *>(character)) { climber = true; }
        }
        if (turn && tilesDeck[tempIndex]->canIMove(climber)) {
            if (modeEnum == NORMAL || modeEnum == MOVEOTHER) {
                if (tempIndex > 0 && tempIndex % 5 != 0) {
                    if (tilesDeck[tempIndex - 1]->canIMove(climber)) {
                        tilesDeck[tempIndex - 1]->updateButton(allegro);
                    }
                }
                if (tempIndex < TILEDECKNUMBER - 1 && tempIndex % 5 != 4) {
                    if (tilesDeck[tempIndex + 1]->canIMove(climber)) {
                        tilesDeck[tempIndex + 1]->updateButton(allegro);
                    }
                }
                if (tempIndex > 4) {
                    if (tilesDeck[tempIndex - 5]->canIMove(climber)) {
                        tilesDeck[tempIndex - 5]->updateButton(allegro);
                    }
                }
                if (tempIndex < TILEDECKNUMBER - 5) {
                    if (tilesDeck[tempIndex + 5]->canIMove(climber)) {
                        tilesDeck[tempIndex + 5]->updateButton(allegro);
                    }
                }
                if (modeEnum == NORMAL) {
                    if (ExplorerCharacter *explorerCharacter = dynamic_cast<ExplorerCharacter *>(character)) {
                        if (tempIndex > 5 && tempIndex % 5 != 0) {
                            if (tilesDeck[tempIndex - 6]->canIMove(climber)) {
                                tilesDeck[tempIndex - 6]->updateButton(allegro);
                            }
                        }
                        if (tempIndex > 4 && tempIndex % 5 != 4) {
                            if (tilesDeck[tempIndex - 4]->canIMove(climber)) {
                                tilesDeck[tempIndex - 4]->updateButton(allegro);
                            }
                        }
                        if (tempIndex < TILEDECKNUMBER - 4 && tempIndex % 5 != 0) {
                            if (tilesDeck[tempIndex + 4]->canIMove(climber)) {
                                tilesDeck[tempIndex + 4]->updateButton(allegro);
                            }
                        }
                        if (tempIndex < TILEDECKNUMBER - 6 && tempIndex % 5 != 4) {
                            if (tilesDeck[tempIndex + 6]->canIMove(climber)) {
                                tilesDeck[tempIndex + 6]->updateButton(allegro);
                            }
                        }
                    }
                } else if (modeEnum == MOVEOTHER) {
                    if (ExplorerCharacter *explorerCharacter = dynamic_cast<ExplorerCharacter *>(character2)) {
                        if (tempIndex > 5 && tempIndex % 5 != 0) {
                            if (tilesDeck[tempIndex - 6]->canIMove(climber)) {
                                tilesDeck[tempIndex - 6]->updateButton(allegro);
                            }
                        }
                        if (tempIndex > 4 && tempIndex % 5 != 4) {
                            if (tilesDeck[tempIndex - 4]->canIMove(climber)) {
                                tilesDeck[tempIndex - 4]->updateButton(allegro);
                            }
                        }
                        if (tempIndex < TILEDECKNUMBER - 4 && tempIndex % 5 != 0) {
                            if (tilesDeck[tempIndex + 4]->canIMove(climber)) {
                                tilesDeck[tempIndex + 4]->updateButton(allegro);
                            }
                        }
                        if (tempIndex < TILEDECKNUMBER - 6 && tempIndex % 5 != 4) {
                            if (tilesDeck[tempIndex + 6]->canIMove(climber)) {
                                tilesDeck[tempIndex + 6]->updateButton(allegro);
                            }
                        }
                    }
                }
            }
            if (modeEnum == REMOVESAND || modeEnum == DUNEBLASTERMODE) {
                if (tempIndex > 0 && tempIndex % 5 != 0) {
                    if (tilesDeck[tempIndex - 1]->haveSand()) {
                        tilesDeck[tempIndex - 1]->updateButton(allegro);
                    }
                }
                if (tempIndex < TILEDECKNUMBER - 1 && tempIndex % 5 != 4) {
                    if (tilesDeck[tempIndex + 1]->haveSand()) {
                        tilesDeck[tempIndex + 1]->updateButton(allegro);
                    }
                }
                if (tempIndex > 4) {
                    if (tilesDeck[tempIndex - 5]->haveSand()) {
                        tilesDeck[tempIndex - 5]->updateButton(allegro);
                    }
                }
                if (tempIndex < TILEDECKNUMBER - 5) {
                    if (tilesDeck[tempIndex + 5]->haveSand()) {
                        tilesDeck[tempIndex + 5]->updateButton(allegro);
                    }
                }
                if (ExplorerCharacter *explorerCharacter = dynamic_cast<ExplorerCharacter *>(character)) {
                    if (tempIndex > 5 && tempIndex % 5 != 0) {
                        if (tilesDeck[tempIndex - 6]->haveSand()) {
                            tilesDeck[tempIndex - 6]->updateButton(allegro);
                        }
                    }
                    if (tempIndex > 4 && tempIndex % 5 != 4) {
                        if (tilesDeck[tempIndex - 4]->haveSand()) {
                            tilesDeck[tempIndex - 4]->updateButton(allegro);
                        }
                    }
                    if (tempIndex < TILEDECKNUMBER - 4 && tempIndex % 5 != 0) {
                        if (tilesDeck[tempIndex + 4]->haveSand()) {
                            tilesDeck[tempIndex + 4]->updateButton(allegro);
                        }
                    }
                    if (tempIndex < TILEDECKNUMBER - 6 && tempIndex % 5 != 4) {
                        if (tilesDeck[tempIndex + 6]->haveSand()) {
                            tilesDeck[tempIndex + 6]->updateButton(allegro);
                        }
                    }
                }
            }
            if (tilesDeck[tempIndex]->gettileType() == TUNNEL && tilesDeck[tempIndex]->isTurned()) {
                for (uint i = 0; i < tilesDeck.size(); i++) {
                    if (tilesDeck[i]->gettileType() == TUNNEL && i != tempIndex && tilesDeck[i]->isTurned()) {
                        if (tilesDeck[i]->canIMove(climber)) { tilesDeck[i]->updateButton(allegro); }
                    }
                }
            }
        }
    }
}
</file>

<file path="src/NavigatorButton.cpp">
#include "NavigatorButton.hpp"

NavigatorButton::NavigatorButton() {}
NavigatorButton::NavigatorButton(int x0, int y0, const char *imageName, const char * nonSelectedImageName, ALL* allegro) : Button(x0, y0, imageName, nonSelectedImageName, allegro) {}
bool NavigatorButton::buttonAction(int x, int y) {
	if (mouseOverButton) {
		cout << "Click on Navigator Button" << endl;
		al_play_sample(selectCharSample, 1.0, 0.0, 1.0, ALLEGRO_PLAYMODE_ONCE, NULL);
		return true;
	}
	return false;
}
</file>

<file path="src/NavigatorCharacter.cpp">
#include "NavigatorCharacter.hpp"

NavigatorCharacter::NavigatorCharacter(int rowSet, int columnSet, Container info, ALL *allegro) : Character(rowSet, columnSet, info, allegro){
	if(adventurerImage = al_load_bitmap_resized("Resources/Players/navigatorImage.png", allegro)){
		if (image = al_load_bitmap_resized("Resources/Players/Pawns/NavigatorPawnImage.png", allegro)) {
			partnerMovesLeft = 3;
			doneButton = new Button(allegro->screenWidth / 8, allegro->screenHeight / 2 - 50, "Resources/Players/NavigatorButton/DoneButtonImage.png", "Resources/Players/NavigatorButton/moseOverButtonDoneButtonImage.png", allegro);
			moveOtherPlayerButton = new Button(allegro->screenWidth / 8, allegro->screenHeight / 2 - 50, "Resources/Players/NavigatorButton/noMouseOverButtonMoveOther.png", "Resources/Players/NavigatorButton/moveOverButtonMoveOther.png", allegro);
		}
		else { cout << "Failed to load Navigator Pawn Image" << endl; }
	}
	else { cout << "Failed to load navigatorImage.png" << endl; }
	//Sounds
	if (gettingCloseSound = al_load_sample("Resources/Sounds/MustBeGettingClose(Girl).wav")) {}
	else { cout << "Failed to load Must be getting close Sound" << endl; }
}
NavigatorCharacter::~NavigatorCharacter(){
	for (int i = 0; i < MAXOFWATERS; i++) { al_destroy_bitmap(watersImage[i]); }
	al_destroy_bitmap(navigatorImage);
	al_destroy_sample(gettingCloseSound);
	delete moveOtherPlayerButton;
	delete doneButton;
}

bool NavigatorCharacter::checkMouseOverButton(int x, int y, bool moveState, double volume) {
	if (moveState) { return doneButton->checkMouse(x, y, volume); }
	else { return moveOtherPlayerButton->checkMouse(x, y, volume); }
}
void NavigatorCharacter::updateNavigator(ALL* allegro, bool moveState) {
	if (moveState) {
		doneButton->updateButton(allegro);
		al_draw_textf(allegro->font, al_map_rgb(WHITE), allegro->screenWidth / 8, allegro->screenHeight / 2, ALLEGRO_ALIGN_CENTRE, "Number of Moves for the other Player: %d", partnerMovesLeft);
	}
	else { moveOtherPlayerButton->updateButton(allegro); }
}
void NavigatorCharacter::resetPartnerMoves() { partnerMovesLeft = 3; }

bool NavigatorCharacter::usedPartnerMoves() { return !(partnerMovesLeft == 3); }

bool NavigatorCharacter::decresePartnerMoves() { 
	if (partnerMovesLeft > 0) { 
		partnerMovesLeft--; 
		return true;
	}
	else { return false; }
}
</file>

<file path="src/Network.cpp">
#include "Network.hpp"

initNetwork::initNetwork() {
	seedStart();
	port = PORT;
	randGenerator();
	abort = false;
}

void initNetwork::initializeNet(ALL *allegro) {
	al_set_target_backbuffer(allegro->startMenuDisplay);
	getIP(allegro);
	connection = openConnection(IP, port);
	printAllegro(allegro, "Trying Connection as Client");
	al_set_timer_count(allegro->timeout, 0);
	al_start_timer(allegro->timeout);

	for (; randNum && (!(isConnected(connection))); randNum--) {
		connection = openConnection(IP, port);
#ifdef __linux__
        usleep(1000);
#elif _WIN32
        Sleep(1);
#endif
	}
	for (int i = 20; isPending(connection) && i; i--) {
#ifdef __linux__
        usleep(200000);
#elif _WIN32
        Sleep(200);
#endif
	}
	if (!(isConnected(connection))) {
		printAllegro(allegro, "Trying Connection as Server");
		startListening(port);
		while (!(connection = getAvailableConnection()) && al_get_timer_count(allegro->timeout)<TIME_OUT)
#ifdef __linux__
            usleep(500000);
#elif _WIN32
        Sleep(500);
#endif
		while (isPending(connection)) {
#ifdef __linux__
            usleep(1000);
#elif _WIN32
            Sleep(1);
#endif
        }
		typeconn = SERVER;
		printAllegro(allegro, "Connection Sucessful!");
	}
	else {
		printAllegro(allegro, "Connection Sucessful!");
		typeconn = CLIENT;
	}
	if (al_get_timer_count(allegro->timeout) >= TIME_OUT) {
		printAllegro(allegro, "TIMEOUT- Connection aborted");
		abort = true;
	}
}
void  initNetwork::seedStart() {
	srand(time(NULL));
}
void initNetwork::randGenerator() {
	randNum = rand() % 9801 + 200;
}
void initNetwork::getIP(ALL* allegro) {
	printAllegro(allegro, "Please, enter the IP");
	char* a;
	a = getcharAllegro(allegro, 8, HEIGHT * allegro->screenHeight / MAXRESOLUTION_Y / 3);
	memcpy(IP, a, strlen(a) + 1);
}
initNetwork::~initNetwork() {
	closeConnection(connection);
}
</file>

<file path="src/Packages.cpp">
#include "Packages.hpp"
#include <iostream>
#include <include/Packages.hpp>


//Constructor
Pack::Pack(PolonetConn connection){
	buffer = NULL;
	for (int i = 0; i < BUFFERSIZE; i++)
		recbuffer[i] = 0;	//Inicializo buffer en 0
	size = 0;
	this->connection = connection;	//Guardo conexion determinada en el objeto
}
//DESTRUCTOR
Pack::~Pack(){
	if(buffer!=NULL)
		delete[] buffer;	//Elimino memoria alocada con new
	else
		return;
}
//Envio paquetes
void Pack::sendPack(){
	if (isConnected(connection))
		sendData(connection, buffer, size);	//En caso de haber una conexion vigente, envio paquete completo de datos
	else
		std::cout << "Warning: Attempt of sending packs through a non-stablished connection" << endl;
}
Container::Container(){//Constructor, inicializo Slots, ID, arreglo de tiles y nombre del usuario en 0
	Slot1 = 0;
	Slot2 = 0;
	Slot3 = 0;
	Slot4 = 0;
	Slot5 = 0;
	Slot6 = 0;
	Slot7 = 0;
	ID = 0;
	for (int i = 0; i < CANTOFTILES; i++) tiles[i] = DEFAULT;
	for (int i = 0; i < CANTOFSTORM; i++) storm[i] = SUNBEATSDOWN;
	for (int i = 0; i < CANTOFEQUIPMENT; i++) equipment[i] = DUNEBLAST;
	for (int i = 0; i < SIZEOFNAME; i++) name[i] = 0;
}	
Container Pack::receivePack(){
	Container ret;
	unsigned char ID;
	receiveData(connection, recbuffer, sizeof(recbuffer));
	ID = recbuffer[0];
	switch(ID)
	{
	case  NAME:
		ret.ID = recbuffer[0];
		break;
	case  NAME_IS:
		ret.ID = recbuffer[0];
		for (int i = 0; i < 20; i++) ret.name[i] = 0;
		memcpy(&ret.name[0], &recbuffer[2], recbuffer[1]);
		ret.name[recbuffer[1]] = '\0';
		break;
	case  ACK:
		ret.ID = recbuffer[0];
		break;
	case  I_START:
		ret.ID = recbuffer[0];
		break;
	case  YOU_START:
		ret.ID = recbuffer[0];
		break;
	case  MOVE:
		ret.ID = recbuffer[0];
		ret.Slot1 = recbuffer[1];
		ret.Slot2 = recbuffer[2];
		break;
	case  REMOVE:
		ret.ID = recbuffer[0];
		ret.Slot1 = recbuffer[1];
		ret.Slot2 = recbuffer[2];
		break;
	case  OFFER_EQUIPMENT:
		ret.ID = recbuffer[0];
		ret.Slot1 = recbuffer[1];
		break;
	case  OFFER_WATER:
		ret.ID = recbuffer[0];
		ret.Slot1 = recbuffer[1];
		break;
	case  REQUEST_EQUIPMENT:
		ret.ID = recbuffer[0];
		ret.Slot1 = recbuffer[1];
		break;
	case  REQUEST_WATER:
		ret.ID = recbuffer[0];
		ret.Slot1 = recbuffer[1];
		break;
	case  REQUEST_MOVE:
		ret.ID = recbuffer[0];
		ret.Slot1 = recbuffer[1];
		ret.Slot2 = recbuffer[2];
		break;
	case  PLAY_EQUIPMENT:
		ret.ID = recbuffer[0];
		ret.Slot1 = recbuffer[1];
		ret.Slot2 = recbuffer[2];
		ret.Slot3 = recbuffer[3];
		break;
	case  PEEP:
		ret.ID = recbuffer[0];
		ret.Slot1 = recbuffer[1];
		break;
	case  EXCAVATE:
		ret.ID = recbuffer[0];
		break;
	case  PICKUP:
		ret.ID = recbuffer[0];
		break;
	case  TAKE_WATER:
		ret.ID = recbuffer[0];
		ret.Slot1 = recbuffer[1];
		break;
	case  DECREASE_WITHDRAWAL:
		ret.ID = recbuffer[0];
		break;
	case  PASS:
		ret.ID = recbuffer[0];
		break;
	case  AGREE:
		ret.ID = recbuffer[0];
		break;
	case  DISAGREE:
		ret.ID = recbuffer[0];
		break;
	case  ERROR_:
		ret.ID = recbuffer[0];
		break;
	case  GAME_OVER:
		ret.ID = recbuffer[0];
		break;
	case PLAY_AGAIN:
		ret.ID = recbuffer[0];
	case  WE_WON:
		ret.ID = recbuffer[0];
		break;
	case  WE_LOST:
		ret.ID = recbuffer[0];
		break;
	case  QUIT:
		ret.ID = recbuffer[0];
		break;
	case  DRAW_STORM_CARDS:
		ret.ID = recbuffer[0];
		ret.Slot1 = recbuffer[1];
		ret.Slot2 = recbuffer[2];
		ret.Slot3 = recbuffer[3];
		ret.Slot4 = recbuffer[4];
		ret.Slot5 = recbuffer[5];
		ret.Slot6 = recbuffer[6];
		break;
	case  START_INFO:
		ret.ID = recbuffer[0];
		ret.Slot1 = recbuffer[1];
		ret.Slot2 = recbuffer[2];
		ret.myRol = (roles)recbuffer[2];
		ret.friendRol = (roles)recbuffer[1];
		for (int i = 0; i < CANTOFTILES; i++)
			ret.tiles[i] = (TilesEnum)recbuffer[i + 3];
		for (int i = 0; i < CANTOFSTORM; i++)
			ret.storm[i] = (StormCardsEnum)recbuffer[i + 3 + CANTOFTILES];
		for (int i = 0; i < CANTOFEQUIPMENT; i++)
			ret.equipment[i] = (EquipmentsEnum)recbuffer[i + 3 + CANTOFTILES + CANTOFSTORM];
		break;
	default:
		ret.ID = NOEVENT;
	}
	//cleanBuffer();
	return ret;
}
void Pack::cleanBuffer(void){
	for (int i = 0; i < BUFFERSIZE; i++)
		recbuffer[i] = 0;
}
// Packs methods
void Pack::ack(){
	if (buffer != NULL)
		delete[] buffer;
	size = sizeof(char);
	buffer = new char[size];
	buffer[0] = ACK;
}
void Pack::agree(){
	if (buffer != NULL)
		delete[] buffer;
	size = sizeof(char);
	buffer = new char[size];
	buffer[0] = AGREE;
}
void Pack::disagree(){
	if (buffer != NULL)
		delete[] buffer;
	size = sizeof(char);
	buffer = new char[size];
	buffer[0] = DISAGREE;
}
void Pack::name(){
	if (buffer != NULL)
		delete[] buffer;
	size = sizeof(char);
	buffer = new char[size];
	buffer[0] = NAME;
}
void Pack::nameis(char* name){
	if (buffer != NULL)
		delete[] buffer;
	size = 2 * sizeof(char) + strlen(name);
	buffer = new char[size];
	buffer[0] = NAME_IS;
	buffer[1] = strlen(name);
	memcpy(&buffer[2], name, strlen(name));
}
roles Pack::rolesort(){		// genera los roles de manera aleatoria
	char rol = rand() % 6 + 0x30;
	return (roles)rol;
}

void Pack::waitForAck(ALL *allegro) {
	char wait;
	al_start_timer(allegro->timeout);
	do {
		cout << "Waiting for ack" << endl;
		wait = receivePack().ID;
		cleanBuffer();
	} while (wait != ACK && al_get_timer_count(allegro->timeout) == TIMEOUT);
	al_stop_timer(allegro->timeout);
	al_set_timer_count(allegro->timeout, 0);
}

void Container::startinfo(roles rol1, roles rol2) {
	char* buffer;
	char size = 3 * sizeof(char) + CANTOFEQUIPMENT + CANTOFSTORM + CANTOFTILES;
	buffer = new char[size];
	buffer[0] = START_INFO;
	buffer[1]= START_INFO;
	//Choose Player
	myRol = (roles) rol1;
	friendRol = (roles) rol2;
	int i = 3;
	buffer[i++] = STORM;
	buffer[i++] = CRASHSITE;
	buffer[i++] = LAUNCHPAD;
	buffer[i++] = DEFAULT;
	int c = 1;
	while (c <= 3) {
		buffer[i++] = TUNNEL;
		c++;
	}
	c = 1;
	while (c <= 2) {
		buffer[i++] = WATER;
		c++;
	}
	buffer[i++] = ENGINECOLUMN;
	buffer[i++] = ENGINEROW;
	buffer[i++] = SOLARCRYSCOLUMN;
	buffer[i++] = SOLARCRYSROW;
	buffer[i++] = NAVIGATIONCOLUMN;
	buffer[i++] = NAVIGATIONROW;
	buffer[i++] = PROPELLERCOLUMN;
	buffer[i++] = PROPELLERROW;
	buffer[i++] = GEAR1;
	buffer[i++] = GEAR2;
	buffer[i++] = GEAR3;
	buffer[i++] = GEAR4;
	buffer[i++] = GEAR5;
	buffer[i++] = GEAR6;
	buffer[i++] = GEAR7;
	buffer[i] = GEAR8;

	std:: random_shuffle(&buffer[3],&buffer[i],myRand);		//Mezclo todos los tiles
	int search;
	for(search = 0; buffer[search] != STORM; search++);		// Busco la sand storm para reubicarla
	std::swap<char>(buffer[search], buffer[15]);			// Reubico la sand storm en el medio, (15 del buffer: la mitad de CANTOFTILES + 3)

	for (int a = 0; a < CANTOFTILES; a++) {
		tiles[a] = (TilesEnum)buffer[a + 3];				// Guardo la informacion del tablero para que la retenga luego de enviarla
	}
	//SandStormCards
	c = 1;
	i++;
	while (c < 3) { //Create 2 of each
		buffer[i++] = RIGHT1;
		buffer[i++] = RIGHT2;
		buffer[i++] = RIGHT3;
		buffer[i++] = LEFT1;
		buffer[i++] = LEFT2;
		buffer[i++] = LEFT3;
		buffer[i++] = UP1;
		buffer[i++] = UP2;
		buffer[i++] = UP3;
		buffer[i++] = DOWN1;
		buffer[i++] = DOWN2;
		buffer[i++] = DOWN3;
		c++;
	}
	c = 1;
	while (c < 4) {
		buffer[i++] = STORMUP;
		c++;
	}
	c = 1;
	while (c < 5) {
		buffer[i++] = SUNBEATSDOWN;
		c++;
	}

	std::random_shuffle(&buffer[CANTOFTILES + 3], &buffer[i], myRand);	//Mezclo todos los tiles... (no son los storm cards?)
	//Harcodie para poder debuggear el SolarShield
	for (int a = 0; a < CANTOFSTORM; a++) {
		storm[a] = (StormCardsEnum)buffer[a + CANTOFTILES + 3];	//Guardo la informacion del tablero para que la retenga luego de enviarla
	}
	//Equipment Cards
	c = 1;
	while (c < 4) {
		buffer[i++] = DUNEBLAST;
		buffer[i++] = JETPACK;
		c++;
	}
	c=1;
	while (c < 3) {
		buffer[i++] = SOLARSHIELD;
		buffer[i++] = TERRASCOPE;
		c++;
	}
	buffer[i++] = SECRETWATERRESERVE;
	buffer[i] = TIMETHROTTLE;

	std::random_shuffle(&buffer[CANTOFTILES + CANTOFSTORM + 3], &buffer[i], myRand);	//Mezclo todos los tiles
	buffer[CANTOFTILES + CANTOFSTORM + 3] = TIMETHROTTLE;//FOR DEBUGGING
	for (int a = 0; a < CANTOFEQUIPMENT; a++) {
		equipment[a] = (EquipmentsEnum)buffer[a + CANTOFTILES + CANTOFSTORM + 3];	//Guardo la informacion del tablero para que la retenga luego de enviarla
	}
}
Container Pack::startinfo(ALL* allegro){
	Container info;

	delete[] buffer;
	size = 3 * sizeof(char) + CANTOFEQUIPMENT + CANTOFSTORM + CANTOFTILES;
	buffer = new char[size];
	buffer[0] = START_INFO;
	buffer[1]=rolesort();
	//Choose Player
	bool stillPlaying = true;
	ChoosePlayer *choosePlayer;
	choosePlayer = new ChoosePlayer(allegro /*, &buffer[1], &buffer[2]*/ );	// TODO: change this or multiplayer broken
	while (stillPlaying) {
		stillPlaying = choosePlayer->eventHandler(allegro);
	}
	//while ((buffer[2] = rolesort()) == buffer[1]);
	//info.myRol = (roles)buffer[1];			// Guardo mi rol
	//info.friendRol = (roles)buffer[2];		// Guardo rol de mi amigo
	info.myRol = (roles) choosePlayer->get_p1_role();
	info.friendRol = (roles) choosePlayer->get_p2_role();
	int i = 3;
	buffer[i++] = STORM;
	buffer[i++] = CRASHSITE;
	buffer[i++] = LAUNCHPAD;
	buffer[i++] = DEFAULT;
	int c = 1;
	while (c <= 3) {
		buffer[i++] = TUNNEL;
		c++;
	}
	c = 1;
	while (c <= 2) {
		buffer[i++] = WATER;
		c++;
	}
	buffer[i++] = ENGINECOLUMN;
	buffer[i++] = ENGINEROW;
	buffer[i++] = SOLARCRYSCOLUMN;
	buffer[i++] = SOLARCRYSROW;
	buffer[i++] = NAVIGATIONCOLUMN;
	buffer[i++] = NAVIGATIONROW;
	buffer[i++] = PROPELLERCOLUMN;
	buffer[i++] = PROPELLERROW;
	buffer[i++] = GEAR1;
	buffer[i++] = GEAR2;
	buffer[i++] = GEAR3;
	buffer[i++] = GEAR4;
	buffer[i++] = GEAR5;
	buffer[i++] = GEAR6;
	buffer[i++] = GEAR7;
	buffer[i] = GEAR8;
	
	std:: random_shuffle(&buffer[3],&buffer[i],myRand);		//Mezclo todos los tiles
	int search;
	for(search = 0; buffer[search] != STORM; search++);		// Busco la sand storm para reubicarla
	std::swap<char>(buffer[search], buffer[15]);			// Reubico la sand storm en el medio, (15 del buffer: la mitad de CANTOFTILES + 3)
	
	for (int a = 0; a < CANTOFTILES; a++) {
		info.tiles[a] = (TilesEnum)buffer[a + 3];			//Guardo la informacion del tablero para que la retenga luego de enviarla
	}
	//SandStormCards
	c = 1;
	i++;
	while (c < 3) { //Create 2 of each
		buffer[i++] = RIGHT1;
		buffer[i++] = RIGHT2;
		buffer[i++] = RIGHT3;
		buffer[i++] = LEFT1;
		buffer[i++] = LEFT2;
		buffer[i++] = LEFT3;
		buffer[i++] = UP1;
		buffer[i++] = UP2;
		buffer[i++] = UP3;
		buffer[i++] = DOWN1;
		buffer[i++] = DOWN2;
		buffer[i++] = DOWN3;
		c++;
	}
	c = 1;
	while (c < 4) {
		buffer[i++] = STORMUP;
		c++;
	}
	c = 1;
	while (c < 5) {
		buffer[i++] = SUNBEATSDOWN;
		c++;
	}

	std::random_shuffle(&buffer[CANTOFTILES + 3], &buffer[i], myRand);	//Mezclo todos los tiles... (no son los storm cards?)
	//Harcodie para poder debuggear el SolarShield
	for (int a = 0; a < CANTOFSTORM; a++) {
		info.storm[a] = (StormCardsEnum)buffer[a + CANTOFTILES + 3];	//Guardo la informacion del tablero para que la retenga luego de enviarla
	}
	//Equipment Cards
	c = 1;
	while (c < 4) {
		buffer[i++] = DUNEBLAST;
		buffer[i++] = JETPACK;
		c++;
	}
	c=1;
	while (c < 3) {
		buffer[i++] = SOLARSHIELD;
		buffer[i++] = TERRASCOPE;
		c++;
	}
	buffer[i++] = SECRETWATERRESERVE;
	buffer[i] = TIMETHROTTLE;

	std::random_shuffle(&buffer[CANTOFTILES + CANTOFSTORM + 3], &buffer[i], myRand);	//Mezclo todos los tiles
	buffer[CANTOFTILES + CANTOFSTORM + 3] = TIMETHROTTLE;//FOR DEBUGGING
	for (int a = 0; a < CANTOFEQUIPMENT; a++) {
		info.equipment[a] = (EquipmentsEnum)buffer[a + CANTOFTILES + CANTOFSTORM + 3];	//Guardo la informacion del tablero para que la retenga luego de enviarla
	}
	//Destroy allegro's things that were initialize in ChoosePlayer
	al_unregister_event_source(allegro->events_queue, al_get_display_event_source(allegro->display));
	al_destroy_display(allegro->display);
	delete choosePlayer;
	return info;
}

void Pack::youstart(){
	if (buffer != NULL)
		delete[] buffer;
	size = sizeof(char);
	buffer = new char[size];
	buffer[0] = YOU_START;
}
void Pack::istart(){
	if (buffer != NULL)
		delete[] buffer;
	size = sizeof(char);
	buffer = new char[size];
	buffer[0] = I_START;
}
void Pack::excavate(){
	if (buffer != NULL)
		delete[] buffer;
	size = sizeof(char);
	buffer = new char[size];
	buffer[0] = EXCAVATE;
}
void Pack::pickup(){
	if (buffer != NULL)
		delete[] buffer;
	size = sizeof(char);
	buffer = new char[size];
	buffer[0] = PICKUP;
}
void Pack::move(char row, char col){
	if (buffer != NULL)
		delete[] buffer;
	size = 3 * sizeof(char);
	buffer = new char[size];
	buffer[0] = MOVE;
	buffer[1] = row;
	buffer[2] = col;
}
void Pack::remove(char row, char col){
	if (buffer != NULL)
		delete[] buffer;
	size = 3 * sizeof(char);
	buffer = new char[size];
	buffer[0] = REMOVE;
	buffer[1] = row;
	buffer[2] = col;
}
void Pack::offerequipment(char equipment){
	if (buffer != NULL)
		delete[] buffer;
	size = 2 * sizeof(char);
	buffer = new char[size];
	buffer[0] = OFFER_EQUIPMENT;
	buffer[1] = equipment;
}
void Pack::offerwater(char water){
	if (buffer != NULL)
		delete[] buffer;
	size = 2 * sizeof(char);
	buffer = new char[size];
	buffer[0] = OFFER_WATER;
	buffer[1] = water;
}
void Pack::requestequipment(char equipment){
	if (buffer != NULL)
		delete[] buffer;
	size = 2 * sizeof(char);
	buffer = new char[size];
	buffer[0] = REQUEST_EQUIPMENT;
	buffer[1] = equipment;
}
void Pack::requestwater(char water){
	if (buffer != NULL)
		delete[] buffer;
	size = 2 * sizeof(char);
	buffer = new char[size];
	buffer[0] = REQUEST_WATER;
	buffer[1] = water;
}
void Pack::requestmove(char row, char col){
	if (buffer != NULL)
		delete[] buffer;
	size = 3 * sizeof(char);
	buffer = new char[size];
	buffer[0] = REQUEST_MOVE;
	buffer[1] = row;
	buffer[2] = col;
}
void Pack::takewater(){
	if (buffer != NULL)
		delete[] buffer;
	size = sizeof(char);
	buffer = new char[size];
	buffer[0] = TAKE_WATER;
}
void Pack::decreasewithdrawal(){
	if (buffer != NULL)
		delete[] buffer;
	size = sizeof(char);
	buffer = new char[sizeof(char)];
	buffer[0] = DECREASE_WITHDRAWAL;
}
void Pack::playequipment(char equipment, char row, char col){
	if (buffer != NULL)
		delete[] buffer;
	size = sizeof(equipment) + sizeof(row) + sizeof(col) + sizeof(char);
	buffer = new char[size];
	buffer[0] = PLAY_EQUIPMENT;
	buffer[1] = equipment;
	buffer[2] = row;
	buffer[3] = col;
}
void Pack::pass(){
	if (buffer != NULL)
		delete[] buffer;
	size = sizeof(char);
	buffer = new char[sizeof(char)];
	buffer[0] = PASS;
}
void Pack::wewon(){
	if (buffer != NULL)
		delete[] buffer;
	size = sizeof(char);
	buffer = new char[sizeof(char)];
	buffer[0] = WE_WON;
}
void Pack::welost(){
	if (buffer != NULL)
		delete[] buffer;
	size = sizeof(char);
	buffer = new char[sizeof(char)];
	buffer[0] = WE_LOST;
}
void Pack::gameover() {
	if (buffer != NULL)
		delete[] buffer;
	size = sizeof(char);
	buffer = new char[sizeof(char)];
	buffer[0] = (char)GAME_OVER;
}
void Pack::playagain() {
	if (buffer != NULL)
		delete[] buffer;
	size = sizeof(char);
	buffer = new char[sizeof(char)];
	buffer[0] = (char)PLAY_AGAIN;
}
void Pack::quit(){
	if (buffer != NULL)
		delete[] buffer;
	size = sizeof(char);
	buffer = new char[size];
	buffer[0] = (char)QUIT;
}
void Pack::error(){
	if (buffer != NULL)
		delete[] buffer;
	size = sizeof(char);
	buffer = new char[size];
	buffer[0] = (char)ERROR_;
}
void Pack::peep(char index){
	if (buffer != NULL)
		delete[] buffer;
	size = 2 * sizeof(char);
	buffer = new char[size];
	buffer[0] = PEEP;
	buffer[1] = index;
}
void Pack::drawstrcard(char first, char second, char third, char forth, char fifth, char sixth){
	if (buffer != NULL)
		delete[] buffer;
	size = sizeof(char) + sizeof(first) + sizeof(second) + sizeof(third);
	if (forth != 0)size++;
	if (fifth != 0)size++;
	if (sixth != 0)size++;
	buffer = new char[size];
	buffer[0] = DRAW_STORM_CARDS;
	buffer[1] = first;
	buffer[2] = second;
	switch (size)
	{
	case 4:
		buffer[3] = third;
		break;
	case 5:
		buffer[3] = third;
		buffer[4] = forth;
		break;
	case 6:
		buffer[3] = third;
		buffer[4] = forth;
		buffer[5] = fifth;
		break;
	case 7:
		buffer[3] = third;
		buffer[4] = forth;
		buffer[5] = fifth;
		buffer[6] = sixth;
		break;
	}
}


void Container:: addName(char* name){
	strncpy(this->name, name, SIZEOFNAME);
}
void Container:: addFriendName(char* friendName){
	strncpy(this->friendName, friendName, SIZEOFNAME);
}
void Container:: addInfo(Container info){
	myRol = info.myRol;
	friendRol = info.friendRol;
	for (int i = 0; i < CANTOFTILES; i++) 
		tiles[i] = info.tiles[i];
	for (int i = 0; i < CANTOFSTORM; i++)
		storm[i] = info.storm[i];
	for (int i = 0; i < CANTOFEQUIPMENT; i++)
		equipment[i] = info.equipment[i];
}

int myRand(int i){
	//funcion que genera numero aleatorio, se usa para ordenar los tiles, como callback
	return rand() % i;
}
</file>

<file path="src/Part.cpp">
#include "Part.hpp"

Part::Part() {
	if (partImage = al_load_bitmap("Resources/Parts/engineImage.png")) {
		column = -1;
		row = -1;
		found = false;
	}
	else{ cout << "Failed to run the Part's default constructor correctly" << endl; }
}
Part::Part(const char* partImageName) {
	if (this->partImage = al_load_bitmap(partImageName)) {
		if (pickUpSound = al_load_sample("Resources/Sounds/pickUpPart.wav")) {
			column = -1;
			row = -1;
			found = false;
			picked = false;
		}
	}
	else{ cout << "Failed to load " << partImageName << endl; }
}
void Part::updatePart(ALL* allegro) {
	if (found) {
		al_draw_bitmap(partImage, partCoords.x, partCoords.y, 0);
	}
}
void Part::findColum(int newColumn, ALL* allegro) {
	column = newColumn;
	if (row != -1) {
		found = true;
		partCoords = updateCoords(allegro);						//This actualy create the pos of the part for it to be displayed
	}
}
void Part::findRow(int newRow, ALL* allegro) {
	row = newRow;
	if (column != -1) {
		found = true;
		partCoords = updateCoords(allegro);
	}
}
void Part::pickUpPart(){
	found = false;
	picked = true;
	al_play_sample(pickUpSound, 1, 0, 1, ALLEGRO_PLAYMODE_ONCE, NULL);
}
void Part::setCardIndex(int index, ALL* allegro) {
	column = index / 5;
	row = index % 5;
	partCoords = updateCoords(allegro);
}
pos Part::updateCoords(ALL* allegro) {
	int n = allegro->screenWidth / 3.0;
	int yoffset = (allegro->screenHeight - n) / 2.0;
	int xoffset = n;
	pos tempPos;
	if(	partImage){
		int l = abs((n - al_get_bitmap_width(partImage) * 5) / 4);	//If the number is negative it souldn't run anyway... but at least it won't explote.
		tempPos.x = (column)*(al_get_bitmap_width(partImage) + l) + xoffset;
		tempPos.y = (row)*(al_get_bitmap_width(partImage) + l) + yoffset;
	}
	else {
		cout << "Failed to updateCoords, Part.cpp" << endl;
		tempPos.x=0;
		tempPos.y=0;
	}

		return tempPos;
}
Part::~Part(){
	al_destroy_bitmap(partImage);
	//al_destroy_sample(pickUpSound);
}
</file>

<file path="src/polo.c">
/**
 * libpolo
 * Lightweight graphics library for educational environments
 * (C) 2011 by the libpolo team.
 *     Marc S. Ressl (mressl@itba.edu.ar)
 *     Jorge Prendes (jprendes@itba.edu.ar)
 * Released under the GPL
 *
 * Requires the glut library.
 */

/* Includes */

#include <math.h>
#include <stdio.h>
#include <stdlib.h>

#include "polo.h"

#if (!defined(_WIN32) && !defined(__APPLE__))
#include <GL/glx.h>
#endif

#ifdef _WIN32
//#include <GL/glext.h>
#endif

#ifndef M_PI
#define M_PI    3.14159265358979323846
#endif

#ifndef GL_BGRA
#define GL_BGRA GL_BGRA_EXT
#endif

#ifndef GL_BGR
#define GL_BGR GL_BGR_EXT
#endif



/* Definitions */
#define POLO_MOUSEBUTTON_NUM    3
#define POLO_MAX_IMAGES         1024

typedef void (*PoloSwapControl)(int value);

typedef struct
{
	GLuint texture;
	int textureWidth;
	int textureHeight;
	int width;
	int height;
} PoloImage;

typedef struct
{
	int isInitialized;
	void *userData;
	void (*drawCallback)(void *userData);
	void (*keyboardCallback)(void *userData, int key);
	void (*mouseMotionCallback)(void *userData, int x, int y);
	void (*mouseButtonCallback)(void *userData, int button, int state);
	void (*timerCallback)(void *userData, int id);
	Color penColor;
	Color fillColor1;
	Color fillColor2;
	PoloImage images[POLO_MAX_IMAGES];
	Color drawTint;
	float drawScale;
	void *font;
	float fontHeight;
	float fontBaseLine;
	int key;
	float mouseX;
	float mouseY;
	int mouseButtonState[POLO_MOUSEBUTTON_NUM];
} PoloState;

typedef struct
{
	unsigned char id[2];
	unsigned char size[4];
	unsigned char reserved[4];
	unsigned char pixelsOffset[4];
	unsigned char headerSize[4];
	unsigned char width[4];
	unsigned char height[4];
	unsigned char numberOfPlanes[2];
	unsigned char bitsPerPixel[2];
	unsigned char compression[4];
} PoloBMPHeader;



/* Static variables
   Note: static variables should always be avoided. They are used here
         because glut does not pass a user pointer to the callbacks. */
static PoloState poloState;



/* Private callbacks */
static void drawCallback()
{
	/* Configure OpenGL */
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	glTranslatef(-1.0, -1.0, 0.0);
	glScalef(2.0 / glutGet(GLUT_WINDOW_WIDTH),
	         2.0 / glutGet(GLUT_WINDOW_HEIGHT),
	         1.0);
	
	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();
	
	/* Call user callback */
	if (poloState.drawCallback)
		poloState.drawCallback(poloState.userData);
	
	updateScreen();
}

static void resizeCallback(int width, int height)
{
	glViewport(0, 0, width, height);
	
	clearScreen();
	updateScreen();
	clearScreen();
}

static void keyboardCallback(unsigned char key, int x, int y)
{
	poloState.key = key;
	
	if (poloState.keyboardCallback)
		poloState.keyboardCallback(poloState.userData,
		                           poloState.key);
}

static void specialCallback(int key, int x, int y)
{
	switch (key)
	{
		case GLUT_KEY_F1:
			poloState.key = POLO_F1;
			break;
		case GLUT_KEY_F2:
			poloState.key = POLO_F2;
			break;
		case GLUT_KEY_F3:
			poloState.key = POLO_F3;
			break;
		case GLUT_KEY_F4:
			poloState.key = POLO_F4;
			break;
		case GLUT_KEY_F5:
			poloState.key = POLO_F5;
			break;
		case GLUT_KEY_F6:
			poloState.key = POLO_F6;
			break;
		case GLUT_KEY_F7:
			poloState.key = POLO_F7;
			break;
		case GLUT_KEY_F8:
			poloState.key = POLO_F8;
			break;
		case GLUT_KEY_F9:
			poloState.key = POLO_F9;
			break;
		case GLUT_KEY_F10:
			poloState.key = POLO_F10;
			break;
		case GLUT_KEY_F11:
			poloState.key = POLO_F11;
			break;
		case GLUT_KEY_F12:
			poloState.key = POLO_F12;
			break;
		case GLUT_KEY_LEFT:
			poloState.key = POLO_LEFT;
			break;
		case GLUT_KEY_RIGHT:
			poloState.key = POLO_RIGHT;
			break;
		case GLUT_KEY_UP:
			poloState.key = POLO_UP;
			break;
		case GLUT_KEY_DOWN:
			poloState.key = POLO_DOWN;
			break;
		case GLUT_KEY_PAGE_UP:
			poloState.key = POLO_PAGEUP;
			break;
		case GLUT_KEY_PAGE_DOWN:
			poloState.key = POLO_PAGEDOWN;
			break;
		case GLUT_KEY_HOME:
			poloState.key = POLO_HOME;
			break;
		case GLUT_KEY_END:
			poloState.key = POLO_END;
			break;
		default:
			return;
	}
	
	if (poloState.keyboardCallback)
		poloState.keyboardCallback(poloState.userData,
		                           poloState.key);
}

static void mouseMotionCallback(int x, int y)
{
	poloState.mouseX = x;
	poloState.mouseY = glutGet(GLUT_WINDOW_HEIGHT) - y;
	
	if (poloState.mouseMotionCallback)
		poloState.mouseMotionCallback(poloState.userData,
		                              poloState.mouseX,
		                              poloState.mouseY);
}

static void mouseButtonCallback(int button, int state, int x, int y)
{
	switch (button)
	{
		case GLUT_LEFT_BUTTON:
			button = 0;
			break;
		case GLUT_RIGHT_BUTTON:
			button = 1;
			break;
		case GLUT_MIDDLE_BUTTON:
			button = 2;
			break;
		default:
			return;
	}
	
	if (state == GLUT_DOWN)
		poloState.mouseButtonState[button] = 1;
	else if (state == GLUT_UP)
		poloState.mouseButtonState[button] = 0;
	
	if (poloState.mouseButtonCallback)
		poloState.mouseButtonCallback(poloState.userData,
		                              button,
		                              poloState.mouseButtonState[button]);
	
	mouseMotionCallback(x, y);
}

static void timerCallback(int value)
{
	if (poloState.timerCallback)
		poloState.timerCallback(poloState.userData, value);
}



/* Initialization & exit */
void setPoloUserData(void *userData)
{
	poloState.userData = userData;
}

void initPolo(int width, int height, int fullscreen, const char *windowTitle)
{
	int argc = 1;
	int displayMode;
	const char *argv[2] = {"polo", NULL};
	
	if (poloState.isInitialized)
		return;
	
	/* Init state */
	setPenColor(POLO_WHITE);
	setFillColor(POLO_TRANSPARENT);
	setDrawTint(POLO_WHITE);
	setDrawScale(1.0);
	setTextFont(POLO_HELVETICA_18);
	
	/* Init glut */
	glutInit(&argc, (char **)argv);
	displayMode = GLUT_RGB | GLUT_DEPTH;
#ifndef __APPLE__
	displayMode |= GLUT_DOUBLE;
#endif /* __APPLE__ */
	glutInitWindowSize(width, height);
	glutInitDisplayMode(displayMode);
	glutCreateWindow(windowTitle);
	if (fullscreen)
		glutFullScreen();
	
	poloState.isInitialized = 1;
	
	/* Init glut run time (so it starts at 0 on all systems) */
	getTime();
	
	/* Set internal callbacks */
	glutDisplayFunc(drawCallback);
	glutReshapeFunc(resizeCallback);
	glutIdleFunc(drawCallback);
	glutKeyboardFunc(keyboardCallback);
	glutSpecialFunc(specialCallback);
	glutMotionFunc(mouseMotionCallback);
	glutMouseFunc(mouseButtonCallback);
	glutPassiveMotionFunc(mouseMotionCallback);
	
	/* Configure freeglut */
#ifdef USE_FREEGLUT
	glutSetOption(GLUT_ACTION_ON_WINDOW_CLOSE, GLUT_ACTION_GLUTMAINLOOP_RETURNS);	
#endif
	
	/* Enable vertical video sync */
#ifdef __APPLE__
	{
		const GLint sync = 1;
		CGLSetParameter(CGLGetCurrentContext(), kCGLCPSwapInterval, &sync);
	}
#endif
	
#ifdef GLX_VERSION_1_4
	{
		PoloSwapControl swapControl;
		swapControl = (PoloSwapControl) glXGetProcAddress((const GLubyte *) "glXSwapIntervalSGI");
		if (swapControl)
			swapControl(1);
	}
#endif
	
#ifdef _WIN32
	{
		PoloSwapControl swapControl;
		swapControl = (PoloSwapControl) wglGetProcAddress((const GLubyte *) "wglSwapInterval");
		if (swapControl)
			swapControl(1);
	}
#endif
	
	/* Configure OpenGL */
	glEnable(GL_BLEND);
	glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
	
	glEnable(GL_TEXTURE_2D);
	
	/* Clear front and back buffer */
	clearScreen();
	updateScreen();
	clearScreen();
}

void runPolo()
{
	glutMainLoop();
}

void exitPolo()
{
	if (!poloState.isInitialized)
		return;
	
#ifdef USE_FREEGLUT
	glutLeaveMainLoop();
	
	poloState.isInitialized = 0;
#else
	exit(0);
#endif
}



/* Drawing */

void setDrawCallback(void (*drawCallback)(void *userData))
{
	poloState.drawCallback = drawCallback;
}

static float saturate(float value)
{
	if (value < 0.0)
		return 0.0;
	if (value > 1.0)
		return 1.0;
	return value;
}

Color getColorFromRGBA(float red, float green, float blue, float alpha)
{
	float r = saturate(red);
	float g = saturate(green);
	float b = saturate(blue);
	float a = saturate(alpha);
	
	return ((((int)(r * 255.0)) << 24) +
	        (((int)(g * 255.0)) << 16) +
	        (((int)(b * 255.0)) << 8) +
	        (((int)(a * 255.0)) << 0));
}

Color getColorFromRGB(float red, float green, float blue)
{
	return getColorFromRGBA(red, green, blue, 1.0);
}

Color getColorFromHSVA(float hue, float saturation, float value, float alpha)
{
	float r, g, b;
	
	float h = hue - floor(hue);
	float s = saturate(saturation);
	float v = saturate(value);
	
	if (s == 0.0)
		r = g = b = v;
	else
	{
		float i, f, p, q, t;
		
		/* If hue == 1.0, then wrap it around the circle to 0.0 */
		if (h == 1.0)
			h = 0.0;
		
		/* Sector 0 to 5 */
		h *= 6.0;
		/* Integer part of h (0, 1, 2, 3, 4, 5 or 6) */
		i = floor(h);
		/* Factorial part of h (0 to 1) */
		f = h - i;
		
		p = v * (1.0f - s);
		q = v * (1.0f - s * f);
		t = v * (1.0f - s * (1.0f - f));
		
		switch ((int) h)
		{
			case 0:
				r = v;
				g = t;
				b = p;
				break;
			case 1:
				r = q;
				g = v;
				b = p;
				break;
			case 2:
				r = p;
				g = v;
				b = t;
				break;
			case 3:
				r = p;
				g = q;
				b = v;
				break;
			case 4:
				r = t;
				g = p;
				b = v;
				break;
			/* case 5 (or 6): */
			default:
				r = v;
				g = p;
				b = q;
				break;
		}
	}
	
	return getColorFromRGBA(r, g, b, alpha);
}

Color getColorFromHSV(float hue, float saturation, float value)
{
	return getColorFromHSVA(hue, saturation, value, 1.0);
}

void setPenColor(Color color)
{
	poloState.penColor = color;
}

void setFillColor(Color color)
{
	poloState.fillColor1 = color;
	poloState.fillColor2 = color;
}

void setFillGradient(Color color1, Color color2)
{
	poloState.fillColor1 = color1;
	poloState.fillColor2 = color2;
}

static void setPoloColor(Color color)
{
	if (!poloState.isInitialized)
		return;
	
	glColor4f(((color & 0xff000000) >> 24) / 255.0,
	          ((color & 0x00ff0000) >> 16) / 255.0,
	          ((color & 0x0000ff00) >> 8) / 255.0,
	          ((color & 0x000000ff) >> 0) / 255.0);
}

void drawPoint(float x, float y)
{
	if (!poloState.isInitialized)
		return;
	
	/* Translate coordinates to pixel center */
	glBegin(GL_POINTS);
	setPoloColor(poloState.penColor);
	glVertex2f(x + 0.5, y + 0.5);
	glEnd();
}

void drawLine(float x1, float y1, float x2, float y2)
{
	if (!poloState.isInitialized)
		return;
	
	x2 += (x2 == x1) ? 0 : ((x2 < x1) ? -1.0 : 1.0);
	y2 += (y2 == y1) ? 0 : ((y2 < y1) ? -1.0 : 1.0);
	
	/* Translate coordinates to pixel center */
	glBegin(GL_LINES);
	setPoloColor(poloState.penColor);
	glVertex2f(x1 + 0.5, y1 + 0.5);
	glVertex2f(x2 + 0.5, y2 + 0.5);
	glEnd();
}

void drawRect(float x, float y, float width, float height)
{
	if (!poloState.isInitialized)
		return;
	
	if ((width <= 0) || (height <= 0))
		return;
	
	glBegin(GL_QUADS);
	setPoloColor(poloState.fillColor2);
	glTexCoord2f(0, 0);
	glVertex2f(x, y);
	glTexCoord2f(1.0, 0);
	glVertex2f(x + width, y);
	setPoloColor(poloState.fillColor1);
	glTexCoord2f(1.0, 1.0);
	glVertex2f(x + width, y + height);
	glTexCoord2f(0.0, 1.0);
	glVertex2f(x, y + height);
	glEnd();
	
	/* Translate coordinates to pixel center */
	glBegin(GL_LINE_LOOP);
	setPoloColor(poloState.penColor);
	glVertex2f(x + 0.5, y + 0.5);
	glVertex2f(x + width - 0.5, y + 0.5);
	glVertex2f(x + width - 0.5, y + height - 0.5);
	glVertex2f(x + 0.5, y + height - 0.5);
	glEnd();
}

void drawRoundedRect(float x, float y, float width, float height, float edgeRadius)
{
	float maxEdgeRadius;
	int i;
	
	if (!poloState.isInitialized)
		return;
	
	if ((width <= 0) || (height <= 0))
		return;
	
	maxEdgeRadius = (width < height) ? width / 2.0 : height / 2.0;
	if (edgeRadius < 0)
		edgeRadius = 0;
	if (edgeRadius > maxEdgeRadius)
		edgeRadius = maxEdgeRadius;
	
	glBegin(GL_QUAD_STRIP);
	for(i = 0; i <= 180; i++)
	{
		float phase = i * 2.0 * M_PI / 360.0;
		float xr = edgeRadius * cos(phase);
		float yr = edgeRadius * sin(phase);
		float xp, yp1, yp2;
		
		if (i < 90)
			xp = edgeRadius - xr + 1.0;
		else
			xp = width - edgeRadius - xr - 1.0;
		yp1 = -yr + edgeRadius;
		yp2 = height + yr - edgeRadius;
		
		setPoloColor(poloState.fillColor2);
		glTexCoord2f(xp / width, yp1 / height);
		glVertex2f(x + xp, y + yp1);
		setPoloColor(poloState.fillColor1);
		glTexCoord2f(xp / width, yp2 / height);
		glVertex2f(x + xp, y + yp2);
	}
	glEnd();
	
	/* Translate coordinates to pixel center */
	glBegin(GL_LINE_LOOP);
	setPoloColor(poloState.penColor);
	for(i = 0; i < 360; i++)
	{
		float phase = i * 2.0 * M_PI / 360.0;
		float xr = edgeRadius * cos(phase);
		float yr = edgeRadius * sin(phase);
		float xp, yp;
		
		if ((i < 90) || (i >= 270))
			xp = xr + x + width - edgeRadius - 0.5;
		else
			xp = xr + x + edgeRadius + 0.5;
		if (i <= 180)
			yp = yr + y + height - edgeRadius - 0.5;
		else
			yp = yr + y + edgeRadius + 0.5;
		
		glVertex2f(xp, yp);
	}
	glEnd();
}

void drawTriangle(float x1, float y1, float x2, float y2, float x3, float y3)
{
	if (!poloState.isInitialized)
		return;
	
	glBegin(GL_TRIANGLES);
	setPoloColor(poloState.fillColor2);
	glTexCoord2f(0, 0);
	glVertex2f(x1, y1);
	glTexCoord2f(1, 0);
	glVertex2f(x2, y2);
	setPoloColor(poloState.fillColor1);
	glTexCoord2f(1, 1);
	glVertex2f(x3, y3);
	glEnd();
	
	glBegin(GL_LINE_LOOP);
	setPoloColor(poloState.penColor);
	glVertex2f(x1, y1);
	glVertex2f(x2, y2);
	glVertex2f(x3, y3);
	glEnd();
}

void drawQuad(float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4)
{
	if (!poloState.isInitialized)
		return;
	
	glBegin(GL_QUADS);
	setPoloColor(poloState.fillColor2);
	glTexCoord2f(0, 0);
	glVertex2f(x1, y1);
	glTexCoord2f(1, 0);
	glVertex2f(x2, y2);
	setPoloColor(poloState.fillColor1);
	glTexCoord2f(1, 1);
	glVertex2f(x3, y3);
	glTexCoord2f(0, 1);
	glVertex2f(x4, y4);
	glEnd();
	
	glBegin(GL_LINE_LOOP);
	setPoloColor(poloState.penColor);
	glVertex2f(x1, y1);
	glVertex2f(x2, y2);
	glVertex2f(x3, y3);
	glVertex2f(x4, y4);
	glEnd();
}

void drawCircle(float x, float y, float radius)
{
	return drawRoundedRect(x - radius, y - radius, 2.0 * radius, 2.0 * radius, radius);
}

void clearScreen()
{
	if (!poloState.isInitialized)
		return;
	
	glClearColor(0.0, 0.0, 0.0, 0.0);
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
}

void updateScreen()
{
	if (!poloState.isInitialized)
		return;
	
	glutSwapBuffers();
}

float getScreenWidth()
{
	return glutGet(GLUT_WINDOW_WIDTH);
}

float getScreenHeight()
{
	return glutGet(GLUT_WINDOW_HEIGHT);
}

void setTextFont(enum PoloFont font)
{
	switch (font)
	{
		case POLO_COURIER_13:
			poloState.font = GLUT_BITMAP_8_BY_13;
			poloState.fontHeight = 14;
			poloState.fontBaseLine = 3;
			break;
		case POLO_COURIER_15:
			poloState.font = GLUT_BITMAP_9_BY_15;
			poloState.fontHeight = 16;
			poloState.fontBaseLine = 4;
			break;
		case POLO_TIMES_10:
			poloState.font = GLUT_BITMAP_TIMES_ROMAN_10;
			poloState.fontHeight = 14;
			poloState.fontBaseLine = 4;
			break;
		case POLO_TIMES_24:
			poloState.font = GLUT_BITMAP_TIMES_ROMAN_24;
			poloState.fontHeight = 29;
			poloState.fontBaseLine = 7;
			break;
		case POLO_HELVETICA_10:
			poloState.font = GLUT_BITMAP_HELVETICA_10;
			poloState.fontHeight = 14;
			poloState.fontBaseLine = 3;
			break;
		case POLO_HELVETICA_12:
			poloState.font = GLUT_BITMAP_HELVETICA_12;
			poloState.fontHeight = 16;
			poloState.fontBaseLine = 4;
			break;
		case POLO_HELVETICA_18:
			poloState.font = GLUT_BITMAP_HELVETICA_18;
			poloState.fontHeight = 23;
			poloState.fontBaseLine = 5;
			break;
	}
}

float getTextDrawWidth(const char *str)
{
	float maxLength = 0, currentLength = 0;
	
	if (!poloState.isInitialized)
		return 0;
	
	while(*str)
	{
		if(*str == '\n')
			currentLength = 0;
		else
			currentLength += glutBitmapWidth(poloState.font, *str);
		
		if(maxLength < currentLength)
			maxLength = currentLength;
		
		str++;
	}
	
	return maxLength;
}

float getTextDrawHeight(const char *str)
{
	int i = 1;

	if (!poloState.isInitialized)
		return 0;
	
	while (*str)
	{
		if (*str == '\n')
			i++;
		
		str++;
	}
	
	return i * poloState.fontHeight;
}

void drawText(float x, float y, const char *str)
{
	y += getTextDrawHeight(str);
	y += poloState.fontBaseLine;
	y -= poloState.fontHeight;
	
	setPoloColor(poloState.penColor);
	glRasterPos2f(x, y);
	while(*str)
	{
		if (*str == '\n')
		{
			y -= poloState.fontHeight;
			glRasterPos2f(x, y);
		}
		else
			glutBitmapCharacter(poloState.font, *str);
		
		str++;
	}
}

static unsigned int getLittleEndianValue(unsigned char *value, int bits)
{
	if (bits == 16)
		return (value[0] << 0) +
		       (value[1] << 8);
	else if (bits == 32)
		return (value[0] << 0) +
		       (value[1] << 8) +
		       (value[2] << 16) +
		       (value[3] << 24);
	
	return 0;
}

static int getNextPowerOf2(int value)
{
	value--;
	value |= value >> 1;
	value |= value >> 2;
	value |= value >> 4;
	value |= value >> 8;
	value |= value >> 16;
	value++;
	
	return value;
}

static Image getFreeImage()
{
	Image i;
	
	for (i = 1; i < POLO_MAX_IMAGES; i++)
		if (!poloState.images[i].texture)
			return i;
	
	return 0;
}

Image loadImage(const char *path)
{
	PoloBMPHeader bmpHeader;
	int pixelsOffset, width, height, numberOfPlanes, bytesPerPixel, compression;
	int valid = 1;
	Image image = 0;
	
	if (!poloState.isInitialized)
		return 0;
	
	FILE *fp = fopen(path, "rb");
	if (!fp)
		return 0;
	
	if (fread(&bmpHeader, sizeof(bmpHeader), 1, fp) != 1)
		valid = 0;
	
	if ((bmpHeader.id[0] != 'B') || (bmpHeader.id[1] != 'M'))
		valid = 0;
	
	pixelsOffset = getLittleEndianValue(bmpHeader.pixelsOffset, 32);
	width = getLittleEndianValue(bmpHeader.width, 32);
	height = getLittleEndianValue(bmpHeader.height, 32);
	numberOfPlanes = getLittleEndianValue(bmpHeader.numberOfPlanes, 16);
	bytesPerPixel = getLittleEndianValue(bmpHeader.bitsPerPixel, 16) / 8;
	compression = getLittleEndianValue(bmpHeader.compression, 32);
	
	if ((width > 4096) || (height > 4096) || (height < -4096) ||
	    (numberOfPlanes != 1) ||
	    ((bytesPerPixel != 3) && (bytesPerPixel != 4)))
		valid = 0;
	
	if (valid)
	{
		/* OpenGL requires a textures of size 2 ^ m by 2 ^ n */
		int textureWidth = getNextPowerOf2(width);
		int textureHeight = getNextPowerOf2(abs(height));
		
		char *p = (char *)calloc(textureWidth * textureHeight, bytesPerPixel);
		int y;
		
		if (p)
		{
			int padding = (4 - (width * bytesPerPixel) & 0x3) & 0x3;
			
			fseek(fp, pixelsOffset, SEEK_SET);
			
			/* Read image line by line */
			if (height >= 0)
				for (y = 0; y < height; y++)
				{
					fread(&p[y * textureWidth * bytesPerPixel],
					      width * bytesPerPixel, 1, fp);
					fseek(fp, padding, SEEK_CUR);
				}
			else
				for (y = -height - 1; y >= 0; y--)
				{
					fread(&p[y * textureWidth * bytesPerPixel],
					      width * bytesPerPixel, 1, fp);
					fseek(fp, padding, SEEK_CUR);
				}
			
			image = getFreeImage();
			if (image)
			{
				PoloImage *poloImage = &poloState.images[image];
				
				glGenTextures(1, &(poloImage->texture));
				
				glBindTexture(GL_TEXTURE_2D, poloImage->texture);
				
				glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
				glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
				
				glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
				glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
				
				glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8,
				             textureWidth, textureHeight,
				             0, (bytesPerPixel == 4) ? GL_BGRA : GL_BGR,
				             GL_UNSIGNED_BYTE, p);
				
				glBindTexture(GL_TEXTURE_2D, 0);
				
				poloImage->textureWidth = textureWidth;
				poloImage->textureHeight = textureHeight;
				poloImage->width = width;
				poloImage->height = abs(height);
			}
			
			free(p);
		}
	}
	
	fclose(fp);
	
	return image;
}

float getImageWidth(Image image)
{
	if (image >= POLO_MAX_IMAGES)
		return 0;
	
	return poloState.images[image].width;
}

float getImageHeight(Image image)
{
	if (image >= POLO_MAX_IMAGES)
		return 0;
	
	return poloState.images[image].height;
}

void freeImage(Image image)
{
	if (!poloState.isInitialized)
		return;
	
	if (image >= POLO_MAX_IMAGES)
		return;
	
	glDeleteTextures(1, &poloState.images[image].texture);
	
	poloState.images[image].texture = 0;
	poloState.images[image].textureWidth = 0;
	poloState.images[image].textureHeight = 0;
	poloState.images[image].width = 0;
	poloState.images[image].height = 0;
}

void drawImage(float x, float y, Image image)
{
	PoloImage *theImage;
	float scale;
	float texCoordWidth, texCoordHeight;
	
	if (!poloState.isInitialized)
		return;
	
	if (image >= POLO_MAX_IMAGES)
		return;
	
	theImage = &poloState.images[image];
	scale = poloState.drawScale;
	
	if (!theImage->texture)
		return;
	
	texCoordWidth = ((float) theImage->width) / theImage->textureWidth;
	texCoordHeight = ((float) theImage->height) / theImage->textureHeight;
	
	glBindTexture(GL_TEXTURE_2D, theImage->texture);
	setPoloColor(poloState.drawTint);
	
	glBegin(GL_QUADS);
	glTexCoord2f(0, 0);
	glVertex2f(x, y);
	glTexCoord2f(texCoordWidth, 0);
	glVertex2f(x + theImage->width * scale, y);
	glTexCoord2f(texCoordWidth, texCoordHeight);
	glVertex2f(x + theImage->width * scale, y + theImage->height * scale);
	glTexCoord2f(0, texCoordHeight);
	glVertex2f(x, y + theImage->height * scale);
	glEnd();
	
	glBindTexture(GL_TEXTURE_2D, 0);	
}

void setDrawTint(Color tint)
{
	poloState.drawTint = tint;
}

void setDrawScale(float scale)
{
	poloState.drawScale = scale;
}

void setTexture(Image image)
{
	PoloImage *poloImage;
	
	if (!poloState.isInitialized)
		return;
	
	if (image >= POLO_MAX_IMAGES)
		return;
	
	poloImage = &poloState.images[image];
	
	glBindTexture(GL_TEXTURE_2D, poloImage->texture);
}



/* Keyboard */

void setKeyboardCallback(void (*keyboardCallback)(void *userData, int key))
{
	poloState.keyboardCallback = keyboardCallback;
}

int getKey()
{
	return poloState.key;
}

void clearKey()
{
	poloState.key = 0;
}



/* Mouse */

void setMouseMotionCallback(void (*mouseMotionCallback)(void *userData, int x, int y))
{
	poloState.mouseMotionCallback = mouseMotionCallback;
}

void setMouseButtonCallback(void (*mouseButtonCallback)(void *userData, int button, int pressed))
{
	poloState.mouseButtonCallback = mouseButtonCallback;
}

float getMouseX()
{
	return poloState.mouseX;
}

float getMouseY()
{
	return poloState.mouseY;
}

int isMouseButtonPressed(int buttonIndex)
{
	if (buttonIndex >= POLO_MOUSEBUTTON_NUM)
		return 0;
	
	return poloState.mouseButtonState[buttonIndex];
}

void showMousePointer()
{
	glutSetCursor(GLUT_CURSOR_LEFT_ARROW);
}

void hideMousePointer()
{
	glutSetCursor(GLUT_CURSOR_NONE);
}



/* Time */

void setTimerCallback(void (*timerCallback)(void *userData, int id))
{
	poloState.timerCallback = timerCallback;
}

void runTimer(int id, int milliseconds)
{
	if (!poloState.isInitialized)
		return;
	
	glutTimerFunc(milliseconds, timerCallback, id);
}

float getTime()
{
	if (!poloState.isInitialized)
		return 0;
	
	return glutGet(GLUT_ELAPSED_TIME) * 0.001;
}
</file>

<file path="src/polonet.c">
/**
 * libpolonet
 * Lightweight TCP/IP network module for educational environments
 * (C) 2011 by the libpolo team.
 *     Marc S. Ressl (mressl@itba.edu.ar)
 *     Jorge Prendes (jprendes@itba.edu.ar)
 *     Agustin Perez Moreno
 * Released under the GPL
 */

#ifdef _WIN32
#include <winsock.h>
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/time.h>
#include <sys/ioctl.h> /* for FIONREAD (sigh) */
#include <netinet/in.h>
#include <netdb.h>
#include <unistd.h>
#include <fcntl.h>
#endif

#ifndef FIONREAD
#include <sys/filio.h> /* Solaris 2 puts it here */
#endif

#include <stdio.h>
#include <string.h>
#include "polonet.h"

static int fdserver = -1;

/*
 * Public functions
 */

static int polonetInitWSA()
{
#ifdef WIN32
	static int isWSAInitialized = 0;
	
	if (!isWSAInitialized)
	{
		WSADATA wsaData;
		WORD wsaVersion = MAKEWORD(2, 0);
		
		if (WSAStartup(wsaVersion, &wsaData))
			return 0;
		
		isWSAInitialized = 1;
	}
#endif	
	return 1;
}

static int polonetSetNonBlocking(int fd)
{
#ifdef WIN32
	unsigned long isNonBlocking = 1;
	return ioctlsocket(fd, FIONBIO, &isNonBlocking) != -1;
#else
	int flags = fcntl(fd, F_GETFL, 0);
	if (flags == -1)
		return 0;
	
	return fcntl(fd, F_SETFL, flags | O_NONBLOCK) != -1;
#endif
}

static int polonetSetReuseAddress(int fd)
{
#ifndef WIN32
	int value = 1;
	if (setsockopt(fdserver, SOL_SOCKET, SO_REUSEADDR,
	               &value, sizeof(value)) == -1)
		return 0;
#endif
	return 1;
}

static void polonetCloseSocket(int fd)
{
	if (fd == -1)
		return;
#ifdef WIN32
	closesocket(fd);
#else
	close(fd);
#endif
}

/*
 * Public functions
 */

int startListening(unsigned short port)
{
	struct sockaddr_in sin;
	
	/* Open server socket */
	polonetInitWSA();
	polonetCloseSocket(fdserver);
	
	if ((fdserver = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) == -1)
		return 0;
	
	polonetSetNonBlocking(fdserver);
	polonetSetReuseAddress(fdserver);
	
	memset(&sin, 0, sizeof(sin));
	sin.sin_family = AF_INET;
	sin.sin_addr.s_addr = htonl(INADDR_ANY);
	sin.sin_port = htons(port);
	
	if (bind(fdserver, (struct sockaddr *) &sin, sizeof(sin)) == -1)
	{
		polonetCloseSocket(fdserver);
		return 0;
	}
	
	if (listen(fdserver, 100) == -1)
	{
		polonetCloseSocket(fdserver);
		return 0;
	}
	
	return 1;
}

void stopListening()
{
	polonetCloseSocket(fdserver);
	fdserver = -1;
}

PolonetConn getAvailableConnection()
{
	fd_set fdsRead;
	struct timeval nowait;
	int fd;	
	
	if (fdserver == -1)
		return 0;
	
	FD_ZERO(&fdsRead);
	FD_SET((unsigned int) fdserver, &fdsRead);
	
	memset((char *)&nowait, 0, sizeof(nowait));
	
	if (select(fdserver + 1, &fdsRead, NULL, NULL, &nowait) == -1)
		return 0;
	
	if (!FD_ISSET(fdserver, &fdsRead))
		return 0;
	
	fd = accept(fdserver, NULL, NULL);
	
	polonetSetNonBlocking(fd);
	
	return fd + 1;
}

PolonetConn openConnection(const char *hostname, unsigned short port)
{
	struct hostent *host;
	struct sockaddr_in sin;
	int fd;
	
	polonetInitWSA();
	
	if ((host = gethostbyname(hostname)) == 0)
		return 0;
	
	if ((fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) == -1)
		return 0;
	
	polonetSetNonBlocking(fd);
	
	memset(&sin, 0, sizeof(sin));
	sin.sin_family = AF_INET;
	sin.sin_addr.s_addr = ((struct in_addr *) (host->h_addr))->s_addr;
	sin.sin_port = htons(port);
	
	connect(fd, (struct sockaddr *) &sin, sizeof(sin));
	
	return fd + 1;
}

int isPending(PolonetConn conn)
{
	fd_set fdsRead, fdsWrite, fdsExcept;
	struct timeval nowait;
	int fd = conn - 1;
	
	if (fd == -1)
		return 0;
	
	FD_ZERO(&fdsRead);
	FD_SET((unsigned int) fd, &fdsRead);
	FD_ZERO(&fdsWrite);
	FD_SET((unsigned int) fd, &fdsWrite);
	FD_ZERO(&fdsExcept);
	FD_SET((unsigned int) fd, &fdsExcept);
	
	memset((char *)&nowait, 0, sizeof(nowait));
	
	if (select(fd + 1, &fdsRead, &fdsWrite, &fdsExcept, &nowait) == -1)
		return 0;
	
	/* Not pending on (fdsRead | fdsWrite) */
	if (FD_ISSET(fd, &fdsRead))
		return 0;
	if (FD_ISSET(fd, &fdsWrite))
		return 0;
	/* Not pending on fdsException */	
	if (FD_ISSET(fd, &fdsExcept))
		return 0;
	
	return 1;
}

int isConnected(PolonetConn conn)
{
	fd_set fdsRead, fdsWrite, fdsExcept;
	struct timeval nowait;
	int fd = conn - 1;
	
	if (fd == -1)
		return 0;
	
	FD_ZERO(&fdsRead);
	FD_SET((unsigned int) fd, &fdsRead);
	FD_ZERO(&fdsWrite);
	FD_SET((unsigned int) fd, &fdsWrite);
	FD_ZERO(&fdsExcept);
	FD_SET((unsigned int) fd, &fdsExcept);
	
	memset((char *)&nowait, 0, sizeof(nowait));
	
	if (select(fd + 1, &fdsRead, &fdsWrite, &fdsExcept, &nowait) == -1)
		return 0;
	
	/* Disconnected if fdsRead but no bytes available for reading */
	if (FD_ISSET(fd, &fdsRead))
	{
		int bytesAvailable;
#ifdef WIN32
		if (ioctlsocket(fd, FIONREAD, &bytesAvailable) == -1)
#else
		if (ioctl(fd, FIONREAD, &bytesAvailable) == -1)
#endif
			return 0;
		if (bytesAvailable <= 0)
			return 0;
	}
	/* Disconnected on !fdsWrite */
	if (!FD_ISSET(fd, &fdsWrite))
		return 0;
	/* Disconnected on fdsException */
	if (FD_ISSET(fd, &fdsExcept))
		return 0;
	
	return 1;
}

int sendData(PolonetConn conn, char *buffer, const int bufferSize)
{
	int fd = conn - 1;
	int status;

	if (fd == -1)
		return 0;
	
	status = send(fd, buffer, bufferSize, 0);
	if (status == -1)
		return 0;
	
	return status;
}

int receiveData(PolonetConn conn, char *buffer, const int bufferSize)
{
	int fd = conn - 1;
	int status;

	if (fd == -1)
		return 0;

	status = recv(fd, buffer, bufferSize, 0);
	if (status == -1)
		return 0;
	
	return status;
}

void closeConnection(PolonetConn conn)
{
	int fd = conn - 1;
	
	polonetCloseSocket(fd);
}
</file>

<file path="src/SinglePlayerGame.cpp">
//
// Created by barrachina on 12/21/18.
//

#include <include/SinglePlayerGame.hpp>

#include "SinglePlayerGame.hpp"

#define TERRASCOPE_PEEP_TIME 600000

/**
 * Single Player Constructor
 * */
SinglePlayerGame::SinglePlayerGame(ALL *allegro, Container *info_in) {
    info = *info_in;
    //allegro->volume = 1;
    if (initializeAllegro(allegro)) {
        //Characters
        initializeCharacters(info, allegro);
        //Buttons
        initializeButtons(allegro);
        //Cards and Decks
        initializeBoard(allegro);
        initializeStormCards(allegro);
        //Parts
        engine = new Part("Resources/Parts/engineImage.png");
        solarCrystal = new Part("Resources/Parts/solarCrystalImage.png");
        propeller = new Part("Resources/Parts/propellerImage.png");
        navigationDeck = new Part("Resources/Parts/navegationDeckImage.png");
        //Indexes
        equipIndex = 0;            //TODO: eliminar esto en un futuro
        peepOffset = 0;
        //Data
        SandMarkersLeft = 40;
        sandStormLevel = 3; //TODO: CUAL ERA EL NUMERO REAL? (era 3 jaja igual no cuesta NADA dejar a el jugador elegir la dificultad y queda mas copado)

        mouse.x = static_cast<int>(allegro->screenWidth / 2.0);
        mouse.y = static_cast<int>(allegro->screenHeight / 2.0);
        redraw = true;
        gameOver = false;
        playAgain = false;

        modeEnum = NORMAL;
    } else { cerr << "Couldn't initialize allegro" << endl; }
}
void SinglePlayerGame::updateScreen(ALL *allegro) {
#ifdef DEBUG_UPDATE_SCREEN
    cout << "Update Screen" << endl;
#endif
    /* Updates the screen */
    redraw = false;
    switch (modeEnum) {
        case PEEPMODE:
            if (firstTimeUpdateScreenPeep == 0) {
                al_draw_bitmap(allegro->menuBackgroundImage, 0, 0, 0);
                firstTimeUpdateScreenPeep++;
            }
            stormCardsDeck[peepOffset]->peepShowImage(allegro);
            nextButton->updateButton(allegro);
            previousButton->updateButton(allegro);
            selectPeepCard->updateButton(allegro);
            break;
        case OFFEREQUIPMENTMODE:
            if (firstTimeUpdateScreenChooseEquipment == 0) {
                al_draw_bitmap(allegro->menuBackgroundImage, 0, 0, 0);
                firstTimeUpdateScreenChooseEquipment++;
                if (character->haveDuneBlaster())
                    equipOffset = DUNEBLAST;
                else if (character->haveJetPack())
                    equipOffset = JETPACK;
                else if (character->haveSolarShield())
                    equipOffset = SOLARSHIELD;
                else if (character->haveTerrascope())
                    equipOffset = TERRASCOPE;
                else if (character->haveTimeThrottle())
                    equipOffset = TIMETHROTTLE;
            }
            al_draw_bitmap(allegro->equipmentCards[equipOffset - 1],
                           (allegro->screenWidth - al_get_bitmap_width(allegro->equipmentCards[equipOffset - 1])) / 2,
                           (allegro->screenHeight - al_get_bitmap_height(allegro->equipmentCards[equipOffset - 1])) / 2,
                           0);
            nextButton->updateButton(allegro);
            previousButton->updateButton(allegro);
            selectEquipmentCard->updateButton(allegro);
            break;
        case REQUESTEQUIPMENTMODE:
            if (firstTimeUpdateScreenChooseEquipment == 0) {
                al_draw_bitmap(allegro->menuBackgroundImage, 0, 0, 0);
                firstTimeUpdateScreenChooseEquipment++;
                if (character2->haveDuneBlaster())
                    equipOffset = DUNEBLAST;
                else if (character2->haveJetPack())
                    equipOffset = JETPACK;
                else if (character2->haveSolarShield())
                    equipOffset = SOLARSHIELD;
                else if (character2->haveTerrascope())
                    equipOffset = TERRASCOPE;
                else if (character2->haveTimeThrottle())
                    equipOffset = TIMETHROTTLE;
            }
            al_draw_bitmap(allegro->equipmentCards[equipOffset - 1],
                           (allegro->screenWidth - al_get_bitmap_width(allegro->equipmentCards[equipOffset - 1])) / 2,
                           (allegro->screenHeight - al_get_bitmap_height(allegro->equipmentCards[equipOffset - 1])) / 2,
                           0);
            nextButton->updateButton(allegro);
            previousButton->updateButton(allegro);
            selectEquipmentCard->updateButton(allegro);
            break;
        default:
#ifdef DEBUG_UPDATE_SCREEN
            cout << "Default case" << endl;
#endif
            al_clear_to_color(al_map_rgb(0, 0, 0));
            al_draw_bitmap(allegro->fondo, 0, 0, 0);
            //Update Tiles
#ifdef DEBUG_UPDATE_SCREEN
            cout << "Update Tiles" << endl;
#endif
            pos tempPos;
            for (uint i = 0; i < tilesDeck.size(); i++) {
                tempPos = getSpot(i % 5, i / 5, allegro, tilesDeck[i]->getTileBackImage());
                tilesDeck[i]->setCoord(tempPos);
            }
            for (auto &i : tilesDeck) {
                i->updateTile(allegro);
            }
            //End of Turn Button
#ifdef DEBUG_UPDATE_SCREEN
            cout << "Update End of Turn Button" << endl;
#endif
            endTurnButton->updateButton(allegro);
            if (allegro->volume == 0) { muteButton->updateButton(allegro); }
            else { noMuteButton->updateButton(allegro); }
            //Tiles Buttons
#ifdef DEBUG_UPDATE_SCREEN
            cout << "Update Tiles Button" << endl;
#endif
            updateTilesButton(allegro); // Don't let the player think he can still move
            //Update Characters
#ifdef DEBUG_UPDATE_SCREEN
            cout << "Update Characters" << endl;
#endif
            character->updateChar(allegro, 1, endTurnButton->getMiddleOfX(), endTurnButton->getMiddleOfY()); //Character must be after Tiles
            character2->updateChar(allegro, 2);

            //Update Parts
#ifdef DEBUG_UPDATE_SCREEN
            cout << "Update Parts" << endl;
#endif
            propeller->updatePart(allegro);
            solarCrystal->updatePart(allegro);
            navigationDeck->updatePart(allegro);
            engine->updatePart(allegro);
            int i = 0;
            if (engine->getPickedState()) {
                al_draw_bitmap(allegro->partsImages[i], allegro->screenWidth / 4, allegro->screenHeight / 5 + i *
                                                                                                              al_get_bitmap_height(allegro->partsImages[i]), 0);
            } else {
                al_draw_bitmap(allegro->partsImages[i + 4], allegro->screenWidth / 4,
                               allegro->screenHeight / 5 + i * al_get_bitmap_height(allegro->partsImages[i]), 0);
            }
            i++;
            if (navigationDeck->getPickedState()) {
                al_draw_bitmap(allegro->partsImages[i], allegro->screenWidth / 4, allegro->screenHeight / 5 + i *
                                                                                                              al_get_bitmap_height(allegro->partsImages[i]), 0);
            } else {
                al_draw_bitmap(allegro->partsImages[i + 4], allegro->screenWidth / 4,
                               allegro->screenHeight / 5 + i * al_get_bitmap_height(allegro->partsImages[i]), 0);
            }
            i++;
            if (propeller->getPickedState()) {
                al_draw_bitmap(allegro->partsImages[i], allegro->screenWidth / 4, allegro->screenHeight / 5 + i *
                                                                                                              al_get_bitmap_height(allegro->partsImages[i]), 0);
            } else {
                al_draw_bitmap(allegro->partsImages[i + 4], allegro->screenWidth / 4,
                               allegro->screenHeight / 5 + i * al_get_bitmap_height(allegro->partsImages[i]), 0);
            }
            i++;
            if (solarCrystal->getPickedState()) {
                al_draw_bitmap(allegro->partsImages[i], allegro->screenWidth / 4, allegro->screenHeight / 5 + i *
                                                                                                              al_get_bitmap_height(allegro->partsImages[i]), 0);
            } else {
                al_draw_bitmap(allegro->partsImages[i + 4], allegro->screenWidth / 4,
                               allegro->screenHeight / 5 + i * al_get_bitmap_height(allegro->partsImages[i]), 0);
            }
            //Buttons
            for (int i = 0; i < MODEBUTTONSNUMBER; i++) {
                modesButtons[i]->updateButton(allegro);
            }
            if (MeteorologistCharacter *meteorologistCharacter = dynamic_cast<MeteorologistCharacter *>(character)) {
                meteorologistCharacter->updateMeteorologistButton(allegro);    //Only display the button for the one who can use it... XD
            } else if (ClimberCharacter *climberCharacter = dynamic_cast<ClimberCharacter *>(character)) {
                climberCharacter->updateClimber(allegro);
            } else if (WaterCarrierCharacter *waterCarrierCharacter = dynamic_cast<WaterCarrierCharacter *>(character)) {
                bool imOnTurnedWell = (tilesDeck[character->getCardIndex()]->gettileType() == WATER &&
                                       tilesDeck[character->getCardIndex()]->isTurned());
                waterCarrierCharacter->updateGetWatersFromWell(imOnTurnedWell, allegro);
            } else if (NavigatorCharacter *navigatorCharacter = dynamic_cast<NavigatorCharacter *>(character)) {
                navigatorCharacter->updateNavigator(allegro, modeEnum == MOVEOTHER);
            }
            //Sand Storm Level Meter
            if (sandStormLevel < 15) {
                al_draw_bitmap(allegro->stormMeter[sandStormLevel], allegro->screenWidth * 12 / 17,
                               allegro->screenHeight - al_get_bitmap_height(allegro->stormMeter[sandStormLevel]), 0);
            }
            //Sand Markers Left (TEXT)
            if (SandMarkersLeft < 0) { SandMarkersLeft = 0; }
            al_draw_textf(allegro->gameFont, al_map_rgb(BLACK), allegro->screenWidth * 30 / 34,
                          allegro->screenHeight * 25 / 32, ALLEGRO_ALIGN_LEFT, "%d", SandMarkersLeft);
#ifdef DEBUG_UPDATE_SCREEN
            cout << "Default case done" << endl;
#endif
    }
    if (modeEnum == OFFERWATERMODE || modeEnum == REQUESTWATERMODE) {
        al_draw_bitmap(allegro->menuBackgroundImage, 0, 0, 0);
        al_draw_text(allegro->font, al_map_rgb(WHITE), allegro->screenWidth * 0.5,
                     watersButton[0]->getInitialPos().y - 55, ALLEGRO_ALIGN_CENTRE, "How many waters?");
        if (modeEnum == OFFERWATERMODE) {
            for (int i = 0; i < min(character->getWaters(), MAXWATERS - character2->getWaters() - 1); i++)
                watersButton[i]->updateButton(allegro);//update all the waters Button
        } else if (modeEnum == REQUESTWATERMODE) {
            for (int i = 0; i < min((MAXWATERS - character->getWaters() - 1), character2->getWaters()); i++)
                watersButton[i]->updateButton(allegro);//update all the waters Button
        }
    }
    al_flip_display();
#ifdef DEBUG_UPDATE_SCREEN
    cout << "Update Done" << endl;
#endif
}
void SinglePlayerGame::updateTilesButton(ALL *allegro) {
#ifdef DEBUG_UPDATE_SCREEN
    cout << "Update Tiles Button" << endl;
#endif
    //Equipments Mode
    if (modeEnum == JETPACKMODE) {
        for (int i = 0; i < TILEDECKNUMBER; i++) {
            if (tilesDeck[i]->canIMove(false)) {
                tilesDeck[i]->updateButton(allegro);
            }
        }
    } else if (modeEnum == TERRASCOPEMODE) {
        for (int i = 0; i < TILEDECKNUMBER; i++)
            if (tilesDeck[i]->gettileType() != STORM && !tilesDeck[i]->isTurned()) {
                tilesDeck[i]->updateButton(allegro);
            }
    } else {
        int tempIndex;
        bool climber = false;
        //Normal Movements
        if (modeEnum == MOVEOTHER) {
            tempIndex = character2->getCardIndex();
            if (ClimberCharacter *climberCharacter = dynamic_cast<ClimberCharacter *>(character2)) { climber = true; }
        } else {
            tempIndex = character->getCardIndex();
            if ((tilesDeck[tempIndex]->haveSand() || !tilesDeck[tempIndex]->isTurned())) { tilesDeck[tempIndex]->updateButton(allegro); }
            if (ClimberCharacter *climberCharacter = dynamic_cast<ClimberCharacter *>(character)) { climber = true; }
        }
        if (tilesDeck[tempIndex]->canIMove(climber)) {
            if (modeEnum == NORMAL || modeEnum == MOVEOTHER) {
                if (tempIndex > 0 && tempIndex % 5 != 0) {
                    if (tilesDeck[tempIndex - 1]->canIMove(climber)) {
                        tilesDeck[tempIndex - 1]->updateButton(allegro);
                    }
                }
                if (tempIndex < TILEDECKNUMBER - 1 && tempIndex % 5 != 4) {
                    if (tilesDeck[tempIndex + 1]->canIMove(climber)) {
                        tilesDeck[tempIndex + 1]->updateButton(allegro);
                    }
                }
                if (tempIndex > 4) {
                    if (tilesDeck[tempIndex - 5]->canIMove(climber)) {
                        tilesDeck[tempIndex - 5]->updateButton(allegro);
                    }
                }
                if (tempIndex < TILEDECKNUMBER - 5) {
                    if (tilesDeck[tempIndex + 5]->canIMove(climber)) {
                        tilesDeck[tempIndex + 5]->updateButton(allegro);
                    }
                }
                if (modeEnum == NORMAL) {
                    if (ExplorerCharacter *explorerCharacter = dynamic_cast<ExplorerCharacter *>(character)) {
                        if (tempIndex > 5 && tempIndex % 5 != 0) {
                            if (tilesDeck[tempIndex - 6]->canIMove(climber)) {
                                tilesDeck[tempIndex - 6]->updateButton(allegro);
                            }
                        }
                        if (tempIndex > 4 && tempIndex % 5 != 4) {
                            if (tilesDeck[tempIndex - 4]->canIMove(climber)) {
                                tilesDeck[tempIndex - 4]->updateButton(allegro);
                            }
                        }
                        if (tempIndex < TILEDECKNUMBER - 4 && tempIndex % 5 != 0) {
                            if (tilesDeck[tempIndex + 4]->canIMove(climber)) {
                                tilesDeck[tempIndex + 4]->updateButton(allegro);
                            }
                        }
                        if (tempIndex < TILEDECKNUMBER - 6 && tempIndex % 5 != 4) {
                            if (tilesDeck[tempIndex + 6]->canIMove(climber)) {
                                tilesDeck[tempIndex + 6]->updateButton(allegro);
                            }
                        }
                    }
                } else if (modeEnum == MOVEOTHER) {
                    if (ExplorerCharacter *explorerCharacter = dynamic_cast<ExplorerCharacter *>(character2)) {
                        if (tempIndex > 5 && tempIndex % 5 != 0) {
                            if (tilesDeck[tempIndex - 6]->canIMove(climber)) {
                                tilesDeck[tempIndex - 6]->updateButton(allegro);
                            }
                        }
                        if (tempIndex > 4 && tempIndex % 5 != 4) {
                            if (tilesDeck[tempIndex - 4]->canIMove(climber)) {
                                tilesDeck[tempIndex - 4]->updateButton(allegro);
                            }
                        }
                        if (tempIndex < TILEDECKNUMBER - 4 && tempIndex % 5 != 0) {
                            if (tilesDeck[tempIndex + 4]->canIMove(climber)) {
                                tilesDeck[tempIndex + 4]->updateButton(allegro);
                            }
                        }
                        if (tempIndex < TILEDECKNUMBER - 6 && tempIndex % 5 != 4) {
                            if (tilesDeck[tempIndex + 6]->canIMove(climber)) {
                                tilesDeck[tempIndex + 6]->updateButton(allegro);
                            }
                        }
                    }
                }
            }
            if (modeEnum == REMOVESAND || modeEnum == DUNEBLASTERMODE) {
                if (tempIndex > 0 && tempIndex % 5 != 0) {
                    if (tilesDeck[tempIndex - 1]->haveSand()) {
                        tilesDeck[tempIndex - 1]->updateButton(allegro);
                    }
                }
                if (tempIndex < TILEDECKNUMBER - 1 && tempIndex % 5 != 4) {
                    if (tilesDeck[tempIndex + 1]->haveSand()) {
                        tilesDeck[tempIndex + 1]->updateButton(allegro);
                    }
                }
                if (tempIndex > 4) {
                    if (tilesDeck[tempIndex - 5]->haveSand()) {
                        tilesDeck[tempIndex - 5]->updateButton(allegro);
                    }
                }
                if (tempIndex < TILEDECKNUMBER - 5) {
                    if (tilesDeck[tempIndex + 5]->haveSand()) {
                        tilesDeck[tempIndex + 5]->updateButton(allegro);
                    }
                }
                if (ExplorerCharacter *explorerCharacter = dynamic_cast<ExplorerCharacter *>(character)) {
                    if (tempIndex > 5 && tempIndex % 5 != 0) {
                        if (tilesDeck[tempIndex - 6]->haveSand()) {
                            tilesDeck[tempIndex - 6]->updateButton(allegro);
                        }
                    }
                    if (tempIndex > 4 && tempIndex % 5 != 4) {
                        if (tilesDeck[tempIndex - 4]->haveSand()) {
                            tilesDeck[tempIndex - 4]->updateButton(allegro);
                        }
                    }
                    if (tempIndex < TILEDECKNUMBER - 4 && tempIndex % 5 != 0) {
                        if (tilesDeck[tempIndex + 4]->haveSand()) {
                            tilesDeck[tempIndex + 4]->updateButton(allegro);
                        }
                    }
                    if (tempIndex < TILEDECKNUMBER - 6 && tempIndex % 5 != 4) {
                        if (tilesDeck[tempIndex + 6]->haveSand()) {
                            tilesDeck[tempIndex + 6]->updateButton(allegro);
                        }
                    }
                }
            }
            if (tilesDeck[tempIndex]->gettileType() == TUNNEL && tilesDeck[tempIndex]->isTurned()) {
                for (uint i = 0; i < tilesDeck.size(); i++) {
                    if (tilesDeck[i]->gettileType() == TUNNEL && i != tempIndex && tilesDeck[i]->isTurned()) {
                        if (tilesDeck[i]->canIMove(climber)) { tilesDeck[i]->updateButton(allegro); }
                    }
                }
            }
        }
    }
}
//! End of game methods
bool SinglePlayerGame::win(ALL *allegro) {
    /*Used to check if the players won*/
    if (engine->getPickedState() && solarCrystal->getPickedState() && propeller->getPickedState() &&
        navigationDeck->getPickedState()) {
        character->playGettingCloseSound();
        if (tilesDeck[character->getCardIndex()]->gettileType() == LAUNCHPAD) {
            if (tilesDeck[character2->getCardIndex()]->gettileType() == LAUNCHPAD) {
                al_draw_bitmap(allegro->menuBackgroundImage, 0, 0, 0);
                al_draw_text(allegro->gameFont, al_map_rgb(WHITE), allegro->screenWidth / 2,
                             allegro->screenHeight * 0.4, ALLEGRO_ALIGN_CENTRE, "WE WON");
                al_flip_display();

                wannaPlay(allegro, WE_WON);
                return true;
            }
        }
    }
    return false;
}
void SinglePlayerGame::wannaPlay(ALL *allegro, char ID) {
    ALLEGRO_EVENT ev;
    ALLEGRO_EVENT_QUEUE *tempQueue;
    if (tempQueue = al_create_event_queue()) {
        al_register_event_source(tempQueue, al_get_mouse_event_source());
        Button *playAgainButton, *gameOverButton;
        playAgainButton = new Button(allegro->screenWidth * 0.25, allegro->screenHeight * 0.65,
                                     "Resources/Buttons/playAgainButton.png",
                                     "Resources/Buttons/playAgainSelectedButton.png", allegro);
        gameOverButton = new Button(allegro->screenWidth * 0.65, allegro->screenHeight * 0.65,
                                    "Resources/Buttons/gameOverButton.png",
                                    "Resources/Buttons/gameOverSelectedButton.png", allegro);
        bool run = true;
        al_draw_bitmap(allegro->menuBackgroundImage, 0, 0, 0);
        if (ID == WE_LOST) {
            al_draw_text(allegro->gameFont, al_map_rgb(WHITE), allegro->screenWidth / 2, allegro->screenHeight * 0.4,
                         ALLEGRO_ALIGN_CENTRE, "WE LOST");
        } else if (ID == WE_WON) {
            al_draw_text(allegro->gameFont, al_map_rgb(WHITE), allegro->screenWidth / 2, allegro->screenHeight * 0.4,
                         ALLEGRO_ALIGN_CENTRE, "WE WON");
        }
        while (run) {
            playAgainButton->updateButton(allegro);
            gameOverButton->updateButton(allegro);
            al_flip_display();
            al_wait_for_event(tempQueue, &ev);
            if (ev.type == ALLEGRO_EVENT_MOUSE_AXES) {
                playAgainButton->checkMouse(ev.mouse.x, ev.mouse.y, allegro->volume);
                gameOverButton->checkMouse(ev.mouse.x, ev.mouse.y, allegro->volume);
            } else if (ev.type == ALLEGRO_EVENT_MOUSE_BUTTON_UP) {
                if (playAgainButton->checkMouse(ev.mouse.x, ev.mouse.y, allegro->volume)) {
                    playAgain = true;
                    gameOver = false;
                    run = false;
                } else if (gameOverButton->checkMouse(ev.mouse.x, ev.mouse.y, allegro->volume)) {
                    gameOver = true;
                    playAgain = false;
                    run = false;
                }
            }

        }
        delete playAgainButton;
        delete gameOverButton;
        al_destroy_event_queue(tempQueue);
    } else { cerr << "Could not initialize tempQueue" << endl; }
}
bool SinglePlayerGame::lose(ALL *allegro) {
    /* Lose: used to check if the players lose*/
    if (sandStormLevel < 15) {
        if (SandMarkersLeft > 0) {
            if (character->haveWater()) {
                if (character2->haveWater()) {
                    return false;
                } else {
                    al_draw_text(allegro->gameFont, al_map_rgb(WHITE), allegro->screenWidth / 2,
                                 allegro->screenHeight * 0.9, ALLEGRO_ALIGN_CENTRE,
                                 "Your partner has died from thirst");
                    cout << "Your partner has died from thirst" << endl;
                }
            } else {
                al_draw_text(allegro->gameFont, al_map_rgb(WHITE), allegro->screenWidth / 2,
                             allegro->screenHeight * 0.9, ALLEGRO_ALIGN_CENTRE, "You have died from thirst");
                cout << "You have died from thirst" << endl;
            }
        } else {
            al_draw_text(allegro->gameFont, al_map_rgb(WHITE), allegro->screenWidth / 2, allegro->screenHeight * 0.9,
                         ALLEGRO_ALIGN_CENTRE, "You habe been burried by the sand");
            cout << "You have been burried by the sand" << endl;
        }
    } else {
        al_draw_text(allegro->gameFont, al_map_rgb(WHITE), allegro->screenWidth / 2, allegro->screenHeight * 0.9,
                     ALLEGRO_ALIGN_CENTRE, "You have been killed by the storm");
        cout << "You have been killed by the storm" << endl;
    }
    //If i'm here, it's because I lose.
    al_draw_bitmap(allegro->menuBackgroundImage, 0, 0, 0);
    al_draw_text(allegro->gameFont, al_map_rgb(WHITE), allegro->screenWidth / 2, allegro->screenHeight * 0.4,
                 ALLEGRO_ALIGN_CENTRE, "WE LOST");
    al_flip_display();

    wannaPlay(allegro, WE_LOST);
    return true;
}
//! Key methods
void SinglePlayerGame::keyUp(ALL *allegro) {
/* Used when the kuy up was pressed, it does what it needs to be done after it happens */
    if (modeEnum != MOVEOTHER) {
        if (character->getCardIndex() > 0) {
            if (modeEnum == NORMAL) {
                bool climber = false;
                if (ClimberCharacter *climberCharacter = dynamic_cast<ClimberCharacter *>(character)) { climber = true; }
                if (tilesDeck[character->getCardIndex() - 1]->canIMove(climber)) { //If I'm not on top... move up
                    if (tilesDeck[character->getCardIndex()]->canIMove(climber)) {
                        if (character->moveUp()) {
                            if (ClimberCharacter *climberCharacter = dynamic_cast<ClimberCharacter *>(character)) {
                                if (climberCharacter->getTakeWithMe() &&
                                    character2->getCardIndex() - 1 == character->getCardIndex()) {
                                    character2->moveUp();
                                }
                            }
                        }
                    }
                }
            } else if (modeEnum == REMOVESAND) {
                if (tilesDeck[character->getCardIndex() - 1]->haveSand()) {
                    if (character->removeSand()) {
                        tilesDeck[character->getCardIndex() - 1]->removeSand();
                        if (ArcheologistCharacter *explorerCharacter = dynamic_cast<ArcheologistCharacter *>(character)) {
                            if (tilesDeck[character->getCardIndex() - 1]->haveSand()) {
                                tilesDeck[character->getCardIndex() - 1]->removeSand();
                                SandMarkersLeft++;
#ifdef DEBUG_GAME
                                cout << "Sand Marker ++" << endl;
#endif
                            }
                        }
                        SandMarkersLeft++;
#ifdef DEBUG_GAME
                        cout << "Sand Marker ++" << endl;
#endif
                    }
                }
            } else if (modeEnum == DUNEBLASTERMODE) {
                while (tilesDeck[character->getCardIndex() - 1]->haveSand()) {
                    tilesDeck[character->getCardIndex() - 1]->removeSand();
                    SandMarkersLeft++;
#ifdef DEBUG_GAME
                    cout << "Sand Marker ++" << endl;
#endif
                }
            }
        }
    } else {    // MoveOther Mode
        if (NavigatorCharacter *navigatorCharacter = dynamic_cast<NavigatorCharacter *>(character)) {
            if (character2->getCardIndex() > 0) {
                if (navigatorCharacter->havePartnersMovesLeft()) {
                    bool climber = false;
                    if (ClimberCharacter *climberCharacter = dynamic_cast<ClimberCharacter *>(character2)) { climber = true; }
                    if (tilesDeck[character2->getCardIndex() - 1]->canIMove(climber)) { //If I'm not on top... move up
                        if (tilesDeck[character2->getCardIndex()]->canIMove(climber)) {
                            if (character2->moveUp() && navigatorCharacter->decresePartnerMoves()) {
                                if (ClimberCharacter *climberCharacter = dynamic_cast<ClimberCharacter *>(character2)) {
                                    if (climberCharacter->getTakeWithMe() &&
                                        character->getCardIndex() - 1 == character2->getCardIndex()) {
                                        character->moveUp(); // TODO: this is not working yet, the other computer never knows if climber has its take with me active
                                    }
                                }
                            } else { cerr << "Error: no moves left even though I was supposed to have" << endl; }
                        }
                    }
                }
            }
        } else { cerr << "Error: Move Other mode without being a navigator character" << endl; }
    }
}
void SinglePlayerGame::keyDown(ALL *allegro) {
    if (modeEnum != MOVEOTHER) {
        if (character->getCardIndex() < tilesDeck.size() - 1) {
            if (modeEnum == NORMAL) {
                bool climber = false;
                if (ClimberCharacter *climberCharacter = dynamic_cast<ClimberCharacter *>(character)) { climber = true; }
                if (tilesDeck[character->getCardIndex() + 1]->canIMove(climber)) {
                    if (tilesDeck[character->getCardIndex()]->canIMove(climber)) {
                        if (character->moveDown()) {
                            if (ClimberCharacter *climberCharacter = dynamic_cast<ClimberCharacter *>(character)) {
                                if (climberCharacter->getTakeWithMe() &&
                                    character2->getCardIndex() + 1 == character->getCardIndex()) {
                                    character2->moveDown();
                                }
                            }
                        }
                    }
                }
            } else if (modeEnum == REMOVESAND) {
                if (tilesDeck[character->getCardIndex() + 1]->haveSand()) {
                    if (character->removeSand()) {
                        tilesDeck[character->getCardIndex() + 1]->removeSand();
                        if (ArcheologistCharacter *explorerCharacter = dynamic_cast<ArcheologistCharacter *>(character)) {
                            if (tilesDeck[character->getCardIndex() + 1]->haveSand()) {
                                tilesDeck[character->getCardIndex() + 1]->removeSand();
                                SandMarkersLeft++;
#ifdef DEBUG_GAME
                                cout << "Sand Marker ++" << endl;
#endif
                            }
                        }
                        SandMarkersLeft++;
#ifdef DEBUG_GAME
                        cout << "Sand Marker ++" << endl;
#endif
                    }
                }
            } else if (modeEnum == DUNEBLASTERMODE) {
                while (tilesDeck[character->getCardIndex() + 1]->haveSand()) {
                    tilesDeck[character->getCardIndex() + 1]->removeSand();
                    SandMarkersLeft++;
#ifdef DEBUG_GAME
                    cout << "Sand Marker ++" << endl;
#endif
                }
            }
        }
    } else {
        if (NavigatorCharacter *navigatorCharacter = dynamic_cast<NavigatorCharacter *>(character)) {
            if (character2->getCardIndex() < tilesDeck.size() - 1) {
                if (navigatorCharacter->havePartnersMovesLeft()) {
                    bool climber = false;
                    if (ClimberCharacter *climberCharacter = dynamic_cast<ClimberCharacter *>(character2)) { climber = true; }
                    if (tilesDeck[character2->getCardIndex() + 1]->canIMove(climber)) {
                        if (tilesDeck[character2->getCardIndex()]->canIMove(climber)) {
                            if (character2->moveDown() && navigatorCharacter->decresePartnerMoves()) {
                                if (ClimberCharacter *climberCharacter = dynamic_cast<ClimberCharacter *>(character2)) {
                                    if (climberCharacter->getTakeWithMe() &&
                                        character->getCardIndex() + 1 == character2->getCardIndex()) {
                                        character->moveDown();
                                    }
                                }
                            } else { cerr << "Error: no moves left even though I was supposed to have" << endl; }
                        }
                    }
                }
            }
        } else { cerr << "Error: Move Other mode without being a navigator character" << endl; }
    }
}
void SinglePlayerGame::keyRight(ALL *allegro) {
    if (modeEnum == OFFEREQUIPMENTMODE || modeEnum == REQUESTEQUIPMENTMODE) { nextEquipCard(); }
    else if (modeEnum == PEEPMODE) { nextPeepStormCard(); }

    if (modeEnum != MOVEOTHER) {
        if (character->getCardIndex() < tilesDeck.size() - 5) {
            if (modeEnum == NORMAL) {
                bool climber = false;
                if (ClimberCharacter *climberCharacter = dynamic_cast<ClimberCharacter *>(character)) { climber = true; }
                if (tilesDeck[character->getCardIndex() + 5]->canIMove(climber)) {
                    if (tilesDeck[character->getCardIndex()]->canIMove(climber)) {
                        if (character->moveRight()) {
                            // If take with me...
                            if (ClimberCharacter *climberCharacter = dynamic_cast<ClimberCharacter *>(character)) {
                                if (climberCharacter->getTakeWithMe() && character2->getCardIndex() + 5 == character->getCardIndex()) {
                                    character2->moveRight();
                                }
                            }
                        }
                    }
                }
            } else if (modeEnum == REMOVESAND) {
                if (tilesDeck[character->getCardIndex() + 5]->haveSand()) {
                    if (character->removeSand()) {
                        tilesDeck[character->getCardIndex() + 5]->removeSand();
                        if (ArcheologistCharacter *explorerCharacter = dynamic_cast<ArcheologistCharacter *>(character)) {
                            if (tilesDeck[character->getCardIndex() + 5]->haveSand()) {
                                tilesDeck[character->getCardIndex() + 5]->removeSand();
                                SandMarkersLeft++;
#ifdef DEBUG_GAME
                                cout << "Sand Marker ++" << endl;
#endif
                            }
                        }
                        SandMarkersLeft++;
#ifdef DEBUG_GAME
                        cout << "Sand Marker ++" << endl;
#endif
                    }
                }
            } else if (modeEnum == DUNEBLASTERMODE) {
                while (tilesDeck[character->getCardIndex() + 5]->haveSand()) {
                    tilesDeck[character->getCardIndex() + 5]->removeSand();
                    SandMarkersLeft++;
#ifdef DEBUG_GAME
                    cout << "Sand Marker ++" << endl;
#endif
                }
            }
        }
    } else {
        if (NavigatorCharacter *navigatorCharacter = dynamic_cast<NavigatorCharacter *>(character)) {
            if (character2->getCardIndex() < tilesDeck.size() - 5) {
                if (navigatorCharacter->havePartnersMovesLeft()) {
                    bool climber = false;
                    if (ClimberCharacter *climberCharacter = dynamic_cast<ClimberCharacter *>(character2)) { climber = true; }
                    if (tilesDeck[character2->getCardIndex() + 5]->canIMove(climber)) { //If I'm not on top... move up
                        if (tilesDeck[character2->getCardIndex()]->canIMove(climber)) {
                            if (character2->moveRight() && navigatorCharacter->decresePartnerMoves()) {
                                if (ClimberCharacter *climberCharacter = dynamic_cast<ClimberCharacter *>(character2)) {
                                    if (climberCharacter->getTakeWithMe() &&
                                        character->getCardIndex() + 5 == character2->getCardIndex()) {
                                        character->moveRight();
                                    }
                                }
                            } else { cerr << "Error: no moves left even though I was supposed to have" << endl; }
                        }
                    }
                }
            }
        } else { cerr << "Error: Move Other mode without being a navigator character" << endl; }
    }
}
void SinglePlayerGame::keyLeft(ALL *allegro) {
    if (modeEnum == OFFEREQUIPMENTMODE || modeEnum == REQUESTEQUIPMENTMODE) { previousEquipCard(); }
    else if (modeEnum == PEEPMODE) { previousPeepStormCard(); }

    if (modeEnum != MOVEOTHER) {
        if (character->getCardIndex() > 4) {
            if (modeEnum == NORMAL) {
                bool climber = false;
                if (ClimberCharacter *climberCharacter = dynamic_cast<ClimberCharacter *>(character)) { climber = true; }
                if (tilesDeck[character->getCardIndex() - 5]->canIMove(climber)) {
                    if (tilesDeck[character->getCardIndex()]->canIMove(climber)) {
                        if (character->moveLeft()) {
                            if (ClimberCharacter *climberCharacter = dynamic_cast<ClimberCharacter *>(character)) {
                                if (climberCharacter->getTakeWithMe() &&
                                    character2->getCardIndex() - 5 == character->getCardIndex()) {
                                    character2->moveLeft();
                                }
                            }
                        }
                    }
                }
            } else if (modeEnum == REMOVESAND) {
                if (tilesDeck[character->getCardIndex() - 5]->haveSand()) {
                    if (character->removeSand()) {
                        tilesDeck[character->getCardIndex() - 5]->removeSand();
                        if (ArcheologistCharacter *explorerCharacter = dynamic_cast<ArcheologistCharacter *>(character)) {
                            if (tilesDeck[character->getCardIndex() - 5]->haveSand()) {
                                tilesDeck[character->getCardIndex() - 5]->removeSand();
                                SandMarkersLeft++;
#ifdef DEBUG_GAME
                                cout << "Sand Marker ++" << endl;
#endif
                            }
                        }
                        SandMarkersLeft++;
#ifdef DEBUG_GAME
                        cout << "Sand Marker ++" << endl;
#endif
                    }
                }
            } else if (modeEnum == DUNEBLASTERMODE) {
                while (tilesDeck[character->getCardIndex() - 5]->haveSand()) {
                    tilesDeck[character->getCardIndex() - 5]->removeSand();
                    SandMarkersLeft++;
#ifdef DEBUG_GAME
                    cout << "Sand Marker ++" << endl;
#endif
                }
            }
        }
    } else {
        if (NavigatorCharacter *navigatorCharacter = dynamic_cast<NavigatorCharacter *>(character)) {
            if (character2->getCardIndex() > 4) {
                if (navigatorCharacter->havePartnersMovesLeft()) {
                    bool climber = false;
                    if (ClimberCharacter *climberCharacter = dynamic_cast<ClimberCharacter *>(character2)) { climber = true; }
                    if (tilesDeck[character2->getCardIndex() - 5]->canIMove(climber)) {
                        if (tilesDeck[character2->getCardIndex()]->canIMove(climber)) {
                            if (character2->moveLeft() && navigatorCharacter->decresePartnerMoves()) {
                                if (ClimberCharacter *climberCharacter = dynamic_cast<ClimberCharacter *>(character2)) {
                                    if (climberCharacter->getTakeWithMe() &&
                                        character->getCardIndex() - 5 == character2->getCardIndex()) {
                                        character->moveLeft();
                                    }
                                }
                            }
                        }
                    }
                }
            }
        } else { cerr << "Error: Move Other mode without being a navigator character" << endl; }
    }
}
void SinglePlayerGame::keyE(ALL *allegro) {
    if (modeEnum == NORMAL) {
        if (!(tilesDeck[character->getCardIndex()]->isTurned())) {
            if (!tilesDeck[character->getCardIndex()]->haveSand()) {
                if (character->dig()) {
                    al_play_sample(allegro->excavateSound, allegro->volume, 0, 1, ALLEGRO_PLAYMODE_ONCE, NULL);
                    tilesDeck[character->getCardIndex()]->turnTile();
                    performTileAction(tilesDeck[character->getCardIndex()]->gettileType(), character->getCardIndex(),
                                      allegro);
                }
            }
        }
    }
}
void SinglePlayerGame::keyP(ALL *allegro) {
    if (modeEnum == NORMAL) {
        pickUpAction();
    }
}
void SinglePlayerGame::keyR(ALL *allegro) {
    if (modeEnum == REMOVESAND) {
        if (tilesDeck[character->getCardIndex()]->haveSand()) {
            if (character->removeSand()) {
                if (ArcheologistCharacter *explorerCharacter = dynamic_cast<ArcheologistCharacter *>(character)) {
                    if (tilesDeck[character->getCardIndex()]->haveSand()) {
                        tilesDeck[character->getCardIndex()]->removeSand();
                        SandMarkersLeft++;
#ifdef DEBUG_GAME
                        cout << "Sand Marker ++" << endl;
#endif
                    }
                }
                tilesDeck[character->getCardIndex()]->removeSand();
                SandMarkersLeft++;
#ifdef DEBUG_GAME
                cout << "Sand Marker ++" << endl;
#endif
            }
        }
    }
}

//! Click Methods
void SinglePlayerGame::click(ALL *allegro) {
/* Runs the click depending in which state i'm in */
    //Volume Buttons
    if (allegro->volume == 0) {
        if (muteButton->checkMouse(mouse.x, mouse.y, allegro->volume)) {
            allegro->volume = 1;
            al_play_sample(allegro->backgroundMusic, allegro->volume / 2, 0.0, 1.0, ALLEGRO_PLAYMODE_LOOP,
                           &allegro->backgroundMusicID);
        }
    } else {
        if (noMuteButton->checkMouse(mouse.x, mouse.y, allegro->volume)) {
            allegro->volume = 0;
            al_stop_sample(&allegro->backgroundMusicID);
#ifdef DEBUG_GAME
            cout << "Stopping background music" << endl;
#endif
        }
    }
    switch (modeEnum) {
        case PEEPMODE:
            clickOnPeepMode(allegro);
            break;
        case JETPACKMODE:
            clickOnJetPackMode(allegro);
            break;
        case TERRASCOPEMODE:
            clickOnTerrascopeMode(allegro);
            break;
        case OFFEREQUIPMENTMODE:
            clickOnOfferEquipmentMode(allegro);
            break;
        case REQUESTEQUIPMENTMODE:
            clickOnRequestEquipmentMode(allegro);
            break;
        case OFFERWATERMODE:
            clickOnOfferWaterMode(allegro);
            break;
        case REQUESTWATERMODE:
            clickOnRequestWaterMode(allegro);
            break;
        default:
            clickOnDefaultMode(allegro);
    }

}
void SinglePlayerGame::clickOnPeepMode(ALL *allegro) {
    /* Click while in peep mode */
    if (MeteorologistCharacter *meteorologistCharacter = dynamic_cast<MeteorologistCharacter *>(character)) {
        if (nextButton->checkMouse(mouse.x, mouse.y, allegro->volume)) { nextPeepStormCard(); }
        if (previousButton->checkMouse(mouse.x, mouse.y, allegro->volume)) { previousPeepStormCard(); }
        if (selectPeepCard->checkMouse(mouse.x, mouse.y, allegro->volume)) {
            for (int i = 0; i < peepOffset; i++) {
                swapStormCards(peepOffset - i - 1, peepOffset - i);
            } //Move the card to the front by swaping with each card
            std::rotate(stormCardsDeck.begin(), stormCardsDeck.begin() + 1,
                        stormCardsDeck.end());        //Rotate to take it to the bottom.
            //meteorologistCharacter->peep();
            modeEnum = NORMAL;
            resetPeepOffset();
        }
    } else { cerr << "Enter in 'click on peep mode' without being an meteorologist" << endl; }
}
void SinglePlayerGame::clickOnJetPackMode(ALL *allegro) {
    for (int i = 0; i < TILEDECKNUMBER; i++) {
        bool climber = false;
        //The climber's ability doesn't affect movement by Jetpack.
        //if (ClimberCharacter* climberCharacter = dynamic_cast<ClimberCharacter*>(character)) { climber = true; }
        if (tilesDeck[i]->canIMove(false)) {
            if (tilesDeck[i]->checkButton(mouse.x, mouse.y, allegro->volume)) {
                character->setPos(i % 5, i / 5);
                character->increaseMoves();
                al_play_sample(allegro->teleportSound, allegro->volume, 0, 1, ALLEGRO_PLAYMODE_ONCE, NULL);
                modeEnum = NORMAL;
            }
        }
    }
}
void SinglePlayerGame::clickOnTerrascopeMode(ALL *allegro) {
    for (int i = 0; i < TILEDECKNUMBER; i++) {
        if (tilesDeck[i]->checkButton(mouse.x, mouse.y, allegro->volume) && !tilesDeck[i]->isTurned()) {
            int backup = tilesDeck[i]->getSand();
            tilesDeck[i]->turnTerrascopeTile();
            tilesDeck[i]->updateTile(allegro);
            al_flip_display();
            tilesDeck[i]->setSand(backup);
            tilesDeck[i]->setTurned(false);
            modeEnum = NORMAL;
            usleep(TERRASCOPE_PEEP_TIME);
        }
    }
}
void SinglePlayerGame::clickOnRequestWaterMode(ALL *allegro) {
    for (int i = 0; i < min(character->getWaters(), MAXWATERS - character2->getWaters() - 1); i++) {
        if (watersButton[i]->checkMouse(mouse.x, mouse.y, allegro->volume)) {  // && character->getWaters() > (i + 1)) {
            modeEnum = NORMAL;
            updateScreen(allegro);
            for (int c = 0; c < i + 1; c++) {
                character->drinkWater();
                character2->addWater();
            }
        }
    }
}
void SinglePlayerGame::clickOnOfferEquipmentMode(ALL *allegro) {
    if (nextButton->checkMouse(mouse.x, mouse.y, allegro->volume)) { nextEquipCard(); }
    if (previousButton->checkMouse(mouse.x, mouse.y, allegro->volume)) { previousEquipCard(); }
    if (selectEquipmentCard->checkMouse(mouse.x, mouse.y, allegro->volume)) {
        modeEnum = NORMAL;
        updateScreen(allegro);
        switch (equipOffset) {
            case DUNEBLAST:
                character->decreaseDuneBlaster();
                character2->increaseDuneBlaster();
                break;
            case JETPACK:
                character->decreaseJetPack();
                character2->increaseJetPack();
                break;
            case SOLARSHIELD:
                character->decreaseSolarShield();
                character2->increaseSolarShield();
                break;
            case TERRASCOPE:
                character->decreaseTerrascope();
                character2->increaseTerrascope();
                break;
            case SECRETWATERRESERVE:
                character->decreaseWaterReserve();
                character2->increaseWaterReserve();
                break;
            case TIMETHROTTLE:
                character->decreaseTimeThrottle();
                character2->increaseTimeThrottle();
                break;
        }
    }
}
void SinglePlayerGame::clickOnRequestEquipmentMode(ALL *allegro) {
    if (nextButton->checkMouse(mouse.x, mouse.y, allegro->volume)) { nextEquipCard(); }
    if (previousButton->checkMouse(mouse.x, mouse.y, allegro->volume)) { previousEquipCard(); }
    if (selectEquipmentCard->checkMouse(mouse.x, mouse.y, allegro->volume)) {
        modeEnum = NORMAL;
        updateScreen(allegro);
        switch (equipOffset) {
            case DUNEBLAST:
                character2->decreaseDuneBlaster();
                character->increaseDuneBlaster();
                break;
            case JETPACK:
                character2->decreaseJetPack();
                character->increaseJetPack();
                break;
            case SOLARSHIELD:
                character2->decreaseSolarShield();
                character->increaseSolarShield();
                break;
            case TERRASCOPE:
                character2->decreaseTerrascope();
                character->increaseTerrascope();
                break;
            case SECRETWATERRESERVE:
                character2->decreaseWaterReserve();
                character->increaseWaterReserve();
                break;
            case TIMETHROTTLE:
                character2->decreaseTimeThrottle();
                character->increaseTimeThrottle();
                break;
        }
    }
}
void SinglePlayerGame::clickOnOfferWaterMode(ALL *allegro) {
    for (int i = 0; i < min(character->getWaters(), MAXWATERS - character2->getWaters() - 1); i++) {
        if (watersButton[i]->checkMouse(mouse.x, mouse.y, allegro->volume)) {  // && character->getWaters() > (i + 1)) {
            modeEnum = NORMAL;
            updateScreen(allegro);
            for (int c = 0; c < i + 1; c++) {
                character->drinkWater();
                character2->addWater();
            }

        }
    }
}
void SinglePlayerGame::clickOnDefaultMode(ALL *allegro) {
    clickModesButtons(allegro);
    clickEquipmentButtons(allegro);
    clickTilesButtons(allegro);
    /*if (tilesDeck[character->getCardIndex()]->checkButton(mouse.x, mouse.y, allegro->volume)) {
		keyR(allegro);
		modeEnum = NORMAL;
	}*/
    if (endTurnButton->checkMouse(mouse.x, mouse.y, allegro->volume)) {
        //If there was a selected character, then return true, else return false
        //!!!!! TODO: make a swap of characters to see if it works OK
        al_play_sample(allegro->clickOnButtonSound, allegro->volume, 0, 1, ALLEGRO_PLAYMODE_ONCE, NULL);
        drawStormCards(allegro);
        Character *tempChar;                // pointer to character to make a swap
        character->resetNumberOfMoves();    // This has to go after draw cards.
                                            // Because if you are a meteorologist you may be able to draw fewer cards.
        character2->resetNumberOfMoves();

        tempChar = character2;
        character2 = character;
        character = tempChar;
        //turn = !turn;
        character2->shield = false;
    }
    if (MeteorologistCharacter *meteorologistCharacter = dynamic_cast<MeteorologistCharacter *>(character)) {
        if (meteorologistCharacter->checkMouseOverButton(mouse.x, mouse.y, allegro->volume)) {
            al_play_sample(allegro->clickOnButtonSound, allegro->volume, 0, 1, ALLEGRO_PLAYMODE_ONCE, NULL);
#ifdef DEBUG_GAME
            cout << "PEEP" << endl;
#endif
            if (meteorologistCharacter->peep()) {
                modeEnum = PEEPMODE;
                peepOffset = 0;
                firstTimeUpdateScreenPeep = 0;
            }
        }
    } else if (ClimberCharacter *climberCharacter = dynamic_cast<ClimberCharacter *>(character)) {
        climberCharacter->clickOnButton(mouse.x, mouse.y, allegro->volume);
    } else if (WaterCarrierCharacter *waterCarrierCharacter = dynamic_cast<WaterCarrierCharacter *>(character)) {
        if (tilesDeck[character->getCardIndex()]->gettileType() == WATER && tilesDeck[character->getCardIndex()]->isTurned()) {
            if (waterCarrierCharacter->checkMouseOverButton(mouse.x, mouse.y, allegro->volume)) {
                al_play_sample(allegro->clickOnButtonSound, allegro->volume, 0, 1, ALLEGRO_PLAYMODE_ONCE, NULL);
                waterCarrierCharacter->getWatersFromWell();
                al_play_sample(allegro->waterSound, allegro->volume, 0, 1, ALLEGRO_PLAYMODE_ONCE, NULL);
            }
        }
    } else if (NavigatorCharacter *navigatorCharacter = dynamic_cast<NavigatorCharacter *>(character)) {
        if (navigatorCharacter->checkMouseOverButton(mouse.x, mouse.y, modeEnum == MOVEOTHER, allegro->volume)) {
#ifdef DEBUG_GAME
            cout << "Click on special navigator button" << endl;
#endif
            al_play_sample(allegro->clickOnButtonSound, allegro->volume, 0, 1, ALLEGRO_PLAYMODE_ONCE, NULL);
            if (modeEnum == MOVEOTHER) {
                modeEnum = NORMAL;
                if(navigatorCharacter->usedPartnerMoves()) {
                    character2->resetNumberOfMoves();
                    navigatorCharacter->decreseMoves();
                }
            } else {
                if (navigatorCharacter->haveMoves()) {
                    modeEnum = MOVEOTHER;
                    navigatorCharacter->resetPartnerMoves();
                    character2->resetNumberOfMoves();    //I reset them to be able to move him
                }
            }
        }
    }
}
void SinglePlayerGame::clickTilesButtons(ALL *allegro) {
    if (modeEnum != MOVEOTHER) {
        // Click on the tile I'm on
        if ((tilesDeck[character->getCardIndex()]->haveSand() || !tilesDeck[character->getCardIndex()]->isTurned())) {
            if (tilesDeck[character->getCardIndex()]->checkButton(mouse.x, mouse.y, allegro->volume)) {
                if (modeEnum == DUNEBLASTERMODE) {
                    while (tilesDeck[character->getCardIndex()]->haveSand()) {
                        tilesDeck[character->getCardIndex()]->removeSand();
                        SandMarkersLeft++;
#ifdef DEBUG_GAME
                        cout << "Sand Marker ++" << endl;
#endif
                    }
                } else if (tilesDeck[character->getCardIndex()]->haveSand()) {
                    if (character->removeSand()) {
                        tilesDeck[character->getCardIndex()]->removeSand();
                        SandMarkersLeft++;
#ifdef DEBUG_GAME
                        cout << "Sand Marker ++" << endl;
#endif
                        if (ArcheologistCharacter *archeologistCharacter = dynamic_cast<ArcheologistCharacter *>(character)) {
                            if (tilesDeck[character->getCardIndex()]->haveSand()) {
                                tilesDeck[character->getCardIndex()]->removeSand();
                                SandMarkersLeft++;
#ifdef DEBUG_GAME
                                cout << "Sand Marker ++" << endl;
#endif
                            }
                        }
                    }
                } else {
                    if (!(tilesDeck[character->getCardIndex()]->isTurned()))
                        if (character->dig()) {
                            al_play_sample(allegro->excavateSound, allegro->volume, 0, 1, ALLEGRO_PLAYMODE_ONCE, NULL);
                            tilesDeck[character->getCardIndex()]->turnTile();
                            performTileAction(tilesDeck[character->getCardIndex()]->gettileType(),
                                              character->getCardIndex(), allegro);
                        }
                }
            }
        }
        //Click on Adyacent Tiles
        if (character->getCardIndex() > 0) {
            if (tilesDeck[character->getCardIndex() - 1]->checkButton(mouse.x, mouse.y, allegro->volume)) {
                keyUp(allegro);
                modeEnum = NORMAL;
            }
        }
        if (character->getCardIndex() < TILEDECKNUMBER - 1) {
            if (tilesDeck[character->getCardIndex() + 1]->checkButton(mouse.x, mouse.y, allegro->volume)) {
                keyDown(allegro);
                modeEnum = NORMAL;
            }
        }
        if (character->getCardIndex() > 4) {
            if (tilesDeck[character->getCardIndex() - 5]->checkButton(mouse.x, mouse.y, allegro->volume)) {
                keyLeft(allegro);
                modeEnum = NORMAL;
            }
        }
        if (character->getCardIndex() < TILEDECKNUMBER - 5) {
            if (tilesDeck[character->getCardIndex() + 5]->checkButton(mouse.x, mouse.y, allegro->volume)) {
                keyRight(allegro);
                modeEnum = NORMAL;
            }
        }
        //Tunnel Tile
        bool climber = false;
        if (ClimberCharacter *climberCharacter = dynamic_cast<ClimberCharacter *>(character)) { climber = true; }
        if (tilesDeck[character->getCardIndex()]->gettileType() == TUNNEL &&
            tilesDeck[character->getCardIndex()]->isTurned()) {
            for (uint i = 0; i < tilesDeck.size(); i++) {
                if (tilesDeck[i]->gettileType() == TUNNEL && i != character->getCardIndex() &&
                    tilesDeck[i]->isTurned()) { //TUNNEL not the same I'm in, it's discovered
                    if (tilesDeck[i]->canIMove(climber)) {
                        if (tilesDeck[i]->checkButton(mouse.x, mouse.y, allegro->volume)) {
                            character->setPos(i % 5, i / 5);
                        }
                    }
                }
            }
        }
        //If I'm Explorer, click on diagonally adyacent tiles
        if (ExplorerCharacter *explorerCharacter = dynamic_cast<ExplorerCharacter *>(character)) {
            bool climber = false;
            if (ClimberCharacter *explorerCharacter = dynamic_cast<ClimberCharacter *>(character)) {
                climber = true;
                cerr << "Error: character is both explorer and climber" << endl;
            }
            if (character->getCardIndex() > 5 && character->getCardIndex() % 5 != 0) {
                if (tilesDeck[character->getCardIndex() - 6]->checkButton(mouse.x, mouse.y, allegro->volume)) {
                    if (modeEnum == NORMAL) {
                        if (tilesDeck[character->getCardIndex() - 6]->canIMove(
                                climber)) {    //Here climber will always be false
                            explorerCharacter->moveUpLeftDiagonally();
                        }
                    } else if (modeEnum == REMOVESAND) {
                        if (tilesDeck[character->getCardIndex() - 6]->haveSand()) {
                            if (character->removeSand()) { //this time there is no need to check if its an archeologist because its an explorer
                                tilesDeck[character->getCardIndex() - 6]->removeSand();
                                SandMarkersLeft++;
#ifdef DEBUG_GAME
                                cout << "Sand Marker ++" << endl;
#endif
                            }
                        }
                    } else if (modeEnum == DUNEBLASTERMODE) {
                        while (tilesDeck[character->getCardIndex() - 6]->haveSand()) {
                            tilesDeck[character->getCardIndex() - 6]->removeSand();
                            SandMarkersLeft++;
#ifdef DEBUG_GAME
                            cout << "Sand Marker ++" << endl;
#endif
                        }
                    }
                    modeEnum = NORMAL;
                }
            }
            if (character->getCardIndex() > 4 && character->getCardIndex() % 5 != 4) {
                if (tilesDeck[character->getCardIndex() - 4]->checkButton(mouse.x, mouse.y, allegro->volume)) {
                    if (modeEnum == NORMAL) {
                        if (tilesDeck[character->getCardIndex() - 4]->canIMove(climber)) {
                            explorerCharacter->moveDownLeftDiagonally();
                        }
                    } else if (modeEnum == REMOVESAND) {
                        if (tilesDeck[character->getCardIndex() - 4]->haveSand()) {
                            if (character->removeSand()) {
                                tilesDeck[character->getCardIndex() - 4]->removeSand();
                                SandMarkersLeft++;
#ifdef DEBUG_GAME
                                cout << "Sand Marker ++" << endl;
#endif
                            }
                        }

                    } else if (modeEnum == DUNEBLASTERMODE) {
                        while (tilesDeck[character->getCardIndex() - 4]->haveSand()) {
                            tilesDeck[character->getCardIndex() - 4]->removeSand();
                            SandMarkersLeft++;
#ifdef DEBUG_GAME
                            cout << "Sand Marker ++" << endl;
#endif
                        }
                    }
                    modeEnum = NORMAL;
                }
            }
            if (character->getCardIndex() < TILEDECKNUMBER - 4 && character->getCardIndex() % 5 != 0) {
                if (tilesDeck[character->getCardIndex() + 4]->checkButton(mouse.x, mouse.y, allegro->volume)) {
                    if (modeEnum == NORMAL) {
                        if (tilesDeck[character->getCardIndex() + 4]->canIMove(climber)) {
                            explorerCharacter->moveUpRightDiagonally();
                        }
                    } else if (modeEnum == REMOVESAND) {
                        if (tilesDeck[character->getCardIndex() + 4]->haveSand()) {
                            if (character->removeSand()) {
                                tilesDeck[character->getCardIndex() + 4]->removeSand();
                                SandMarkersLeft++;
#ifdef DEBUG_GAME
                                cout << "Sand Marker ++" << endl;
#endif
                            }
                        }
                    } else if (modeEnum == DUNEBLASTERMODE) {
                        while (tilesDeck[character->getCardIndex() + 4]->haveSand()) {
                            tilesDeck[character->getCardIndex() + 4]->removeSand();
                            SandMarkersLeft++;
#ifdef DEBUG_GAME
                            cout << "Sand Marker ++" << endl;
#endif
                        }
                    }
                    modeEnum = NORMAL;
                }
            }
            if (character->getCardIndex() < TILEDECKNUMBER - 6 && character->getCardIndex() % 5 != 4) {
                if (tilesDeck[character->getCardIndex() + 6]->checkButton(mouse.x, mouse.y, allegro->volume)) {
                    if (modeEnum == NORMAL) {
                        if (tilesDeck[character->getCardIndex() + 6]->canIMove(climber)) {
                            explorerCharacter->moveDownRightDiagonally();
                        }
                    } else if (modeEnum == REMOVESAND) {
                        if (tilesDeck[character->getCardIndex() + 6]->haveSand()) {
                            if (character->removeSand()) {
                                tilesDeck[character->getCardIndex() + 6]->removeSand();
                                SandMarkersLeft++;
#ifdef DEBUG_GAME
                                cout << "Sand Marker ++" << endl;
#endif
                            }
                        }
                    } else if (modeEnum == DUNEBLASTERMODE) {
                        while (tilesDeck[character->getCardIndex() + 6]->haveSand()) {
                            tilesDeck[character->getCardIndex() + 6]->removeSand();
                            SandMarkersLeft++;
#ifdef DEBUG_GAME
                            cout << "Sand Marker ++" << endl;
#endif
                        }
                    }
                    modeEnum = NORMAL;
                }
            }
        }
    } else {
        //Click on Adyacent Tiles
        if (character2->getCardIndex() > 0) {
            if (tilesDeck[character2->getCardIndex() - 1]->checkButton(mouse.x, mouse.y, allegro->volume)) {
                keyUp(allegro);
            }
        }
        if (character2->getCardIndex() < TILEDECKNUMBER - 1) {
            if (tilesDeck[character2->getCardIndex() + 1]->checkButton(mouse.x, mouse.y, allegro->volume)) {
                keyDown(allegro);
            }
        }
        if (character2->getCardIndex() > 4) {
            if (tilesDeck[character2->getCardIndex() - 5]->checkButton(mouse.x, mouse.y, allegro->volume)) {
                keyLeft(allegro);
            }
        }
        if (character2->getCardIndex() < TILEDECKNUMBER - 5) {
            if (tilesDeck[character2->getCardIndex() + 5]->checkButton(mouse.x, mouse.y, allegro->volume)) {
                keyRight(allegro);
            }
        }
        //Tunnel Tile
        bool climber = false;
        if (ClimberCharacter *climberCharacter = dynamic_cast<ClimberCharacter *>(character2)) { climber = true; }
        if (tilesDeck[character2->getCardIndex()]->gettileType() == TUNNEL &&
            tilesDeck[character2->getCardIndex()]->isTurned()) {
            for (uint i = 0; i < tilesDeck.size(); i++) {
                if (tilesDeck[i]->gettileType() == TUNNEL && i != character2->getCardIndex() &&
                    tilesDeck[i]->isTurned()) {
                    if (tilesDeck[i]->canIMove(climber)) {
                        if (tilesDeck[i]->checkButton(mouse.x, mouse.y, allegro->volume)) {
                            character2->setPos(i % 5, i / 5);
                        }
                    }
                }
            }
        }
        //If I'm Explorer, click on diagonally adyacent tiles
        if (ExplorerCharacter *explorerCharacter = dynamic_cast<ExplorerCharacter *>(character2)) {
            if (NavigatorCharacter *navigatorCharacter = dynamic_cast<NavigatorCharacter *>(character)) {
                bool climber = false;
                if (ClimberCharacter *explorerCharacter = dynamic_cast<ClimberCharacter *>(character2)) {
                    climber = true;
                    cerr << "Error: character is both explorer and climber" << endl;
                }
                if (character2->getCardIndex() > 5 && character2->getCardIndex() % 5 != 0) {
                    if (tilesDeck[character2->getCardIndex() - 6]->checkButton(mouse.x, mouse.y, allegro->volume)) {
                        if (navigatorCharacter->havePartnersMovesLeft()) {
                            if (tilesDeck[character2->getCardIndex() - 6]->canIMove(
                                    climber)) {    //Here climber will always be false
                                explorerCharacter->moveUpLeftDiagonally();
                                navigatorCharacter->decresePartnerMoves();
                                //Conection
                            }
                        }
                    }
                }
                if (character2->getCardIndex() > 4 && character2->getCardIndex() % 5 != 4) {
                    if (tilesDeck[character2->getCardIndex() - 4]->checkButton(mouse.x, mouse.y, allegro->volume)) {
                        if (navigatorCharacter->havePartnersMovesLeft()) {
                            if (tilesDeck[character2->getCardIndex() - 4]->canIMove(climber)) {
                                explorerCharacter->moveDownLeftDiagonally();
                                navigatorCharacter->decresePartnerMoves();
                            }
                        }
                    }
                }
                if (character2->getCardIndex() < TILEDECKNUMBER - 4 && character2->getCardIndex() % 5 != 0) {
                    if (tilesDeck[character2->getCardIndex() + 4]->checkButton(mouse.x, mouse.y, allegro->volume)) {
                        if (navigatorCharacter->havePartnersMovesLeft()) {
                            if (tilesDeck[character2->getCardIndex() + 4]->canIMove(climber)) {
                                explorerCharacter->moveUpRightDiagonally();
                                navigatorCharacter->decresePartnerMoves();
                            }
                        }
                    }
                }
                if (character2->getCardIndex() < TILEDECKNUMBER - 6 && character->getCardIndex() % 5 != 4) {
                    if (tilesDeck[character2->getCardIndex() + 6]->checkButton(mouse.x, mouse.y, allegro->volume)) {
                        if (navigatorCharacter->havePartnersMovesLeft()) {
                            if (tilesDeck[character2->getCardIndex() + 6]->canIMove(climber)) {
                                explorerCharacter->moveDownRightDiagonally();
                                navigatorCharacter->decresePartnerMoves();
                            }
                        }
                    }
                }
            }
        }
    }
}
void SinglePlayerGame::clickModesButtons(ALL *allegro) {
    if (modesButtons[REMOVEBUTTON]->checkMouse(mouse.x, mouse.y, allegro->volume)) {
#ifdef DEBUG_GAME
        cout << "Remove Sand Button Clicked" << endl;
#endif
        al_play_sample(allegro->clickOnButtonSound, allegro->volume, 0, 1, ALLEGRO_PLAYMODE_ONCE, NULL);
        if (modeEnum == REMOVESAND) {
            if (tilesDeck[character->getCardIndex()]->haveSand()) {
                if (character->removeSand()) {
                    tilesDeck[character->getCardIndex()]->removeSand();
                    if (ArcheologistCharacter *explorerCharacter = dynamic_cast<ArcheologistCharacter *>(character)) {
                        if (tilesDeck[character->getCardIndex()]->haveSand()) {
                            tilesDeck[character->getCardIndex()]->removeSand();
                            SandMarkersLeft++;
#ifdef DEBUG_GAME
                            cout << "Sand Marker ++" << endl;
#endif
                        }
                    }
                    SandMarkersLeft++;
#ifdef DEBUG_GAME
                    cout << "Sand Marker ++" << endl;
#endif
                }
            }
            modeEnum = NORMAL;
        } else { modeEnum = REMOVESAND; }
    } else if (modesButtons[EXCAVATEBUTTON]->checkMouse(mouse.x, mouse.y,
                                                        allegro->volume)) {    //I use else if because it will take less time for the computer to check the buttons
#ifdef DEBUG_GAME
        cout << "Excavate Button Clicked" << endl;
#endif
        al_play_sample(allegro->clickOnButtonSound, allegro->volume, 0, 1, ALLEGRO_PLAYMODE_ONCE, NULL);
        keyE(allegro);
        modeEnum = NORMAL;
    } else if (modesButtons[PICKUPBUTTON]->checkMouse(mouse.x, mouse.y, allegro->volume)) {
#ifdef DEBUG_GAME
        cout << "Pick Up Part Button Clicked" << endl;
#endif
        al_play_sample(allegro->clickOnButtonSound, allegro->volume, 0, 1, ALLEGRO_PLAYMODE_ONCE, NULL);
        keyP(allegro);
        modeEnum = NORMAL;
    } else if (modesButtons[OFFERWBUTTON]->checkMouse(mouse.x, mouse.y, allegro->volume)) {
#ifdef DEBUG_GAME
        cout << "Offer Water Button Clicked" << endl;
#endif
        al_play_sample(allegro->clickOnButtonSound, allegro->volume, 0, 1, ALLEGRO_PLAYMODE_ONCE, NULL);
        if (WaterCarrierCharacter *waterCarrierCharacter = dynamic_cast<WaterCarrierCharacter *>(character)) {
            if (character->getRow() == character2->getRow()) {
                if (character2->getColumn() >= character->getColumn() - 1 &&
                    character2->getColumn() <= character->getColumn() + 1) {
                    if (min(character->getWaters(), MAXWATERS - character2->getWaters() - 1) !=
                        0) { modeEnum = OFFERWATERMODE; }
                }
            } else if (character->getColumn() == character2->getColumn()) {
                if (character2->getColumn() == character->getColumn() - 1 ||
                    character2->getColumn() == character->getColumn() + 1) {
                    if (min(character->getWaters(), MAXWATERS - character2->getWaters() - 1) !=
                        0) { modeEnum = OFFERWATERMODE; }
                }
            }
        } else if (character->getRow() == character2->getRow() && character->getColumn() == character2->getColumn()) {
            if (min(character->getWaters(), MAXWATERS - character2->getWaters() - 1) !=
                0) { modeEnum = OFFERWATERMODE; }
        }
    } else if (modesButtons[OFFEREBUTTON]->checkMouse(mouse.x, mouse.y, allegro->volume)) {
#ifdef DEBUG_GAME
        cout << "Offer Equipment Button Clicked" << endl;
#endif
        al_play_sample(allegro->clickOnButtonSound, allegro->volume, 0, 1, ALLEGRO_PLAYMODE_ONCE, NULL);
        //if the player does not have any equipment...
        if (character->getCardIndex() == character2->getCardIndex()) {
            if (character->haveDuneBlaster() || character->haveJetPack() || character->haveSolarShield() ||
                character->haveTerrascope() || character->haveTimeThrottle()) {
                modeEnum = OFFEREQUIPMENTMODE;
                firstTimeUpdateScreenChooseEquipment = 0;
            }
        }
    } else if (modesButtons[REQUESTWBUTTON]->checkMouse(mouse.x, mouse.y, allegro->volume)) {
        al_play_sample(allegro->clickOnButtonSound, allegro->volume, 0, 1, ALLEGRO_PLAYMODE_ONCE, NULL);
        if (WaterCarrierCharacter *waterCarrierCharacter = dynamic_cast<WaterCarrierCharacter *>(character2)) {
            if (character->getRow() == character2->getRow()) {
                if (character->getColumn() >= character2->getColumn() - 1 &&
                    character->getColumn() <= character2->getColumn() + 1) {
                    if (min(character2->getWaters(), MAXWATERS - character->getWaters() - 1) !=
                        0) { modeEnum = REQUESTWATERMODE; }
                }
            } else if (character->getColumn() == character2->getColumn()) {
                if (character2->getColumn() == character->getColumn() - 1 ||
                    character2->getColumn() == character->getColumn() + 1) {
                    if (min(character2->getWaters(), MAXWATERS - character->getWaters() - 1) !=
                        0) { modeEnum = REQUESTWATERMODE; }
                }
            }
        } else if (character->getColumn() == character2->getColumn() && character->getRow() == character2->getRow()) {
            if (min(character2->getWaters(), MAXWATERS - character->getWaters() - 1) !=
                0) { modeEnum = REQUESTWATERMODE; }
        }
    } else if (modesButtons[REQUESTEBUTTON]->checkMouse(mouse.x, mouse.y, allegro->volume)) {
        al_play_sample(allegro->clickOnButtonSound, allegro->volume, 0, 1, ALLEGRO_PLAYMODE_ONCE, NULL);
        if (character->getCardIndex() == character2->getCardIndex()) {
            if (character2->haveDuneBlaster() || character2->haveJetPack() || character2->haveSolarShield() ||
                character2->haveTerrascope() || character2->haveTimeThrottle()) {
                modeEnum = REQUESTEQUIPMENTMODE;
                firstTimeUpdateScreenChooseEquipment = 0;
            }
        }
    }
}
void SinglePlayerGame::checkTilesButtons(double volume) {
    int tempIndex;
    bool climber = false;
    if (modeEnum == MOVEOTHER) {
        tempIndex = character2->getCardIndex();
        if (ClimberCharacter *climberCharacter = dynamic_cast<ClimberCharacter *>(character2)) { climber = true; }
    } else {
        tempIndex = character->getCardIndex();
        if ((tilesDeck[tempIndex]->haveSand() || !tilesDeck[tempIndex]->isTurned())) {
            tilesDeck[tempIndex]->checkButton(mouse.x, mouse.y, volume);
        }
        if (ClimberCharacter *climberCharacter = dynamic_cast<ClimberCharacter *>(character)) { climber = true; }
    }
    if (tilesDeck[tempIndex]->canIMove(climber)) {
        if (modeEnum == NORMAL || modeEnum == MOVEOTHER) {
            if (tempIndex > 0) {
                if (tilesDeck[tempIndex - 1]->canIMove(climber) && tempIndex % 5 != 0) {
                    tilesDeck[tempIndex - 1]->checkButton(mouse.x, mouse.y, volume);
                }
            }
            if (tempIndex < TILEDECKNUMBER - 1) {
                if (tilesDeck[tempIndex + 1]->canIMove(climber) && tempIndex % 5 != 4) {
                    tilesDeck[tempIndex + 1]->checkButton(mouse.x, mouse.y, volume);
                }
            }
            if (tempIndex > 4) {
                if (tilesDeck[tempIndex - 5]->canIMove(climber)) {
                    tilesDeck[tempIndex - 5]->checkButton(mouse.x, mouse.y, volume);
                }
            }
            if (tempIndex < TILEDECKNUMBER - 5) {
                if (tilesDeck[tempIndex + 5]->canIMove(climber)) {
                    tilesDeck[tempIndex + 5]->checkButton(mouse.x, mouse.y, volume);
                }
            }
            //Tunnel Tile
            if (tilesDeck[tempIndex]->gettileType() == TUNNEL && tilesDeck[tempIndex]->isTurned()) {
                for (uint i = 0; i < tilesDeck.size(); i++) {
                    if (tilesDeck[i]->gettileType() == TUNNEL && i != tempIndex && tilesDeck[i]->isTurned()) {
                        if (tilesDeck[i]->canIMove(climber)) { tilesDeck[i]->checkButton(mouse.x, mouse.y, volume); }
                    }
                }
            }
            // Explorer Move Diagonally
            if (modeEnum == NORMAL) {
                if (ExplorerCharacter *explorerCharacter = dynamic_cast<ExplorerCharacter *>(character)) { //TODO: fix this for character2
                    if (tempIndex > 5 && tempIndex % 5 != 0) {
                        if (tilesDeck[tempIndex - 6]->canIMove(climber)) {
                            tilesDeck[tempIndex - 6]->checkButton(mouse.x, mouse.y, volume);
                        }
                    }
                    if (tempIndex > 5 && tempIndex % 5 != 4) {
                        if (tilesDeck[tempIndex - 4]->canIMove(climber)) {
                            tilesDeck[tempIndex - 4]->checkButton(mouse.x, mouse.y, volume);
                        }
                    }
                    if (tempIndex < TILEDECKNUMBER - 4 && tempIndex % 5 != 0) {
                        if (tilesDeck[tempIndex + 4]->canIMove(climber)) {
                            tilesDeck[tempIndex + 4]->checkButton(mouse.x, mouse.y, volume);
                        }
                    }
                    if (tempIndex < TILEDECKNUMBER - 6 && tempIndex % 5 != 4) {
                        if (tilesDeck[tempIndex + 6]->canIMove(climber)) {
                            tilesDeck[tempIndex + 6]->checkButton(mouse.x, mouse.y, volume);
                        }
                    }
                }
            } else if (modeEnum == MOVEOTHER) {
                if (ExplorerCharacter *explorerCharacter = dynamic_cast<ExplorerCharacter *>(character2)) {
                    if (tempIndex > 5 && tempIndex % 5 != 0) {
                        if (tilesDeck[tempIndex - 6]->canIMove(climber)) {
                            tilesDeck[tempIndex - 6]->checkButton(mouse.x, mouse.y, volume);
                        }
                    }
                    if (tempIndex > 5 && tempIndex % 5 != 4) {
                        if (tilesDeck[tempIndex - 4]->canIMove(climber)) {
                            tilesDeck[tempIndex - 4]->checkButton(mouse.x, mouse.y, volume);
                        }
                    }
                    if (tempIndex < TILEDECKNUMBER - 4 && tempIndex % 5 != 0) {
                        if (tilesDeck[tempIndex + 4]->canIMove(climber)) {
                            tilesDeck[tempIndex + 4]->checkButton(mouse.x, mouse.y, volume);
                        }
                    }
                    if (tempIndex < TILEDECKNUMBER - 6 && tempIndex % 5 != 4) {
                        if (tilesDeck[tempIndex + 6]->canIMove(climber)) {
                            tilesDeck[tempIndex + 6]->checkButton(mouse.x, mouse.y, volume);
                        }
                    }
                }
            }
        }
        if (modeEnum == REMOVESAND || modeEnum ==
                                      DUNEBLASTERMODE) { //I pass always true because in this mode I only don't want not to be marked if its the storm
            if (tempIndex > 0) {
                if (tilesDeck[tempIndex - 1]->haveSand() && tempIndex % 5 != 0) {
                    tilesDeck[tempIndex - 1]->checkButton(mouse.x, mouse.y, volume);
                }
            }
            if (tempIndex < TILEDECKNUMBER - 1) {
                if (tilesDeck[tempIndex + 1]->haveSand() && tempIndex % 5 != 4) {
                    tilesDeck[tempIndex + 1]->checkButton(mouse.x, mouse.y, volume);
                }
            }
            if (tempIndex > 4) {
                if (tilesDeck[tempIndex - 5]->haveSand()) {
                    tilesDeck[tempIndex - 5]->checkButton(mouse.x, mouse.y, volume);
                }
            }
            if (tempIndex < TILEDECKNUMBER - 5) {
                if (tilesDeck[tempIndex + 5]->haveSand()) {
                    tilesDeck[tempIndex + 5]->checkButton(mouse.x, mouse.y, volume);
                }
            }
            // Explorer Move Diagonally
            if (ExplorerCharacter *explorerCharacter = dynamic_cast<ExplorerCharacter *>(character)) {
                if (tempIndex > 5 && tempIndex % 5 != 0) {
                    if (tilesDeck[tempIndex - 6]->haveSand()) {
                        tilesDeck[tempIndex - 6]->checkButton(mouse.x, mouse.y, volume);
                    }
                }
                if (tempIndex > 5 && tempIndex % 5 != 4) {
                    if (tilesDeck[tempIndex - 4]->haveSand()) {
                        tilesDeck[tempIndex - 4]->checkButton(mouse.x, mouse.y, volume);
                    }
                }
                if (tempIndex < TILEDECKNUMBER - 4 && tempIndex % 5 != 0) {
                    if (tilesDeck[tempIndex + 4]->haveSand()) {
                        tilesDeck[tempIndex + 4]->checkButton(mouse.x, mouse.y, volume);
                    }
                }
                if (tempIndex < TILEDECKNUMBER - 6 && tempIndex % 5 != 4) {
                    if (tilesDeck[tempIndex + 6]->haveSand()) {
                        tilesDeck[tempIndex + 6]->checkButton(mouse.x, mouse.y, volume);
                    }
                }
            }
        }
    }
}
//! Draw Methods
void SinglePlayerGame::drawEquipment(EquipmentsEnum equipEnum) {
/* Gets the equipment and adds it to the player */
    switch (equipEnum) {
        case DUNEBLAST:
            character->increaseDuneBlaster();
            break;
        case JETPACK:
            character->increaseJetPack();
            break;
        case SOLARSHIELD:
            character->increaseSolarShield();
            break;
        case TERRASCOPE:
            character->increaseTerrascope();
            break;
        case SECRETWATERRESERVE:
            character->increaseWaterReserve();
            break;
        case TIMETHROTTLE:
            character->increaseTimeThrottle();
            break;
    }
    if (equipIndex == 11) { equipIndex = 0; }
    else { equipIndex++; }
}
void SinglePlayerGame::drawStormCards(ALL *allegro) {
//The sandStormLevel does not indicate the number of stormCards to be drawn
    int discount = 0;        //Sometimes, if meteorologist is playing, it may be a discount on how many cards to draw
    if (MeteorologistCharacter *meteorologistCharacter = dynamic_cast<MeteorologistCharacter *>(character)) {
        discount = character->getNumberOfMoves();
    }
    character->resetNumberOfMoves();
    character2->resetNumberOfMoves();
    if (sandStormLevel < 6) {
        if (discount < 3) {
            for (int i = 0; i < 3 - discount; i++) {
#ifdef DEBUG_GAME
                cout << "Pick Up One Storm Card" << endl;
#endif
                this->performStormCardAction(allegro, stormCardsDeck[0]->getStormCardType());
            }
        }
    } else if (sandStormLevel >= 6 && sandStormLevel < 10) {
        if (discount != 4) {
            for (int i = 0; i < 4 - discount; i++) {
#ifdef DEBUG_GAME
                cout << "Pick Up One Storm Card" << endl;
#endif
                this->performStormCardAction(allegro, stormCardsDeck[0]->getStormCardType());
            }
        }
    } else if (sandStormLevel >= 10 && sandStormLevel < 13) {
        for (int i = 0; i < 5 - discount; i++) {
#ifdef DEBUG_GAME
            cout << "Pick Up One Storm Card" << endl;
#endif
            this->performStormCardAction(allegro, stormCardsDeck[0]->getStormCardType());
        }
    } else if (sandStormLevel >= 13 && sandStormLevel < 15) {
        for (int i = 0; i < 6 - discount; i++) {
#ifdef DEBUG_GAME
            cout << "Pick Up One Storm Card" << endl;
#endif
            this->performStormCardAction(allegro, stormCardsDeck[0]->getStormCardType());
        }
    }
}
void SinglePlayerGame::performEquipmentsAction(EquipmentsEnum equipEnum, ALL *allegro) {
    /* Similar to performTileAction. gets the enum of the equipment and acts accordingly */
    bool run = true;
    switch (equipEnum) {
        case DUNEBLAST:
            character->decreaseDuneBlaster();
            modeEnum = DUNEBLASTERMODE;
            break;
        case JETPACK:
            character->decreaseJetPack();
            modeEnum = JETPACKMODE;
            break;
        case SOLARSHIELD:
            character->decreaseSolarShield();
            character->shield = true;
            break;
        case TERRASCOPE:
            character->decreaseTerrascope();
            al_play_sample(allegro->curiositySound, allegro->volume, 0, 1, ALLEGRO_PLAYMODE_ONCE, NULL);
            modeEnum = TERRASCOPEMODE;
            break;
        case SECRETWATERRESERVE:
            //2 waters for each player
            character->decreaseWaterReserve();
            character->addWater();
            character->addWater();
            al_play_sample(allegro->waterSound, allegro->volume, 0, 1, ALLEGRO_PLAYMODE_ONCE, NULL);
            if (character->getRow() == character2->getRow() && character->getColumn() == character2->getColumn()) {
                character2->addWater();
                character2->addWater();
            }
            break;
        case TIMETHROTTLE:
            character->decreaseTimeThrottle();
            character->increaseMoves();
            character->increaseMoves();
            break;
        default:
            break;
    }
}
bool SinglePlayerGame::eventHandler(ALL *allegro) {
    bool stillPlaying = true;
    ALLEGRO_EVENT ev;
    al_wait_for_event(allegro->events_queue, &ev);

    if (ev.type == ALLEGRO_EVENT_TIMER) { redraw = true; }
    else if (ev.type == ALLEGRO_EVENT_DISPLAY_CLOSE) {
        stillPlaying = false;
    } else if (ev.type == ALLEGRO_EVENT_MOUSE_AXES || ev.type == ALLEGRO_EVENT_MOUSE_ENTER_DISPLAY) {
        mouse.x = ev.mouse.x;
        mouse.y = ev.mouse.y;
        checkMouse(allegro);
    } else if (ev.type == ALLEGRO_EVENT_MOUSE_BUTTON_UP) {
        if (ev.mouse.button == SECONDARY_BUTTON) { keyEscape(); }
        else click(allegro);
    } else if (ev.type == ALLEGRO_EVENT_KEY_UP) {
        switch (ev.keyboard.keycode) {
            case ALLEGRO_KEY_ESCAPE: //In case you want to cancel any mode you've played before.
                keyEscape();
                modeEnum = NORMAL;
                break;
            case ALLEGRO_KEY_UP:
                keyUp(allegro);
                if (modeEnum != MOVEOTHER) { modeEnum = NORMAL; }
                break;
            case ALLEGRO_KEY_DOWN:
                keyDown(allegro);
                if (modeEnum != MOVEOTHER) { modeEnum = NORMAL; }
                break;
            case ALLEGRO_KEY_LEFT:
                keyLeft(allegro);
                if (modeEnum == REMOVESAND) { modeEnum = NORMAL; }
                break;
            case ALLEGRO_KEY_RIGHT:
                keyRight(allegro);
                if (modeEnum == REMOVESAND) { modeEnum = NORMAL; }
                break;
            case ALLEGRO_KEY_E:
                keyE(allegro);
                modeEnum = NORMAL;
                break;
            case ALLEGRO_KEY_P:
                keyP(allegro);
                modeEnum = NORMAL;
                break;
            case ALLEGRO_KEY_R:
                keyR(allegro);
                if (auto *explorerCharacter = dynamic_cast<ArcheologistCharacter *>(character)) {
                    if (modeEnum == REMOVESAND) {
                        if (tilesDeck[character->getCardIndex()]->haveSand()) {
                            tilesDeck[character->getCardIndex()]->removeSand();
                        }
                    }
                }
                if (modeEnum == NORMAL) { modeEnum = REMOVESAND; }
                else { modeEnum = NORMAL; }
                break;
            case ALLEGRO_KEY_W:
                if (modeEnum == NORMAL &&
                    character2->getWaters() < MAXWATERS) {    //TODO: cambiar cuando haga el water carrier
                    modeEnum = OFFERWATERMODE;
                } else { modeEnum = NORMAL; }
                break;
            case ALLEGRO_KEY_O:
                if (modeEnum == NORMAL) {
                    if (character->getCardIndex() == character2->getCardIndex()) {
                        if (character->haveDuneBlaster() || character->haveJetPack() ||
                            character->haveSolarShield() || character->haveTerrascope() ||
                            character->haveTimeThrottle()) {
                            modeEnum = OFFEREQUIPMENTMODE;
                            firstTimeUpdateScreenChooseEquipment = 0;
                        }
                    }
                } else { modeEnum = NORMAL; }
                break;
            default:
                break;
        }
    }
    //this 'if' checks if the other player I'm moving has already moved 3 spaces... if so... get out of the move other mode
    if (modeEnum == MOVEOTHER) {
        if (auto *navigatorCharacter = dynamic_cast<NavigatorCharacter *>(character)) {
            if (!navigatorCharacter->havePartnersMovesLeft()) {
                modeEnum = NORMAL;
                character2->resetNumberOfMoves();
                navigatorCharacter->decreseMoves();
            }
        } else { cerr << "Error: was in moveother mode without being a Navigator" << endl; }
    }
    //checks if win or lose
    if (redraw && al_is_event_queue_empty(allegro->events_queue)) {
        if (lose(allegro)) { stillPlaying = false; }
        else if (win(allegro)) { stillPlaying = false; }
        updateScreen(allegro);
    }
    return stillPlaying;
}
void SinglePlayerGame::pickUpAction() {
/*	Picks up the part in question. The function use the character acording to whose turn is it and then checks if its posible to pick up
	the part. If it is, picks up the correct part
	*/
    Character *tempChar;            //pointer to character. it will point to character 1 or 2 acording to whose turn is it.
    tempChar = character;
    // This code makes the player be able to pick up multiple items at once if they are at the same place
    if (tempChar->getRow() == engine->getRow() && tempChar->getColumn() == engine->getColumn()) {
        if (engine->getFoundState()) {            //Only able to pick it up if I found it
            if (tilesDeck[tempChar->getCardIndex()]->isTurned()) {
                if (tilesDeck[tempChar->getCardIndex()]->canIMove(false)) {
                    if (tempChar->pickUpPart()) { engine->pickUpPart(); }
                }
            }
        }
    }
    if (tempChar->getRow() == solarCrystal->getRow() && tempChar->getColumn() == solarCrystal->getColumn()) {
        if (solarCrystal->getFoundState()) {
            if (tilesDeck[tempChar->getCardIndex()]->isTurned()) {
                if (tilesDeck[tempChar->getCardIndex()]->canIMove(false)) {
                    if (tempChar->pickUpPart()) { solarCrystal->pickUpPart(); }
                }
            }
        }
    }
    if (tempChar->getRow() == propeller->getRow() && tempChar->getColumn() == propeller->getColumn()) {
        if (propeller->getFoundState()) {
            if (tilesDeck[tempChar->getCardIndex()]->isTurned()) {
                if (tilesDeck[tempChar->getCardIndex()]->canIMove(false)) {
                    if (tempChar->pickUpPart()) { propeller->pickUpPart(); }
                }
            }
        }
    }
    if (navigationDeck->getRow() == tempChar->getRow() && tempChar->getColumn() == navigationDeck->getColumn()) {
        if (navigationDeck->getFoundState()) {
            if (tilesDeck[tempChar->getCardIndex()]->isTurned()) {
                if (tilesDeck[tempChar->getCardIndex()]->canIMove(false)) {
                    if (tempChar->pickUpPart()) { navigationDeck->pickUpPart(); }
                }
            }
        }
    }
}
</file>

<file path="src/StartMenu.cpp">
#include <include/StartMenu.hpp>

#include "StartMenu.hpp"

StartMenu::StartMenu(ALL* allegro) {
    al_set_target_backbuffer(allegro->startMenuDisplay);
    al_clear_to_color(al_map_rgb(0, 0, 0));
    al_draw_bitmap(allegro->backgroundStartMenuImage, 0, 0, 0);
    initializeButtons(allegro);
}
bool StartMenu::eventHandler(ALL *allegro) {
	bool chooseMode = true;
	ALLEGRO_EVENT ev;
	al_wait_for_event(allegro->events_queue, &ev);
	if (ev.type == ALLEGRO_EVENT_TIMER) { redraw = true; }
	else if (ev.type == ALLEGRO_EVENT_DISPLAY_CLOSE) {
		/*gamePack.quit();
		gamePack.sendPack();
		gamePack.waitForAck(allegro);*/
	}
	else if (ev.type == ALLEGRO_EVENT_MOUSE_AXES || ev.type == ALLEGRO_EVENT_MOUSE_ENTER_DISPLAY) {
		mouse.x = ev.mouse.x;
		mouse.y = ev.mouse.y;
		checkMouse(allegro);
	}
	else if (ev.type == ALLEGRO_EVENT_MOUSE_BUTTON_UP) {
		if (ev.mouse.button == SECONDARY_BUTTON) {
			// Do Nothing
		}
		else {
		    chooseMode = click(allegro);
		}
	}
	if (redraw && al_is_event_queue_empty(allegro->events_queue)) {
		updateScreen(allegro);
	}

	return chooseMode;
}
bool StartMenu::click(ALL *allegro) {
	if (singlePlayerButton->checkMouse(mouse.x, mouse.y, allegro->volume)) {
	    singlePlayer = true;
	}
	else if(multiPlayerButton->checkMouse(mouse.x, mouse.y, allegro->volume)) {
	    singlePlayer = false;
	}
	else { return true; }
	return false;
}
void StartMenu::initializeButtons(ALL *allegro) {
	singlePlayerButton = new Button(WIDTH * allegro->screenWidth / MAXRESOLUTION_X / 2 - al_get_bitmap_width(al_load_bitmap("Resources/Buttons/singlePlayerSelectedButton.png")) / 2,
	        HEIGHT * allegro->screenHeight / MAXRESOLUTION_Y * 1 / 3,
	        "Resources/Buttons/singlePlayerButton.png", "Resources/Buttons/singlePlayerSelectedButton.png", allegro);
	multiPlayerButton = new Button(WIDTH * allegro->screenWidth / MAXRESOLUTION_X / 2 - al_get_bitmap_width(al_load_bitmap("Resources/Buttons/singlePlayerSelectedButton.png")) / 2,
	        HEIGHT * allegro->screenHeight / MAXRESOLUTION_Y * 2 / 3,
	        "Resources/Buttons/lanButton.png", "Resources/Buttons/lanSelectedButton.png", allegro);
}
void StartMenu::checkMouse(ALL *allegro) {
	singlePlayerButton->checkMouse(mouse.x, mouse.y, allegro->volume);
	multiPlayerButton->checkMouse(mouse.x, mouse.y, allegro->volume);
}
void StartMenu::updateScreen(ALL *allegro) {
	al_set_target_backbuffer(allegro->startMenuDisplay);
	al_draw_textf(allegro->statusFont, al_map_rgb(WHITE), WIDTH * allegro->screenWidth / MAXRESOLUTION_X / 2, HEIGHT * allegro->screenHeight / MAXRESOLUTION_Y - 12, ALLEGRO_ALIGN_CENTRE, "%s", "Welcome to Forbidden Desert");
	singlePlayerButton->updateButton(allegro);
	multiPlayerButton->updateButton(allegro);
	al_flip_display();
}

//StartMenu::~StartMenu(){
//	al_destroy_bitmap(background);
//}
</file>

<file path="src/StormCard.cpp">
#include "StormCard.hpp"
#define STORMCARD_X 0.8375
#define STORMCARD_Y 0.3722
StormCard::StormCard() {}
StormCard::StormCard(StormCardsEnum cardEnum, ALL *allegro) {
	switch (cardEnum)
	{
	case SUNBEATSDOWN:
		this->cardImage = al_load_bitmap_resized("Resources/Storm Cards/sunBeatsDownImage.png", allegro);
		break;
	case STORMUP:
		this->cardImage = al_load_bitmap_resized("Resources/Storm Cards/stormPickUpImage.png", allegro);
		break;
	case RIGHT1:
		this->cardImage = al_load_bitmap_resized("Resources/Storm Cards/1stormRightImage.png", allegro);
		break;
	case LEFT1:
		this->cardImage = al_load_bitmap_resized("Resources/Storm Cards/1stormLeftImage.png", allegro);
		break;
	case UP1:
		this->cardImage = al_load_bitmap_resized("Resources/Storm Cards/1stormUpImage.png", allegro);
		break;
	case DOWN1:
		this->cardImage = al_load_bitmap_resized("Resources/Storm Cards/1stormDownImage.png", allegro);
		break;
	case RIGHT2:
		this->cardImage = al_load_bitmap_resized("Resources/Storm Cards/2stormRightImage.png", allegro);
		break;
	case LEFT2:
		this->cardImage = al_load_bitmap_resized("Resources/Storm Cards/2stormLeftImage.png", allegro);
		break;
	case UP2:
		this->cardImage = al_load_bitmap_resized("Resources/Storm Cards/2stormUpImage.png", allegro);
		break;
	case DOWN2:
		this->cardImage = al_load_bitmap_resized("Resources/Storm Cards/2stormDownImage.png", allegro);
		break;
	case RIGHT3:
		this->cardImage = al_load_bitmap_resized("Resources/Storm Cards/3stormRightImage.png", allegro);
		break;
	case LEFT3:
		this->cardImage = al_load_bitmap_resized("Resources/Storm Cards/3stormLeftImage.png", allegro);
		break;
	case UP3:
		this->cardImage = al_load_bitmap_resized("Resources/Storm Cards/3stormUpImage.png", allegro);
		break;
	case DOWN3:
		this->cardImage = al_load_bitmap_resized("Resources/Storm Cards/3stormDownImage.png", allegro);
		break;
	}

	if( this->cardImage)
		stormCardEnum = cardEnum;
	else { cerr << "Failed to load " << cardEnum << " image" << endl;}
}
void StormCard::showImage(ALL *allegro){
	al_draw_bitmap(cardImage, allegro->screenWidth * STORMCARD_X, allegro->screenHeight * STORMCARD_Y, 0);
	al_flip_display();
}
StormCard::~StormCard(){
	al_destroy_bitmap(cardImage);
}
</file>

<file path="src/Tile.cpp">
#include "Tile.hpp"

Tile::Tile() {}
Tile::Tile(TilesEnum tileType, ALL* allegro) {
	switch (tileType) {
	case STORM:
		this->backOfCardImage = al_load_bitmap_resized("Resources/Tiles/stormImage.png", allegro);
		this->frontOfCardImage = al_load_bitmap_resized("Resources/Tiles/stormImage.png", allegro);
		frontCardButton = new Button(0, 0, "Resources/Buttons/Tiles/crashSiteImage.png", "Resources/Buttons/Tiles/crashSiteImage.png", allegro);
		backCardButton = new Button(0, 0, "Resources/Buttons/Tiles/crashSiteImage.png", "Resources/Buttons/Tiles/crashSiteImage.png", allegro);
		break;
	case CRASHSITE:
		this->backOfCardImage = al_load_bitmap_resized("Resources/Tiles/crashSiteImage.png", allegro);
		this->frontOfCardImage = al_load_bitmap_resized("Resources/Tiles/crashSiteImage.png", allegro);
		frontCardButton = new Button(0, 0, "Resources/Buttons/Tiles/noCrashSiteImage.png", "Resources/Buttons/Tiles/crashSiteImage.png", allegro);
		backCardButton = new Button(0, 0, "Resources/Buttons/Tiles/noCrashSiteImage.png", "Resources/Buttons/Tiles/crashSiteImage.png", allegro);
		break;
	case LAUNCHPAD:
		this->backOfCardImage = al_load_bitmap_resized("Resources/Tiles/backOfCardImage.png", allegro);
		this->frontOfCardImage = al_load_bitmap_resized("Resources/Tiles/launchPadImage.png", allegro);
		frontCardButton = new Button(0, 0, "Resources/Buttons/Tiles/noLaunchPadImage.png", "Resources/Buttons/Tiles/launchPadImage.png", allegro);
		backCardButton = new Button(0, 0, "Resources/Buttons/Tiles/noBackOfCardImage.png", "Resources/Buttons/Tiles/backOfCardImage.png", allegro);
		break;
	case DEFAULT:
		this->backOfCardImage = al_load_bitmap_resized("Resources/Tiles/waterTileImage.png", allegro);
		this->frontOfCardImage = al_load_bitmap_resized("Resources/Tiles/mirageImage.png", allegro);
		frontCardButton = new Button(0, 0, "Resources/Buttons/Tiles/noMirageImage.png", "Resources/Buttons/Tiles/mirageImage.png", allegro);
		backCardButton = new Button(0, 0, "Resources/Buttons/Tiles/noWaterTileImage.png", "Resources/Buttons/Tiles/waterTileImage.png", allegro);
		break;
	case WATER:
		this->backOfCardImage = al_load_bitmap_resized("Resources/Tiles/waterTileImage.png", allegro);
		this->frontOfCardImage = al_load_bitmap_resized("Resources/Tiles/wellImage.png", allegro);
		frontCardButton = new Button(0, 0, "Resources/Buttons/Tiles/noWellImage.png", "Resources/Buttons/Tiles/wellImage.png", allegro);
		backCardButton = new Button(0, 0, "Resources/Buttons/Tiles/noWaterTileImage.png", "Resources/Buttons/Tiles/waterTileImage.png", allegro);
		break;
	case TUNNEL:
		this->backOfCardImage = al_load_bitmap_resized("Resources/Tiles/backOfCardImage.png", allegro);
		this->frontOfCardImage = al_load_bitmap_resized("Resources/Tiles/tunnelImage.png", allegro);
		frontCardButton = new Button(0, 0, "Resources/Buttons/Tiles/noTunnelImage.png", "Resources/Buttons/Tiles/tunnelImage.png", allegro);
		backCardButton = new Button(0, 0, "Resources/Buttons/Tiles/noBackOfCardImage.png", "Resources/Buttons/Tiles/backOfCardImage.png", allegro);
		break;
	case ENGINECOLUMN:
		this->backOfCardImage = al_load_bitmap_resized("Resources/Tiles/backOfCardImage.png", allegro);
		this->frontOfCardImage = al_load_bitmap_resized("Resources/Tiles/engineColumnImage.png", allegro);
		frontCardButton = new Button(0, 0, "Resources/Buttons/Tiles/noEngineColumnImage.png", "Resources/Buttons/Tiles/engineColumnImage.png", allegro);
		backCardButton = new Button(0, 0, "Resources/Buttons/Tiles/noBackOfCardImage.png", "Resources/Buttons/Tiles/backOfCardImage.png", allegro);
		break;
	case ENGINEROW:
		this->backOfCardImage = al_load_bitmap_resized("Resources/Tiles/backOfCardImage.png", allegro);
		this->frontOfCardImage = al_load_bitmap_resized("Resources/Tiles/engineRowImage.png", allegro);
		frontCardButton = new Button(0, 0, "Resources/Buttons/Tiles/noEngineRowImage.png", "Resources/Buttons/Tiles/engineRowImage.png", allegro);
		backCardButton = new Button(0, 0, "Resources/Buttons/Tiles/noBackOfCardImage.png", "Resources/Buttons/Tiles/backOfCardImage.png", allegro);
		break;
	case SOLARCRYSCOLUMN:
		this->backOfCardImage = al_load_bitmap_resized("Resources/Tiles/backOfCardImage.png", allegro);
		this->frontOfCardImage = al_load_bitmap_resized("Resources/Tiles/solarCrystalColumnImage.png", allegro);
		frontCardButton = new Button(0, 0, "Resources/Buttons/Tiles/noSolarCrystalColumnImage.png", "Resources/Buttons/Tiles/solarCrystalColumnImage.png", allegro);
		backCardButton = new Button(0, 0, "Resources/Buttons/Tiles/noBackOfCardImage.png", "Resources/Buttons/Tiles/backOfCardImage.png", allegro);
		break;
	case SOLARCRYSROW:
		this->backOfCardImage = al_load_bitmap_resized("Resources/Tiles/backOfCardImage.png", allegro);
		this->frontOfCardImage = al_load_bitmap_resized("Resources/Tiles/solarCrystalRowImage.png", allegro);
		frontCardButton = new Button(0, 0, "Resources/Buttons/Tiles/noSolarCrystalRowImage.png", "Resources/Buttons/Tiles/solarCrystalRowImage.png", allegro);
		backCardButton = new Button(0, 0, "Resources/Buttons/Tiles/noBackOfCardImage.png", "Resources/Buttons/Tiles/backOfCardImage.png", allegro);
		break;
	case PROPELLERCOLUMN:
		this->backOfCardImage = al_load_bitmap_resized("Resources/Tiles/backOfCardImage.png", allegro);
		this->frontOfCardImage = al_load_bitmap_resized("Resources/Tiles/propellerColumnImage.png", allegro);
		frontCardButton = new Button(0, 0, "Resources/Buttons/Tiles/noPropellerColumnImage.png", "Resources/Buttons/Tiles/propellerColumnImage.png", allegro);
		backCardButton = new Button(0, 0, "Resources/Buttons/Tiles/noBackOfCardImage.png", "Resources/Buttons/Tiles/backOfCardImage.png", allegro);
		break;
	case PROPELLERROW:
		this->backOfCardImage = al_load_bitmap_resized("Resources/Tiles/backOfCardImage.png", allegro);
		this->frontOfCardImage = al_load_bitmap_resized("Resources/Tiles/propellerRowImage.png", allegro);
		frontCardButton = new Button(0, 0, "Resources/Buttons/Tiles/noPropellerRowImage.png", "Resources/Buttons/Tiles/propellerRowImage.png", allegro);
		backCardButton = new Button(0, 0, "Resources/Buttons/Tiles/noBackOfCardImage.png", "Resources/Buttons/Tiles/backOfCardImage.png", allegro);
		break;
	case NAVIGATIONCOLUMN:
		this->backOfCardImage = al_load_bitmap_resized("Resources/Tiles/backOfCardImage.png", allegro);
		this->frontOfCardImage = al_load_bitmap_resized("Resources/Tiles/navigationDeckColumnImage.png", allegro);
		frontCardButton = new Button(0, 0, "Resources/Buttons/Tiles/noNavigationDeckColumnImage.png", "Resources/Buttons/Tiles/navigationDeckColumnImage.png", allegro);
		backCardButton = new Button(0, 0, "Resources/Buttons/Tiles/noBackOfCardImage.png", "Resources/Buttons/Tiles/backOfCardImage.png", allegro);
		break;
	case NAVIGATIONROW:
		this->backOfCardImage = al_load_bitmap_resized("Resources/Tiles/backOfCardImage.png", allegro);
		this->frontOfCardImage = al_load_bitmap_resized("Resources/Tiles/navigationDeckRowImage.png", allegro);
		frontCardButton = new Button(0, 0, "Resources/Buttons/Tiles/noNavigationDeckRowImage.png", "Resources/Buttons/Tiles/navigationDeckRowImage.png", allegro);
		backCardButton = new Button(0, 0, "Resources/Buttons/Tiles/noBackOfCardImage.png", "Resources/Buttons/Tiles/backOfCardImage.png", allegro);
		break;
	case GEAR1:
		this->backOfCardImage = al_load_bitmap_resized("Resources/Tiles/backOfCardImage.png", allegro);
		this->frontOfCardImage = al_load_bitmap_resized("Resources/Tiles/gear1Image.png", allegro);
		frontCardButton = new Button(0, 0, "Resources/Buttons/Tiles/noGear1Image.png", "Resources/Buttons/Tiles/gear1Image.png", allegro);
		backCardButton = new Button(0, 0, "Resources/Buttons/Tiles/noBackOfCardImage.png", "Resources/Buttons/Tiles/backOfCardImage.png", allegro);
		break;
	case GEAR2:
		this->backOfCardImage = al_load_bitmap_resized("Resources/Tiles/backOfCardImage.png", allegro);
		this->frontOfCardImage = al_load_bitmap_resized("Resources/Tiles/gear2Image.png", allegro);
		frontCardButton = new Button(0, 0, "Resources/Buttons/Tiles/noGear2Image.png", "Resources/Buttons/Tiles/gear2Image.png", allegro);
		backCardButton = new Button(0, 0, "Resources/Buttons/Tiles/noBackOfCardImage.png", "Resources/Buttons/Tiles/backOfCardImage.png", allegro);
		break;
	case GEAR3:
		this->backOfCardImage = al_load_bitmap_resized("Resources/Tiles/backOfCardImage.png", allegro);
		this->frontOfCardImage = al_load_bitmap_resized("Resources/Tiles/gear3Image.png", allegro);
		frontCardButton = new Button(0, 0, "Resources/Buttons/Tiles/noGear3Image.png", "Resources/Buttons/Tiles/gear3Image.png", allegro);
		backCardButton = new Button(0, 0, "Resources/Buttons/Tiles/noBackOfCardImage.png", "Resources/Buttons/Tiles/backOfCardImage.png", allegro);
		break;
	case GEAR4:
		this->backOfCardImage = al_load_bitmap_resized("Resources/Tiles/backOfCardImage.png", allegro);
		this->frontOfCardImage = al_load_bitmap_resized("Resources/Tiles/gear4Image.png", allegro);
		frontCardButton = new Button(0, 0, "Resources/Buttons/Tiles/noGear4Image.png", "Resources/Buttons/Tiles/gear4Image.png", allegro);
		backCardButton = new Button(0, 0, "Resources/Buttons/Tiles/noBackOfCardImage.png", "Resources/Buttons/Tiles/backOfCardImage.png", allegro);
		break;
	case GEAR5:
		this->backOfCardImage = al_load_bitmap_resized("Resources/Tiles/backOfCardImage.png", allegro);
		this->frontOfCardImage = al_load_bitmap_resized("Resources/Tiles/gear5Image.png", allegro);
		frontCardButton = new Button(0, 0, "Resources/Buttons/Tiles/noGear5Image.png", "Resources/Buttons/Tiles/gear5Image.png", allegro);
		backCardButton = new Button(0, 0, "Resources/Buttons/Tiles/noBackOfCardImage.png", "Resources/Buttons/Tiles/backOfCardImage.png", allegro);
		break;
	case GEAR6:
		this->backOfCardImage = al_load_bitmap_resized("Resources/Tiles/backOfCardImage.png", allegro);
		this->frontOfCardImage = al_load_bitmap_resized("Resources/Tiles/gear6Image.png", allegro);
		frontCardButton = new Button(0, 0, "Resources/Buttons/Tiles/noGear6Image.png", "Resources/Buttons/Tiles/gear6Image.png", allegro);
		backCardButton = new Button(0, 0, "Resources/Buttons/Tiles/noBackOfCardImage.png", "Resources/Buttons/Tiles/backOfCardImage.png", allegro);
		break;
	case GEAR7:
		this->backOfCardImage = al_load_bitmap_resized("Resources/Tiles/backOfCardImage.png", allegro);
		this->frontOfCardImage = al_load_bitmap_resized("Resources/Tiles/gear7Image.png", allegro);
		frontCardButton = new Button(0, 0, "Resources/Buttons/Tiles/noGear7Image.png", "Resources/Buttons/Tiles/gear7Image.png", allegro);
		backCardButton = new Button(0, 0, "Resources/Buttons/Tiles/noBackOfCardImage.png", "Resources/Buttons/Tiles/backOfCardImage.png", allegro);
		break;
	case GEAR8:
		this->backOfCardImage = al_load_bitmap_resized("Resources/Tiles/backOfCardImage.png", allegro);
		this->frontOfCardImage = al_load_bitmap_resized("Resources/Tiles/gear8Image.png", allegro);
		frontCardButton = new Button(0, 0, "Resources/Buttons/Tiles/noGear8Image.png", "Resources/Buttons/Tiles/gear8Image.png", allegro);
		backCardButton = new Button(0, 0, "Resources/Buttons/Tiles/noBackOfCardImage.png", "Resources/Buttons/Tiles/backOfCardImage.png", allegro);
		break;
	}
	if (this->backOfCardImage && this->frontOfCardImage) {
		turned = false;
		tileEnum = tileType;
		if(oneSandImage = al_load_bitmap_resized("Resources/Tiles/sandMarkerImage.png", allegro)){
			if (multipleSandImage = al_load_bitmap_resized("Resources/Tiles/highSandMarkerImage.png", allegro)) {
				sand = 0;
				tileCoords.x = 0;
				tileCoords.y = 0;
			}
		}
		else { cerr << "Failed to load sandMarkerImage.png" << endl; }
	}
	else { cerr << "Failed to load front of card Image for " << TilesNames[tileType] << endl; }
}
void Tile::setCoord(pos coords) { 
	tileCoords = coords;
	frontCardButton->changeCoords(coords.x - 4, coords.y + al_get_bitmap_height(backOfCardImage) / 2 + 1);
	backCardButton->changeCoords(coords.x - 4, coords.y + al_get_bitmap_height(backOfCardImage) / 2 + 1);
}
void Tile::setSand(int i) { sand = i; }
void Tile::increaseSand() { sand++; }
void Tile::updateTile(ALL *allegro) {
	if (turned) {
		al_draw_bitmap(frontOfCardImage, tileCoords.x, tileCoords.y, 0);
	}
	else {
		al_draw_bitmap(backOfCardImage, tileCoords.x, tileCoords.y, 0);
	}
	if (sand == 1) {
		al_draw_bitmap(oneSandImage, tileCoords.x, tileCoords.y, 0);
	}
	else if (sand > 1) {
		al_draw_bitmap(multipleSandImage, tileCoords.x, tileCoords.y, 0);
		if (sand > 2) {		//Les gusta asi? cosa que cuando hay 2 no dice nada y te avisa solo si hay mas? saquen el if si prefieren que siempre avise
			al_draw_textf(allegro->font, al_map_rgb(WHITE), tileCoords.x + al_get_bitmap_width(multipleSandImage) / 2, tileCoords.y + al_get_bitmap_height(multipleSandImage) / 4, ALLEGRO_ALIGN_CENTER, "%d", sand);
		}
	}
}
bool Tile::canIMove(bool climber) {
	if (climber == false) {
		if (sand > 1) { return false; }
	}
	return (tileEnum != STORM);			//If there are 1 or 0 sands I can move only if the tile its not the storm.
}
bool Tile::canIMoveClimber() {
	return (tileEnum != STORM);
}
bool Tile::haveSand() {
	if (sand != 0) { return true; } 
	else { return false; }
}
void Tile::turnTile(){
	if (!haveSand()) {
		turned = true;
	}
}
void Tile::turnTerrascopeTile()
{
	turned=true;
	sand=0;
}
//Buttons methods
void Tile::updateButton(ALL* allegro) {
	if (turned) { frontCardButton->updateButton(allegro); }
	else { backCardButton->updateButton(allegro); }
	if (sand == 1) { al_draw_bitmap(oneSandImage, tileCoords.x, tileCoords.y, 0); }
	else if (sand > 1) {
		al_draw_bitmap(multipleSandImage, tileCoords.x, tileCoords.y, 0);
		if (sand > 2) {		//Les gusta asi? cosa que cuando hay 2 no dice nada y te avisa solo si hay mas? saquen el if si prefieren que siempre avise
			al_draw_textf(allegro->font, al_map_rgb(WHITE), tileCoords.x + al_get_bitmap_width(multipleSandImage) / 2, tileCoords.y + al_get_bitmap_height(multipleSandImage) / 4, ALLEGRO_ALIGN_CENTER, "%d", sand);
		}
	}
}
bool Tile::checkButton(int mousex, int mousey, double volume) {
	if (turned) { return frontCardButton->checkMouse(mousex, mousey, volume); }
	else { return backCardButton->checkMouse(mousex,mousey, volume); }
}
Tile::~Tile(){
	delete frontCardButton;
	delete backCardButton;
	al_destroy_bitmap(backOfCardImage);
	al_destroy_bitmap(frontOfCardImage);
	al_destroy_bitmap(oneSandImage);
	al_destroy_bitmap(multipleSandImage);
}
</file>

<file path="src/WaitForEvent.cpp">
/*



char waitForEvent() {
	Sleep(59);
	Container container = recivePack();
	return container.ID;
}



*/
</file>

<file path="src/WaterCarrierButton.cpp">
#include "WaterCarrierButton.hpp"

WaterCarrierButton::WaterCarrierButton() {}
WaterCarrierButton::WaterCarrierButton(int x0, int y0, const char *imageName, const char * nonSelectedImageName, ALL* allegro) : Button(x0, y0, imageName, nonSelectedImageName, allegro) {}

bool WaterCarrierButton::buttonAction(int x, int y) {
	if (mouseOverButton) {
		cout << "Click on WaterCarrier Button" << endl;
		al_play_sample(selectCharSample, 1.0, 0.0, 1.0, ALLEGRO_PLAYMODE_ONCE, NULL);
		return true;
	}
	return false;
}
</file>

<file path="src/WaterCarrierCharacter.cpp">
#include "WaterCarrierCharacter.hpp"

WaterCarrierCharacter::WaterCarrierCharacter(int rowSet, int columnSet, Container info, ALL *allegro) : Character(rowSet, columnSet, info, allegro) {
	if(adventurerImage = al_load_bitmap_resized("Resources/Players/waterCarrierImage.png", allegro)){
		if (watersImages[0] = al_load_bitmap_resized("Resources/Water Level/WaterCarrier/0WaterLevelImage.png", allegro)) {
			if (watersImages[1] = al_load_bitmap_resized("Resources/Water Level/WaterCarrier/1WaterLevelImage.png", allegro)) {
				if (watersImages[2] = al_load_bitmap_resized("Resources/Water Level/WaterCarrier/2WaterLevelImage.png", allegro)) {
					if (watersImages[3] = al_load_bitmap_resized("Resources/Water Level/WaterCarrier/3WaterLevelImage.png", allegro)) {
						if (watersImages[4] = al_load_bitmap_resized("Resources/Water Level/WaterCarrier/4WaterLevelImage.png", allegro)) {
							if (watersImages[5] = al_load_bitmap_resized("Resources/Water Level/WaterCarrier/5WaterLevelImage.png", allegro)) {
								if (watersImages[6] = al_load_bitmap_resized("Resources/Water Level/WaterCarrier/DWaterLevelImage.png", allegro)) {
									if (image = al_load_bitmap_resized("Resources/Players/Pawns/WaterCarrierPawnImage.png", allegro)) {
										if (disabledGetWatersFromWellImage = al_load_bitmap_resized("Resources/Players/WaterCarrierButton/disabledGetWaterImage.png", allegro)) {
											waters = 5;
											getWatersFromWellButton = new Button(allegro->screenWidth / 7 + al_get_bitmap_width(disabledGetWatersFromWellImage), allegro->screenHeight / 2, "Resources/Players/WaterCarrierButton/noMouseOverGetWater.png", "Resources/Players/WaterCarrierButton/mouseOverGetWater.png", allegro);
										}
										else { cout << "Failed to load dislabled get waters from well image" << endl; }
									}
									else { cout << "Failed to load Water Carrier Pawn Image" << endl; }
								}
								else { cout << "Unable to load Dead Water Level Image" << endl; }
							}
							else { cout << "Unable to load 5 Water Level Image" << endl; }
						}
						else { cout << "Unable to load 4 water level Image" << endl; }
					}
					else { cout << "Unable to load 3 water level Image" << endl; }
				}
				else { cout << "Unable to load 2 water level Image" << endl; }
			}
			else { cout << "Unable to load 1 water level Image" << endl; }
		}
		else { cout << "Unable to load 0 water level Image" << endl; }
	}
	else { cout << "Failed to load archeologistImage.png" << endl; }
	//Sounds
	if (gettingCloseSound = al_load_sample("Resources/Sounds/MustBeGettingClose(Girl).wav")) {}
	else { cout << "Failed to load Must be getting close Sound" << endl; }
}
void WaterCarrierCharacter::addWater() {
	if (waters < 5) {
		waters++;
	}
}
void WaterCarrierCharacter::updateGetWatersFromWell(bool imOnDiscoveredWell, ALL* allegro) {
	if (imOnDiscoveredWell) { getWatersFromWellButton->updateButton(allegro); }
	else { al_draw_bitmap(disabledGetWatersFromWellImage, allegro->screenWidth / 7 + al_get_bitmap_width(disabledGetWatersFromWellImage), (allegro->screenHeight - al_get_bitmap_height(disabledGetWatersFromWellImage)) / 2, 0); }
}
bool WaterCarrierCharacter::getWatersFromWell() {
	if (waters < 5 && numberOfMoves > 0) {
		addWater();
		addWater();
		decreseMoves();
		return true;
	}
	else { return false; }
}
WaterCarrierCharacter::~WaterCarrierCharacter(){
	for (int i = 0; i < MAXOFWATERS; i++) { al_destroy_bitmap(watersImage[i]); }
	al_destroy_bitmap(waterCarrierImage);
	al_destroy_bitmap(disabledGetWatersFromWellImage);
	al_destroy_sample(gettingCloseSound);
	delete getWatersFromWellButton;
}
</file>

<file path="testingAllegro/hello.c">
#include <allegro5/allegro5.h>
#include <allegro5/allegro_font.h>

int main()
{
    al_init();
    al_install_keyboard();

    ALLEGRO_TIMER* timer = al_create_timer(1.0 / 30.0);
    ALLEGRO_EVENT_QUEUE* queue = al_create_event_queue();
    ALLEGRO_DISPLAY* disp = al_create_display(320, 200);
    ALLEGRO_FONT* font = al_create_builtin_font();

    al_register_event_source(queue, al_get_keyboard_event_source());
    al_register_event_source(queue, al_get_timer_event_source(timer));

    bool redraw = true;
    ALLEGRO_EVENT event;

    al_start_timer(timer);
    while(1)
    {
        al_wait_for_event(queue, &event);

        if(event.type == ALLEGRO_EVENT_TIMER)
            redraw = true;
        else if((event.type == ALLEGRO_EVENT_KEY_DOWN) || (event.type == ALLEGRO_EVENT_DISPLAY_CLOSE))
            break;

        if(redraw && al_is_event_queue_empty(queue))
        {
            al_clear_to_color(al_map_rgb(0, 0, 0));
            al_draw_text(font, al_map_rgb(255, 255, 255), 0, 0, 0, "Hello world!");
            al_flip_display();

            redraw = false;
        }
    }

    al_destroy_font(font);
    al_destroy_display(disp);
    al_destroy_timer(timer);
    al_destroy_event_queue(queue);

    return 0;
}
</file>

<file path=".gitignore">
CMakeCache.txt
CMakeFiles/
cmake-build-debug/
Makefile
cmake_install.cmake
ForbiddenDesert.v11.suo.doc
.~lock.ForbiddenDesert.v11.suo.doc#
*.cbp


## Ignore Visual Studio temporary files, build results, and
## files generated by popular Visual Studio add-ons.

#VisualStudio
*.vcxproj
*.filters
*.vcxproj.filters
*.vcxproj.user
*.sln
*.sdf
*.v11.suo
*.suo
*.user

#Ignore Folders
Debug/
.vs/

# User-specific files
*.suo
*.user
*.userosscache
*.sln.docstates

# User-specific files (MonoDevelop/Xamarin Studio)
*.userprefs

# Build results
[Dd]ebug/
[Dd]ebugPublic/
[Rr]elease/
[Rr]eleases/
x64/
x86/
bld/
[Bb]in/
[Oo]bj/
[Ll]og/

# Visual Studio 2015 cache/options directory
.vs/
# Uncomment if you have tasks that create the project's static files in wwwroot
#wwwroot/

# MSTest test Results
[Tt]est[Rr]esult*/
[Bb]uild[Ll]og.*

# NUNIT
*.VisualState.xml
TestResult.xml

# Build Results of an ATL Project
[Dd]ebugPS/
[Rr]eleasePS/
dlldata.c

# DNX
project.lock.json
artifacts/

*_i.c
*_p.c
*_i.h
*.ilk
*.meta
*.obj
*.pch
*.pdb
*.pgc
*.pgd
*.rsp
*.sbr
*.tlb
*.tli
*.tlh
*.tmp
*.tmp_proj
*.log
*.vspscc
*.vssscc
.builds
*.pidb
*.svclog
*.scc

# Chutzpah Test files
_Chutzpah*

# Visual C++ cache files
ipch/
*.aps
*.ncb
*.opendb
*.opensdf
*.sdf
*.cachefile

# Visual Studio profiler
*.psess
*.vsp
*.vspx
*.sap

# TFS 2012 Local Workspace
$tf/

# Guidance Automation Toolkit
*.gpState

# ReSharper is a .NET coding add-in
_ReSharper*/
*.[Rr]e[Ss]harper
*.DotSettings.user

# JustCode is a .NET coding add-in
.JustCode

# TeamCity is a build add-in
_TeamCity*

# DotCover is a Code Coverage Tool
*.dotCover

# NCrunch
_NCrunch_*
.*crunch*.local.xml
nCrunchTemp_*

# MightyMoose
*.mm.*
AutoTest.Net/

# Web workbench (sass)
.sass-cache/

# Installshield output folder
[Ee]xpress/

# DocProject is a documentation generator add-in
DocProject/buildhelp/
DocProject/Help/*.HxT
DocProject/Help/*.HxC
DocProject/Help/*.hhc
DocProject/Help/*.hhk
DocProject/Help/*.hhp
DocProject/Help/Html2
DocProject/Help/html

# Click-Once directory
publish/

# Publish Web Output
*.[Pp]ublish.xml
*.azurePubxml
# TODO: Comment the next line if you want to checkin your web deploy settings 
# but database connection strings (with potential passwords) will be unencrypted
*.pubxml
*.publishproj

# NuGet Packages
*.nupkg
# The packages folder can be ignored because of Package Restore
**/packages/*
# except build/, which is used as an MSBuild target.
!**/packages/build/
# Uncomment if necessary however generally it will be regenerated when needed
#!**/packages/repositories.config
# NuGet v3's project.json files produces more ignoreable files
*.nuget.props
*.nuget.targets

# Microsoft Azure Build Output
csx/
*.build.csdef

# Microsoft Azure Emulator
ecf/
rcf/

# Windows Store app package directories and files
AppPackages/
BundleArtifacts/
Package.StoreAssociation.xml
_pkginfo.txt

# Visual Studio cache files
# files ending in .cache can be ignored
*.[Cc]ache
# but keep track of directories ending in .cache
!*.[Cc]ache/

# Others
ClientBin/
~$*
*~
*.dbmdl
*.dbproj.schemaview
*.pfx
*.publishsettings
node_modules/
orleans.codegen.cs

# Since there are multiple workflows, uncomment next line to ignore bower_components 
# (https://github.com/github/gitignore/pull/1529#issuecomment-104372622)
#bower_components/

# RIA/Silverlight projects
Generated_Code/

# Backup & report files from converting an old project file
# to a newer Visual Studio version. Backup files are not needed,
# because we have git ;-)
_UpgradeReport_Files/
Backup*/
UpgradeLog*.XML
UpgradeLog*.htm

# SQL Server files
*.mdf
*.ldf

# Business Intelligence projects
*.rdl.data
*.bim.layout
*.bim_*.settings

# Microsoft Fakes
FakesAssemblies/

# GhostDoc plugin setting file
*.GhostDoc.xml

# Node.js Tools for Visual Studio
.ntvs_analysis.dat

# Visual Studio 6 build log
*.plg

# Visual Studio 6 workspace options file
*.opt

# Visual Studio LightSwitch build output
**/*.HTMLClient/GeneratedArtifacts
**/*.DesktopClient/GeneratedArtifacts
**/*.DesktopClient/ModelManifest.xml
**/*.Server/GeneratedArtifacts
**/*.Server/ModelManifest.xml
_Pvt_Extensions

# Paket dependency manager
.paket/paket.exe
paket-files/

# FAKE - F# Make
.fake/

# JetBrains Rider
.idea/
*.sln.iml

#OS junk files
[Tt]humbs.db
*.DS_Store

#Visual Studio files
*.[Oo]bj
*.user
*.aps
*.pch
*.vspscc
*.vssscc
*_i.c
*_p.c
*.ncb
*.suo
*.tlb
*.tlh
*.bak
*.[Cc]ache
*.ilk
*.log
*.lib
*.sbr
*.sdf
ipch/
obj/
[Bb]in
[Dd]ebug*/
[Rr]elease*/
Ankh.NoLoad

#Tooling
_ReSharper*/
*.resharper
[Tt]est[Rr]esult*

#Project files
[Bb]uild/

#Subversion files
.svn

# Office Temp Files
~$*
</file>

<file path="allegro.log.txt">
system   D            wsystem.c:583  maybe_parent_dir                 [   0.00069] Also searching C:\Users\NEGU\Documents\ForbiddenDesert\TPFinal\
system   D            wsystem.c:633  _al_win_safe_load_library        [   0.00097] PathFindOnPath found: C:\WINDOWS\system32\d3d9.dll
system   D            wsystem.c:544  load_library_at_path             [   0.00099] Calling LoadLibrary C:\WINDOWS\system32\d3d9.dll
system   I            wsystem.c:547  load_library_at_path             [   0.01745] Loaded C:\WINDOWS\system32\d3d9.dll
d3d      I         d3d_disp.cpp:696  _al_d3d_init_display             [   0.10422] Render-to-texture: 1
system   I             system.c:252  al_install_system                [   0.10430] Allegro version: 5.0.10
d3d      I         d3d_disp.cpp:1737 d3d_create_display_locked        [   0.10726] faux_fullscreen=0
d3d      D         d3d_disp.cpp:1738 d3d_create_display_locked        [   0.10894] al_display=00CFBFE8
d3d      D         d3d_disp.cpp:1739 d3d_create_display_locked        [   0.10898] al_display->vt=00CCA900
d3d      I d3d_display_formats.cpp:144  _al_d3d_generate_display_format_list [   0.18852] found 64 format combinations
display  D   display_settings.c:191  debug_display_settings           [   0.18857] color: 32 (rgba 8880), depth: 0, stencil: 0, acc: 0000, samples: 0/0
display  D   display_settings.c:506  _al_score_display_settings       [   0.18860] Score is : 897
display  D   display_settings.c:191  debug_display_settings           [   0.18862] color: 32 (rgba 8880), depth: 0, stencil: 0, acc: 0000, samples: 0/0
display  D   display_settings.c:506  _al_score_display_settings       [   0.18864] Score is : 897
display  D   display_settings.c:191  debug_display_settings           [   0.18865] color: 32 (rgba 8880), depth: 24, stencil: 8, acc: 0000, samples: 0/0
display  D   display_settings.c:506  _al_score_display_settings       [   0.18867] Score is : 897
display  D   display_settings.c:191  debug_display_settings           [   0.18869] color: 32 (rgba 8880), depth: 24, stencil: 8, acc: 0000, samples: 0/0
display  D   display_settings.c:506  _al_score_display_settings       [   0.18870] Score is : 897
display  D   display_settings.c:191  debug_display_settings           [   0.18872] color: 32 (rgba 8880), depth: 24, stencil: 0, acc: 0000, samples: 0/0
display  D   display_settings.c:506  _al_score_display_settings       [   0.18873] Score is : 897
display  D   display_settings.c:191  debug_display_settings           [   0.18876] color: 32 (rgba 8880), depth: 24, stencil: 0, acc: 0000, samples: 0/0
display  D   display_settings.c:506  _al_score_display_settings       [   0.18877] Score is : 897
display  D   display_settings.c:191  debug_display_settings           [   0.18879] color: 32 (rgba 8880), depth: 16, stencil: 0, acc: 0000, samples: 0/0
display  D   display_settings.c:506  _al_score_display_settings       [   0.18881] Score is : 897
display  D   display_settings.c:191  debug_display_settings           [   0.18882] color: 32 (rgba 8880), depth: 16, stencil: 0, acc: 0000, samples: 0/0
display  D   display_settings.c:506  _al_score_display_settings       [   0.18884] Score is : 897
display  D   display_settings.c:191  debug_display_settings           [   0.18885] color: 16 (rgba 5650), depth: 0, stencil: 0, acc: 0000, samples: 0/0
display  D   display_settings.c:506  _al_score_display_settings       [   0.18887] Score is : 897
display  D   display_settings.c:191  debug_display_settings           [   0.18888] color: 16 (rgba 5650), depth: 0, stencil: 0, acc: 0000, samples: 0/0
display  D   display_settings.c:506  _al_score_display_settings       [   0.18890] Score is : 897
display  D   display_settings.c:191  debug_display_settings           [   0.18892] color: 16 (rgba 5650), depth: 24, stencil: 8, acc: 0000, samples: 0/0
display  D   display_settings.c:506  _al_score_display_settings       [   0.18894] Score is : 897
display  D   display_settings.c:191  debug_display_settings           [   0.18895] color: 16 (rgba 5650), depth: 24, stencil: 8, acc: 0000, samples: 0/0
display  D   display_settings.c:506  _al_score_display_settings       [   0.18903] Score is : 897
display  D   display_settings.c:191  debug_display_settings           [   0.18905] color: 16 (rgba 5650), depth: 24, stencil: 0, acc: 0000, samples: 0/0
display  D   display_settings.c:506  _al_score_display_settings       [   0.18907] Score is : 897
display  D   display_settings.c:191  debug_display_settings           [   0.18909] color: 16 (rgba 5650), depth: 24, stencil: 0, acc: 0000, samples: 0/0
display  D   display_settings.c:506  _al_score_display_settings       [   0.18911] Score is : 897
display  D   display_settings.c:191  debug_display_settings           [   0.18912] color: 16 (rgba 5650), depth: 16, stencil: 0, acc: 0000, samples: 0/0
display  D   display_settings.c:506  _al_score_display_settings       [   0.18914] Score is : 897
display  D   display_settings.c:191  debug_display_settings           [   0.18915] color: 16 (rgba 5650), depth: 16, stencil: 0, acc: 0000, samples: 0/0
display  D   display_settings.c:506  _al_score_display_settings       [   0.18917] Score is : 897
display  D   display_settings.c:191  debug_display_settings           [   0.18919] color: 32 (rgba 8880), depth: 0, stencil: 0, acc: 0000, samples: 0/0
display  D   display_settings.c:377  _al_score_display_settings       [   0.18920] Single Buffer requirement not met.
display  D   display_settings.c:191  debug_display_settings           [   0.18922] color: 32 (rgba 8880), depth: 0, stencil: 0, acc: 0000, samples: 0/0
display  D   display_settings.c:377  _al_score_display_settings       [   0.18924] Single Buffer requirement not met.
display  D   display_settings.c:191  debug_display_settings           [   0.18925] color: 32 (rgba 8880), depth: 24, stencil: 8, acc: 0000, samples: 0/0
display  D   display_settings.c:377  _al_score_display_settings       [   0.18927] Single Buffer requirement not met.
display  D   display_settings.c:191  debug_display_settings           [   0.18929] color: 32 (rgba 8880), depth: 24, stencil: 8, acc: 0000, samples: 0/0
display  D   display_settings.c:377  _al_score_display_settings       [   0.18931] Single Buffer requirement not met.
display  D   display_settings.c:191  debug_display_settings           [   0.18932] color: 32 (rgba 8880), depth: 24, stencil: 0, acc: 0000, samples: 0/0
display  D   display_settings.c:377  _al_score_display_settings       [   0.18934] Single Buffer requirement not met.
display  D   display_settings.c:191  debug_display_settings           [   0.18935] color: 32 (rgba 8880), depth: 24, stencil: 0, acc: 0000, samples: 0/0
display  D   display_settings.c:377  _al_score_display_settings       [   0.18937] Single Buffer requirement not met.
display  D   display_settings.c:191  debug_display_settings           [   0.18939] color: 32 (rgba 8880), depth: 16, stencil: 0, acc: 0000, samples: 0/0
display  D   display_settings.c:377  _al_score_display_settings       [   0.18941] Single Buffer requirement not met.
display  D   display_settings.c:191  debug_display_settings           [   0.18942] color: 32 (rgba 8880), depth: 16, stencil: 0, acc: 0000, samples: 0/0
display  D   display_settings.c:377  _al_score_display_settings       [   0.18944] Single Buffer requirement not met.
display  D   display_settings.c:191  debug_display_settings           [   0.18946] color: 16 (rgba 5650), depth: 0, stencil: 0, acc: 0000, samples: 0/0
display  D   display_settings.c:377  _al_score_display_settings       [   0.18947] Single Buffer requirement not met.
display  D   display_settings.c:191  debug_display_settings           [   0.18949] color: 16 (rgba 5650), depth: 0, stencil: 0, acc: 0000, samples: 0/0
display  D   display_settings.c:377  _al_score_display_settings       [   0.18951] Single Buffer requirement not met.
display  D   display_settings.c:191  debug_display_settings           [   0.18953] color: 16 (rgba 5650), depth: 24, stencil: 8, acc: 0000, samples: 0/0
display  D   display_settings.c:377  _al_score_display_settings       [   0.18954] Single Buffer requirement not met.
display  D   display_settings.c:191  debug_display_settings           [   0.18956] color: 16 (rgba 5650), depth: 24, stencil: 8, acc: 0000, samples: 0/0
display  D   display_settings.c:377  _al_score_display_settings       [   0.18958] Single Buffer requirement not met.
display  D   display_settings.c:191  debug_display_settings           [   0.18960] color: 16 (rgba 5650), depth: 24, stencil: 0, acc: 0000, samples: 0/0
display  D   display_settings.c:377  _al_score_display_settings       [   0.18962] Single Buffer requirement not met.
display  D   display_settings.c:191  debug_display_settings           [   0.18963] color: 16 (rgba 5650), depth: 24, stencil: 0, acc: 0000, samples: 0/0
display  D   display_settings.c:377  _al_score_display_settings       [   0.18965] Single Buffer requirement not met.
display  D   display_settings.c:191  debug_display_settings           [   0.18966] color: 16 (rgba 5650), depth: 16, stencil: 0, acc: 0000, samples: 0/0
display  D   display_settings.c:377  _al_score_display_settings       [   0.18968] Single Buffer requirement not met.
display  D   display_settings.c:191  debug_display_settings           [   0.18970] color: 16 (rgba 5650), depth: 16, stencil: 0, acc: 0000, samples: 0/0
display  D   display_settings.c:377  _al_score_display_settings       [   0.18972] Single Buffer requirement not met.
display  D   display_settings.c:191  debug_display_settings           [   0.18973] color: 32 (rgba 8880), depth: 0, stencil: 0, acc: 0000, samples: 0/0
display  D   display_settings.c:506  _al_score_display_settings       [   0.18976] Score is : 769
display  D   display_settings.c:191  debug_display_settings           [   0.18978] color: 32 (rgba 8880), depth: 0, stencil: 0, acc: 0000, samples: 0/0
display  D   display_settings.c:506  _al_score_display_settings       [   0.18980] Score is : 769
display  D   display_settings.c:191  debug_display_settings           [   0.18981] color: 32 (rgba 8880), depth: 24, stencil: 8, acc: 0000, samples: 0/0
display  D   display_settings.c:506  _al_score_display_settings       [   0.18983] Score is : 769
display  D   display_settings.c:191  debug_display_settings           [   0.18984] color: 32 (rgba 8880), depth: 24, stencil: 8, acc: 0000, samples: 0/0
display  D   display_settings.c:506  _al_score_display_settings       [   0.18985] Score is : 769
display  D   display_settings.c:191  debug_display_settings           [   0.18987] color: 32 (rgba 8880), depth: 24, stencil: 0, acc: 0000, samples: 0/0
display  D   display_settings.c:506  _al_score_display_settings       [   0.18988] Score is : 769
display  D   display_settings.c:191  debug_display_settings           [   0.18990] color: 32 (rgba 8880), depth: 24, stencil: 0, acc: 0000, samples: 0/0
display  D   display_settings.c:506  _al_score_display_settings       [   0.18991] Score is : 769
display  D   display_settings.c:191  debug_display_settings           [   0.18992] color: 32 (rgba 8880), depth: 16, stencil: 0, acc: 0000, samples: 0/0
display  D   display_settings.c:506  _al_score_display_settings       [   0.18994] Score is : 769
display  D   display_settings.c:191  debug_display_settings           [   0.18996] color: 32 (rgba 8880), depth: 16, stencil: 0, acc: 0000, samples: 0/0
display  D   display_settings.c:506  _al_score_display_settings       [   0.18998] Score is : 769
display  D   display_settings.c:191  debug_display_settings           [   0.18999] color: 16 (rgba 5650), depth: 0, stencil: 0, acc: 0000, samples: 0/0
display  D   display_settings.c:506  _al_score_display_settings       [   0.19001] Score is : 769
display  D   display_settings.c:191  debug_display_settings           [   0.19002] color: 16 (rgba 5650), depth: 0, stencil: 0, acc: 0000, samples: 0/0
display  D   display_settings.c:506  _al_score_display_settings       [   0.19004] Score is : 769
display  D   display_settings.c:191  debug_display_settings           [   0.19005] color: 16 (rgba 5650), depth: 24, stencil: 8, acc: 0000, samples: 0/0
display  D   display_settings.c:506  _al_score_display_settings       [   0.19007] Score is : 769
display  D   display_settings.c:191  debug_display_settings           [   0.19008] color: 16 (rgba 5650), depth: 24, stencil: 8, acc: 0000, samples: 0/0
display  D   display_settings.c:506  _al_score_display_settings       [   0.19011] Score is : 769
display  D   display_settings.c:191  debug_display_settings           [   0.19012] color: 16 (rgba 5650), depth: 24, stencil: 0, acc: 0000, samples: 0/0
display  D   display_settings.c:506  _al_score_display_settings       [   0.19014] Score is : 769
display  D   display_settings.c:191  debug_display_settings           [   0.19015] color: 16 (rgba 5650), depth: 24, stencil: 0, acc: 0000, samples: 0/0
display  D   display_settings.c:506  _al_score_display_settings       [   0.19017] Score is : 769
display  D   display_settings.c:191  debug_display_settings           [   0.19018] color: 16 (rgba 5650), depth: 16, stencil: 0, acc: 0000, samples: 0/0
display  D   display_settings.c:506  _al_score_display_settings       [   0.19020] Score is : 769
display  D   display_settings.c:191  debug_display_settings           [   0.19021] color: 16 (rgba 5650), depth: 16, stencil: 0, acc: 0000, samples: 0/0
display  D   display_settings.c:506  _al_score_display_settings       [   0.19023] Score is : 769
display  D   display_settings.c:191  debug_display_settings           [   0.19024] color: 32 (rgba 8880), depth: 0, stencil: 0, acc: 0000, samples: 0/0
display  D   display_settings.c:377  _al_score_display_settings       [   0.19027] Single Buffer requirement not met.
display  D   display_settings.c:191  debug_display_settings           [   0.19028] color: 32 (rgba 8880), depth: 0, stencil: 0, acc: 0000, samples: 0/0
display  D   display_settings.c:377  _al_score_display_settings       [   0.19030] Single Buffer requirement not met.
display  D   display_settings.c:191  debug_display_settings           [   0.19031] color: 32 (rgba 8880), depth: 24, stencil: 8, acc: 0000, samples: 0/0
display  D   display_settings.c:377  _al_score_display_settings       [   0.19033] Single Buffer requirement not met.
display  D   display_settings.c:191  debug_display_settings           [   0.19035] color: 32 (rgba 8880), depth: 24, stencil: 8, acc: 0000, samples: 0/0
display  D   display_settings.c:377  _al_score_display_settings       [   0.19036] Single Buffer requirement not met.
display  D   display_settings.c:191  debug_display_settings           [   0.19038] color: 32 (rgba 8880), depth: 24, stencil: 0, acc: 0000, samples: 0/0
display  D   display_settings.c:377  _al_score_display_settings       [   0.19040] Single Buffer requirement not met.
display  D   display_settings.c:191  debug_display_settings           [   0.19042] color: 32 (rgba 8880), depth: 24, stencil: 0, acc: 0000, samples: 0/0
display  D   display_settings.c:377  _al_score_display_settings       [   0.19044] Single Buffer requirement not met.
display  D   display_settings.c:191  debug_display_settings           [   0.19045] color: 32 (rgba 8880), depth: 16, stencil: 0, acc: 0000, samples: 0/0
display  D   display_settings.c:377  _al_score_display_settings       [   0.19047] Single Buffer requirement not met.
display  D   display_settings.c:191  debug_display_settings           [   0.19048] color: 32 (rgba 8880), depth: 16, stencil: 0, acc: 0000, samples: 0/0
display  D   display_settings.c:377  _al_score_display_settings       [   0.19050] Single Buffer requirement not met.
display  D   display_settings.c:191  debug_display_settings           [   0.19052] color: 16 (rgba 5650), depth: 0, stencil: 0, acc: 0000, samples: 0/0
display  D   display_settings.c:377  _al_score_display_settings       [   0.19053] Single Buffer requirement not met.
display  D   display_settings.c:191  debug_display_settings           [   0.19055] color: 16 (rgba 5650), depth: 0, stencil: 0, acc: 0000, samples: 0/0
display  D   display_settings.c:377  _al_score_display_settings       [   0.19057] Single Buffer requirement not met.
display  D   display_settings.c:191  debug_display_settings           [   0.19058] color: 16 (rgba 5650), depth: 24, stencil: 8, acc: 0000, samples: 0/0
display  D   display_settings.c:377  _al_score_display_settings       [   0.19066] Single Buffer requirement not met.
display  D   display_settings.c:191  debug_display_settings           [   0.19068] color: 16 (rgba 5650), depth: 24, stencil: 8, acc: 0000, samples: 0/0
display  D   display_settings.c:377  _al_score_display_settings       [   0.19070] Single Buffer requirement not met.
display  D   display_settings.c:191  debug_display_settings           [   0.19071] color: 16 (rgba 5650), depth: 24, stencil: 0, acc: 0000, samples: 0/0
display  D   display_settings.c:377  _al_score_display_settings       [   0.19073] Single Buffer requirement not met.
display  D   display_settings.c:191  debug_display_settings           [   0.19075] color: 16 (rgba 5650), depth: 24, stencil: 0, acc: 0000, samples: 0/0
display  D   display_settings.c:377  _al_score_display_settings       [   0.19077] Single Buffer requirement not met.
display  D   display_settings.c:191  debug_display_settings           [   0.19078] color: 16 (rgba 5650), depth: 16, stencil: 0, acc: 0000, samples: 0/0
display  D   display_settings.c:377  _al_score_display_settings       [   0.19080] Single Buffer requirement not met.
display  D   display_settings.c:191  debug_display_settings           [   0.19082] color: 16 (rgba 5650), depth: 16, stencil: 0, acc: 0000, samples: 0/0
display  D   display_settings.c:377  _al_score_display_settings       [   0.19083] Single Buffer requirement not met.
d3d      D         d3d_disp.cpp:1645 d3d_create_display_internals     [   0.19086] Trying format 0.
d3d      I         d3d_disp.cpp:1326 d3d_display_thread_proc          [   0.19162] Chose a display format: 23
d3d      I         d3d_disp.cpp:1395 d3d_display_thread_proc          [   0.19166] Normal window.
d3d      I         d3d_disp.cpp:801  d3d_create_device                [   0.21464] Using no depth stencil buffer
d3d      D         d3d_disp.cpp:866  d3d_create_device                [   0.22151] BeginScene succeeded in create_device
d3d      D         d3d_disp.cpp:874  d3d_create_device                [   0.22155] Success
d3d      D         d3d_disp.cpp:1668 d3d_create_display_internals     [   0.22158] Resumed after wait.
d3d      I         d3d_disp.cpp:1701 d3d_create_display_internals     [   0.22161] Format 0 succeeded.
d3d      D         d3d_disp.cpp:1724 d3d_create_display_internals     [   0.22165] Returning d3d_display: 00CFBFE8
d3d      D         d3d_disp.cpp:1749 d3d_create_display_locked        [   0.22167] al_display=00CFBFE8
d3d      D         d3d_disp.cpp:1750 d3d_create_display_locked        [   0.22169] al_display->vt=00CCA900
dtor     D               dtor.c:184  _al_register_destructor          [   0.22469] added dtor for object 00C8C120, func 002856C0
dtor     D               dtor.c:184  _al_register_destructor          [   0.22474] added dtor for object 00C8C1F0, func 002856C0
dtor     D               dtor.c:184  _al_register_destructor          [   0.22478] added dtor for object 04819508, func 00285D55
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.27302] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.27306] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.27307] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.27309] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.27310] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.27312] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.27313] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.27314] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.27316] Fake format
d3d      D         d3d_disp.cpp:1174 real_choose_bitmap_format        [   0.27317] Alpha doesn't match
d3d      D         d3d_disp.cpp:1181 real_choose_bitmap_format        [   0.27319] Adapter format is 23
d3d      D         d3d_disp.cpp:1184 real_choose_bitmap_format        [   0.27321] Found a format
d3d      I         d3d_disp.cpp:2283 _al_d3d_create_bitmap            [   0.27322] Chose bitmap format 9
dtor     D               dtor.c:184  _al_register_destructor          [   0.27362] added dtor for object 04850CD0, func 0028581E
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   0.33284] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   0.33294] _al_d3d_sync_bitmap (video) ref count == 1
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.33668] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.33671] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.33673] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.33675] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.33676] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.33678] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.33679] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.33681] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.33683] Fake format
d3d      D         d3d_disp.cpp:1174 real_choose_bitmap_format        [   0.33684] Alpha doesn't match
d3d      D         d3d_disp.cpp:1181 real_choose_bitmap_format        [   0.33686] Adapter format is 23
d3d      D         d3d_disp.cpp:1184 real_choose_bitmap_format        [   0.33687] Found a format
d3d      I         d3d_disp.cpp:2283 _al_d3d_create_bitmap            [   0.33689] Chose bitmap format 9
dtor     D               dtor.c:184  _al_register_destructor          [   0.33730] added dtor for object 048FAF30, func 0028581E
dtor     D               dtor.c:214  _al_unregister_destructor        [   0.33760] removed dtor for object 04850CD0
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.34267] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.34271] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.34272] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.34274] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.34275] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.34277] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.34278] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.34279] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.34281] Fake format
d3d      D         d3d_disp.cpp:1174 real_choose_bitmap_format        [   0.34282] Alpha doesn't match
d3d      D         d3d_disp.cpp:1181 real_choose_bitmap_format        [   0.34283] Adapter format is 23
d3d      D         d3d_disp.cpp:1184 real_choose_bitmap_format        [   0.34285] Found a format
d3d      I         d3d_disp.cpp:2283 _al_d3d_create_bitmap            [   0.34287] Chose bitmap format 9
dtor     D               dtor.c:184  _al_register_destructor          [   0.34325] added dtor for object 048FEEF8, func 0028581E
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   0.35220] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   0.35225] _al_d3d_sync_bitmap (video) ref count == 1
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.35877] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.35881] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.35883] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.35884] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.35886] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.35887] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.35889] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.35890] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.35892] Fake format
d3d      D         d3d_disp.cpp:1174 real_choose_bitmap_format        [   0.35893] Alpha doesn't match
d3d      D         d3d_disp.cpp:1181 real_choose_bitmap_format        [   0.35894] Adapter format is 23
d3d      D         d3d_disp.cpp:1184 real_choose_bitmap_format        [   0.35896] Found a format
d3d      I         d3d_disp.cpp:2283 _al_d3d_create_bitmap            [   0.35897] Chose bitmap format 9
dtor     D               dtor.c:184  _al_register_destructor          [   0.35933] added dtor for object 04843CE0, func 0028581E
dtor     D               dtor.c:214  _al_unregister_destructor        [   0.35939] removed dtor for object 048FEEF8
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.36216] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.36219] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.36223] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.36226] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.36228] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.36229] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.36230] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.36232] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.36233] Fake format
d3d      D         d3d_disp.cpp:1174 real_choose_bitmap_format        [   0.36234] Alpha doesn't match
d3d      D         d3d_disp.cpp:1181 real_choose_bitmap_format        [   0.36236] Adapter format is 23
d3d      D         d3d_disp.cpp:1184 real_choose_bitmap_format        [   0.36248] Found a format
d3d      I         d3d_disp.cpp:2283 _al_d3d_create_bitmap            [   0.36250] Chose bitmap format 9
dtor     D               dtor.c:184  _al_register_destructor          [   0.36286] added dtor for object 04843DE0, func 0028581E
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   0.42330] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   0.42334] _al_d3d_sync_bitmap (video) ref count == 1
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.47432] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.47436] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.47437] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.47439] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.47440] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.47442] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.47443] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.47445] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.47446] Fake format
d3d      D         d3d_disp.cpp:1174 real_choose_bitmap_format        [   0.47447] Alpha doesn't match
d3d      D         d3d_disp.cpp:1181 real_choose_bitmap_format        [   0.47449] Adapter format is 23
d3d      D         d3d_disp.cpp:1184 real_choose_bitmap_format        [   0.47451] Found a format
d3d      I         d3d_disp.cpp:2283 _al_d3d_create_bitmap            [   0.47453] Chose bitmap format 9
dtor     D               dtor.c:184  _al_register_destructor          [   0.47494] added dtor for object 0481D700, func 0028581E
dtor     D               dtor.c:214  _al_unregister_destructor        [   0.47506] removed dtor for object 04843DE0
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.48960] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.48963] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.48964] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.48966] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.48967] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.48969] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.48970] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.48972] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.48973] Fake format
d3d      D         d3d_disp.cpp:1174 real_choose_bitmap_format        [   0.48974] Alpha doesn't match
d3d      D         d3d_disp.cpp:1181 real_choose_bitmap_format        [   0.48976] Adapter format is 23
d3d      D         d3d_disp.cpp:1184 real_choose_bitmap_format        [   0.48978] Found a format
d3d      I         d3d_disp.cpp:2283 _al_d3d_create_bitmap            [   0.48979] Chose bitmap format 9
dtor     D               dtor.c:184  _al_register_destructor          [   0.49032] added dtor for object 0484E9D8, func 0028581E
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   0.50186] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   0.50191] _al_d3d_sync_bitmap (video) ref count == 1
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.51049] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.51052] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.51054] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.51055] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.51056] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.51058] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.51059] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.51061] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.51062] Fake format
d3d      D         d3d_disp.cpp:1174 real_choose_bitmap_format        [   0.51063] Alpha doesn't match
d3d      D         d3d_disp.cpp:1181 real_choose_bitmap_format        [   0.51065] Adapter format is 23
d3d      D         d3d_disp.cpp:1184 real_choose_bitmap_format        [   0.51066] Found a format
d3d      I         d3d_disp.cpp:2283 _al_d3d_create_bitmap            [   0.51068] Chose bitmap format 9
dtor     D               dtor.c:184  _al_register_destructor          [   0.51120] added dtor for object 0484F0D8, func 0028581E
dtor     D               dtor.c:214  _al_unregister_destructor        [   0.51126] removed dtor for object 0484E9D8
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.51531] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.51534] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.51535] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.51536] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.51538] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.51546] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.51548] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.51550] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.51551] Fake format
d3d      D         d3d_disp.cpp:1174 real_choose_bitmap_format        [   0.51553] Alpha doesn't match
d3d      D         d3d_disp.cpp:1181 real_choose_bitmap_format        [   0.51554] Adapter format is 23
d3d      D         d3d_disp.cpp:1184 real_choose_bitmap_format        [   0.51556] Found a format
d3d      I         d3d_disp.cpp:2283 _al_d3d_create_bitmap            [   0.51557] Chose bitmap format 9
dtor     D               dtor.c:184  _al_register_destructor          [   0.51591] added dtor for object 0484E5D8, func 0028581E
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   0.52778] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   0.52782] _al_d3d_sync_bitmap (video) ref count == 1
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.54523] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.54526] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.54528] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.54529] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.54531] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.54532] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.54534] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.54535] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.54536] Fake format
d3d      D         d3d_disp.cpp:1174 real_choose_bitmap_format        [   0.54538] Alpha doesn't match
d3d      D         d3d_disp.cpp:1181 real_choose_bitmap_format        [   0.54539] Adapter format is 23
d3d      D         d3d_disp.cpp:1184 real_choose_bitmap_format        [   0.54541] Found a format
d3d      I         d3d_disp.cpp:2283 _al_d3d_create_bitmap            [   0.54543] Chose bitmap format 9
dtor     D               dtor.c:184  _al_register_destructor          [   0.54582] added dtor for object 0484EAD8, func 0028581E
dtor     D               dtor.c:214  _al_unregister_destructor        [   0.54588] removed dtor for object 0484E5D8
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.54922] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.54925] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.54926] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.54927] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.54929] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.54930] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.54931] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.54932] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.54933] Fake format
d3d      D         d3d_disp.cpp:1174 real_choose_bitmap_format        [   0.54935] Alpha doesn't match
d3d      D         d3d_disp.cpp:1181 real_choose_bitmap_format        [   0.54936] Adapter format is 23
d3d      D         d3d_disp.cpp:1184 real_choose_bitmap_format        [   0.54938] Found a format
d3d      I         d3d_disp.cpp:2283 _al_d3d_create_bitmap            [   0.54939] Chose bitmap format 9
dtor     D               dtor.c:184  _al_register_destructor          [   0.54993] added dtor for object 0484F8D8, func 0028581E
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   0.55844] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   0.55849] _al_d3d_sync_bitmap (video) ref count == 1
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.57072] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.57075] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.57077] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.57078] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.57080] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.57081] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.57082] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.57084] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.57085] Fake format
d3d      D         d3d_disp.cpp:1174 real_choose_bitmap_format        [   0.57086] Alpha doesn't match
d3d      D         d3d_disp.cpp:1181 real_choose_bitmap_format        [   0.57088] Adapter format is 23
d3d      D         d3d_disp.cpp:1184 real_choose_bitmap_format        [   0.57089] Found a format
d3d      I         d3d_disp.cpp:2283 _al_d3d_create_bitmap            [   0.57091] Chose bitmap format 9
dtor     D               dtor.c:184  _al_register_destructor          [   0.57129] added dtor for object 0484EFD8, func 0028581E
dtor     D               dtor.c:214  _al_unregister_destructor        [   0.57135] removed dtor for object 0484F8D8
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.57365] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.57368] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.57369] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.57371] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.57372] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.57373] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.57375] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.57376] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.57377] Fake format
d3d      D         d3d_disp.cpp:1174 real_choose_bitmap_format        [   0.57379] Alpha doesn't match
d3d      D         d3d_disp.cpp:1181 real_choose_bitmap_format        [   0.57380] Adapter format is 23
d3d      D         d3d_disp.cpp:1184 real_choose_bitmap_format        [   0.57381] Found a format
d3d      I         d3d_disp.cpp:2283 _al_d3d_create_bitmap            [   0.57383] Chose bitmap format 9
dtor     D               dtor.c:184  _al_register_destructor          [   0.57417] added dtor for object 0484E8D8, func 0028581E
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   0.58306] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   0.58311] _al_d3d_sync_bitmap (video) ref count == 1
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.59055] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.59058] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.59060] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.59062] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.59063] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.59064] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.59066] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.59068] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.59070] Fake format
d3d      D         d3d_disp.cpp:1174 real_choose_bitmap_format        [   0.59071] Alpha doesn't match
d3d      D         d3d_disp.cpp:1181 real_choose_bitmap_format        [   0.59072] Adapter format is 23
d3d      D         d3d_disp.cpp:1184 real_choose_bitmap_format        [   0.59074] Found a format
d3d      I         d3d_disp.cpp:2283 _al_d3d_create_bitmap            [   0.59075] Chose bitmap format 9
dtor     D               dtor.c:184  _al_register_destructor          [   0.59116] added dtor for object 0484E2D8, func 0028581E
dtor     D               dtor.c:214  _al_unregister_destructor        [   0.59122] removed dtor for object 0484E8D8
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.59306] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.59308] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.59310] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.59311] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.59313] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.59315] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.59317] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.59318] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.59320] Fake format
d3d      D         d3d_disp.cpp:1174 real_choose_bitmap_format        [   0.59321] Alpha doesn't match
d3d      D         d3d_disp.cpp:1181 real_choose_bitmap_format        [   0.59322] Adapter format is 23
d3d      D         d3d_disp.cpp:1184 real_choose_bitmap_format        [   0.59324] Found a format
d3d      I         d3d_disp.cpp:2283 _al_d3d_create_bitmap            [   0.59326] Chose bitmap format 9
dtor     D               dtor.c:184  _al_register_destructor          [   0.59365] added dtor for object 0484DFD8, func 0028581E
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   0.60038] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   0.60042] _al_d3d_sync_bitmap (video) ref count == 1
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.60817] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.60821] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.60822] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.60823] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.60825] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.60826] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.60828] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.60829] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.60830] Fake format
d3d      D         d3d_disp.cpp:1174 real_choose_bitmap_format        [   0.60832] Alpha doesn't match
d3d      D         d3d_disp.cpp:1181 real_choose_bitmap_format        [   0.60833] Adapter format is 23
d3d      D         d3d_disp.cpp:1184 real_choose_bitmap_format        [   0.60835] Found a format
d3d      I         d3d_disp.cpp:2283 _al_d3d_create_bitmap            [   0.60836] Chose bitmap format 9
dtor     D               dtor.c:184  _al_register_destructor          [   0.60876] added dtor for object 0484E1D8, func 0028581E
dtor     D               dtor.c:214  _al_unregister_destructor        [   0.60882] removed dtor for object 0484DFD8
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.61059] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.61062] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.61064] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.61065] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.61067] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.61068] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.61069] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.61071] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.61072] Fake format
d3d      D         d3d_disp.cpp:1174 real_choose_bitmap_format        [   0.61073] Alpha doesn't match
d3d      D         d3d_disp.cpp:1181 real_choose_bitmap_format        [   0.61075] Adapter format is 23
d3d      D         d3d_disp.cpp:1184 real_choose_bitmap_format        [   0.61076] Found a format
d3d      I         d3d_disp.cpp:2283 _al_d3d_create_bitmap            [   0.61078] Chose bitmap format 9
dtor     D               dtor.c:184  _al_register_destructor          [   0.61115] added dtor for object 0484E8D8, func 0028581E
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   0.61758] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   0.61761] _al_d3d_sync_bitmap (video) ref count == 1
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.62577] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.62580] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.62582] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.62583] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.62584] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.62586] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.62587] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.62588] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.62590] Fake format
d3d      D         d3d_disp.cpp:1174 real_choose_bitmap_format        [   0.62591] Alpha doesn't match
d3d      D         d3d_disp.cpp:1181 real_choose_bitmap_format        [   0.62592] Adapter format is 23
d3d      D         d3d_disp.cpp:1184 real_choose_bitmap_format        [   0.62594] Found a format
d3d      I         d3d_disp.cpp:2283 _al_d3d_create_bitmap            [   0.62595] Chose bitmap format 9
dtor     D               dtor.c:184  _al_register_destructor          [   0.62633] added dtor for object 0484E3D8, func 0028581E
dtor     D               dtor.c:214  _al_unregister_destructor        [   0.62639] removed dtor for object 0484E8D8
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.62824] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.62826] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.62828] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.62829] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.62831] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.62832] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.62833] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.62835] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.62836] Fake format
d3d      D         d3d_disp.cpp:1174 real_choose_bitmap_format        [   0.62837] Alpha doesn't match
d3d      D         d3d_disp.cpp:1181 real_choose_bitmap_format        [   0.62840] Adapter format is 23
d3d      D         d3d_disp.cpp:1184 real_choose_bitmap_format        [   0.62842] Found a format
d3d      I         d3d_disp.cpp:2283 _al_d3d_create_bitmap            [   0.62844] Chose bitmap format 9
dtor     D               dtor.c:184  _al_register_destructor          [   0.62884] added dtor for object 0484E6D8, func 0028581E
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   0.63519] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   0.63523] _al_d3d_sync_bitmap (video) ref count == 1
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.64126] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.64129] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.64130] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.64132] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.64133] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.64134] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.64136] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.64137] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.64138] Fake format
d3d      D         d3d_disp.cpp:1174 real_choose_bitmap_format        [   0.64140] Alpha doesn't match
d3d      D         d3d_disp.cpp:1181 real_choose_bitmap_format        [   0.64141] Adapter format is 23
d3d      D         d3d_disp.cpp:1184 real_choose_bitmap_format        [   0.64143] Found a format
d3d      I         d3d_disp.cpp:2283 _al_d3d_create_bitmap            [   0.64144] Chose bitmap format 9
dtor     D               dtor.c:184  _al_register_destructor          [   0.64184] added dtor for object 0484ECD8, func 0028581E
dtor     D               dtor.c:214  _al_unregister_destructor        [   0.64190] removed dtor for object 0484E6D8
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.64373] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.64376] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.64377] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.64379] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.64380] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.64382] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.64383] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.64385] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.64386] Fake format
d3d      D         d3d_disp.cpp:1174 real_choose_bitmap_format        [   0.64388] Alpha doesn't match
d3d      D         d3d_disp.cpp:1181 real_choose_bitmap_format        [   0.64389] Adapter format is 23
d3d      D         d3d_disp.cpp:1184 real_choose_bitmap_format        [   0.64391] Found a format
d3d      I         d3d_disp.cpp:2283 _al_d3d_create_bitmap            [   0.64392] Chose bitmap format 9
dtor     D               dtor.c:184  _al_register_destructor          [   0.64428] added dtor for object 0484F3D8, func 0028581E
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   0.65478] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   0.65482] _al_d3d_sync_bitmap (video) ref count == 1
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.66472] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.66476] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.66478] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.66480] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.66481] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.66483] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.66484] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.66485] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.66486] Fake format
d3d      D         d3d_disp.cpp:1174 real_choose_bitmap_format        [   0.66488] Alpha doesn't match
d3d      D         d3d_disp.cpp:1181 real_choose_bitmap_format        [   0.66489] Adapter format is 23
d3d      D         d3d_disp.cpp:1184 real_choose_bitmap_format        [   0.66491] Found a format
d3d      I         d3d_disp.cpp:2283 _al_d3d_create_bitmap            [   0.66492] Chose bitmap format 9
dtor     D               dtor.c:184  _al_register_destructor          [   0.66614] added dtor for object 0484F1D8, func 0028581E
dtor     D               dtor.c:214  _al_unregister_destructor        [   0.66622] removed dtor for object 0484F3D8
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.66817] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.66819] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.66821] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.66822] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.66824] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.66825] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.66827] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.66828] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.66829] Fake format
d3d      D         d3d_disp.cpp:1174 real_choose_bitmap_format        [   0.66830] Alpha doesn't match
d3d      D         d3d_disp.cpp:1181 real_choose_bitmap_format        [   0.66832] Adapter format is 23
d3d      D         d3d_disp.cpp:1184 real_choose_bitmap_format        [   0.66833] Found a format
d3d      I         d3d_disp.cpp:2283 _al_d3d_create_bitmap            [   0.66835] Chose bitmap format 9
dtor     D               dtor.c:184  _al_register_destructor          [   0.66869] added dtor for object 0484E9D8, func 0028581E
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   0.67489] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   0.67493] _al_d3d_sync_bitmap (video) ref count == 1
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.68446] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.68450] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.68451] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.68452] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.68454] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.68455] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.68457] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.68458] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.68460] Fake format
d3d      D         d3d_disp.cpp:1174 real_choose_bitmap_format        [   0.68461] Alpha doesn't match
d3d      D         d3d_disp.cpp:1181 real_choose_bitmap_format        [   0.68463] Adapter format is 23
d3d      D         d3d_disp.cpp:1184 real_choose_bitmap_format        [   0.68465] Found a format
d3d      I         d3d_disp.cpp:2283 _al_d3d_create_bitmap            [   0.68467] Chose bitmap format 9
dtor     D               dtor.c:184  _al_register_destructor          [   0.68504] added dtor for object 0484E4D8, func 0028581E
dtor     D               dtor.c:214  _al_unregister_destructor        [   0.68510] removed dtor for object 0484E9D8
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.68885] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.68888] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.68890] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.68891] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.68892] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.68894] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.68895] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.68896] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.68898] Fake format
d3d      D         d3d_disp.cpp:1174 real_choose_bitmap_format        [   0.68899] Alpha doesn't match
d3d      D         d3d_disp.cpp:1181 real_choose_bitmap_format        [   0.68900] Adapter format is 23
d3d      D         d3d_disp.cpp:1184 real_choose_bitmap_format        [   0.68902] Found a format
d3d      I         d3d_disp.cpp:2283 _al_d3d_create_bitmap            [   0.68903] Chose bitmap format 9
dtor     D               dtor.c:184  _al_register_destructor          [   0.68942] added dtor for object 0484E8D8, func 0028581E
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   0.69570] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   0.69574] _al_d3d_sync_bitmap (video) ref count == 1
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.70737] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.70740] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.70742] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.70743] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.70745] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.70746] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.70747] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.70748] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.70750] Fake format
d3d      D         d3d_disp.cpp:1174 real_choose_bitmap_format        [   0.70751] Alpha doesn't match
d3d      D         d3d_disp.cpp:1181 real_choose_bitmap_format        [   0.70752] Adapter format is 23
d3d      D         d3d_disp.cpp:1184 real_choose_bitmap_format        [   0.70754] Found a format
d3d      I         d3d_disp.cpp:2283 _al_d3d_create_bitmap            [   0.70755] Chose bitmap format 9
dtor     D               dtor.c:184  _al_register_destructor          [   0.70789] added dtor for object 0484E5D8, func 0028581E
dtor     D               dtor.c:214  _al_unregister_destructor        [   0.70795] removed dtor for object 0484E8D8
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.70984] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.70986] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.70988] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.70989] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.70991] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.70993] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.70994] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.70996] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.70997] Fake format
d3d      D         d3d_disp.cpp:1174 real_choose_bitmap_format        [   0.70998] Alpha doesn't match
d3d      D         d3d_disp.cpp:1181 real_choose_bitmap_format        [   0.71000] Adapter format is 23
d3d      D         d3d_disp.cpp:1184 real_choose_bitmap_format        [   0.71001] Found a format
d3d      I         d3d_disp.cpp:2283 _al_d3d_create_bitmap            [   0.71003] Chose bitmap format 9
dtor     D               dtor.c:184  _al_register_destructor          [   0.71040] added dtor for object 0484F2D8, func 0028581E
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   0.71705] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   0.71709] _al_d3d_sync_bitmap (video) ref count == 1
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.72243] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.72246] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.72248] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.72249] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.72250] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.72252] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.72253] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.72254] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.72256] Fake format
d3d      D         d3d_disp.cpp:1174 real_choose_bitmap_format        [   0.72257] Alpha doesn't match
d3d      D         d3d_disp.cpp:1181 real_choose_bitmap_format        [   0.72258] Adapter format is 23
d3d      D         d3d_disp.cpp:1184 real_choose_bitmap_format        [   0.72260] Found a format
d3d      I         d3d_disp.cpp:2283 _al_d3d_create_bitmap            [   0.72262] Chose bitmap format 9
dtor     D               dtor.c:184  _al_register_destructor          [   0.72301] added dtor for object 0484EBD8, func 0028581E
dtor     D               dtor.c:214  _al_unregister_destructor        [   0.72307] removed dtor for object 0484F2D8
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.72505] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.72508] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.72510] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.72511] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.72513] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.72514] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.72516] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.72517] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.72518] Fake format
d3d      D         d3d_disp.cpp:1174 real_choose_bitmap_format        [   0.72520] Alpha doesn't match
d3d      D         d3d_disp.cpp:1181 real_choose_bitmap_format        [   0.72521] Adapter format is 23
d3d      D         d3d_disp.cpp:1184 real_choose_bitmap_format        [   0.72523] Found a format
d3d      I         d3d_disp.cpp:2283 _al_d3d_create_bitmap            [   0.72524] Chose bitmap format 9
dtor     D               dtor.c:184  _al_register_destructor          [   0.72562] added dtor for object 0484DED8, func 0028581E
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   0.73386] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   0.73391] _al_d3d_sync_bitmap (video) ref count == 1
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.74174] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.74177] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.74179] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.74180] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.74181] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.74183] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.74184] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.74186] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.74187] Fake format
d3d      D         d3d_disp.cpp:1174 real_choose_bitmap_format        [   0.74188] Alpha doesn't match
d3d      D         d3d_disp.cpp:1181 real_choose_bitmap_format        [   0.74190] Adapter format is 23
d3d      D         d3d_disp.cpp:1184 real_choose_bitmap_format        [   0.74191] Found a format
d3d      I         d3d_disp.cpp:2283 _al_d3d_create_bitmap            [   0.74193] Chose bitmap format 9
dtor     D               dtor.c:184  _al_register_destructor          [   0.74231] added dtor for object 0484F7D8, func 0028581E
dtor     D               dtor.c:214  _al_unregister_destructor        [   0.74236] removed dtor for object 0484DED8
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.74399] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.74402] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.74403] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.74405] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.74406] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.74407] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.74408] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.74410] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.74411] Fake format
d3d      D         d3d_disp.cpp:1174 real_choose_bitmap_format        [   0.74413] Alpha doesn't match
d3d      D         d3d_disp.cpp:1181 real_choose_bitmap_format        [   0.74414] Adapter format is 23
d3d      D         d3d_disp.cpp:1184 real_choose_bitmap_format        [   0.74416] Found a format
d3d      I         d3d_disp.cpp:2283 _al_d3d_create_bitmap            [   0.74417] Chose bitmap format 9
dtor     D               dtor.c:184  _al_register_destructor          [   0.74945] added dtor for object 0484E9D8, func 0028581E
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   0.76967] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   0.76975] _al_d3d_sync_bitmap (video) ref count == 1
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.84764] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.84767] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.84769] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.84771] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.84773] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.84774] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.84776] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.84778] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.84779] Fake format
d3d      D         d3d_disp.cpp:1174 real_choose_bitmap_format        [   0.84781] Alpha doesn't match
d3d      D         d3d_disp.cpp:1181 real_choose_bitmap_format        [   0.84783] Adapter format is 23
d3d      D         d3d_disp.cpp:1184 real_choose_bitmap_format        [   0.84784] Found a format
d3d      I         d3d_disp.cpp:2283 _al_d3d_create_bitmap            [   0.84786] Chose bitmap format 9
dtor     D               dtor.c:184  _al_register_destructor          [   0.85125] added dtor for object 0484E6D8, func 0028581E
dtor     D               dtor.c:214  _al_unregister_destructor        [   0.85132] removed dtor for object 0484E9D8
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.87227] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.87231] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.87233] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.87235] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.87237] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.87238] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.87240] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.87241] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.87243] Fake format
d3d      D         d3d_disp.cpp:1174 real_choose_bitmap_format        [   0.87245] Alpha doesn't match
d3d      D         d3d_disp.cpp:1181 real_choose_bitmap_format        [   0.87247] Adapter format is 23
d3d      D         d3d_disp.cpp:1184 real_choose_bitmap_format        [   0.87249] Found a format
d3d      I         d3d_disp.cpp:2283 _al_d3d_create_bitmap            [   0.87250] Chose bitmap format 9
dtor     D               dtor.c:184  _al_register_destructor          [   0.87367] added dtor for object 0484F2D8, func 0028581E
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   0.89340] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   0.89343] _al_d3d_sync_bitmap (video) ref count == 1
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.91607] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.91610] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.91612] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.91613] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.91615] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.91616] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.91618] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.91619] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.91620] Fake format
d3d      D         d3d_disp.cpp:1174 real_choose_bitmap_format        [   0.91622] Alpha doesn't match
d3d      D         d3d_disp.cpp:1181 real_choose_bitmap_format        [   0.91623] Adapter format is 23
d3d      D         d3d_disp.cpp:1184 real_choose_bitmap_format        [   0.91625] Found a format
d3d      I         d3d_disp.cpp:2283 _al_d3d_create_bitmap            [   0.91626] Chose bitmap format 9
dtor     D               dtor.c:184  _al_register_destructor          [   0.91735] added dtor for object 0484E8D8, func 0028581E
dtor     D               dtor.c:214  _al_unregister_destructor        [   0.91743] removed dtor for object 0484F2D8
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.92215] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.92218] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.92220] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.92221] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.92223] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.92224] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.92225] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.92227] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.92228] Fake format
d3d      D         d3d_disp.cpp:1174 real_choose_bitmap_format        [   0.92229] Alpha doesn't match
d3d      D         d3d_disp.cpp:1181 real_choose_bitmap_format        [   0.92231] Adapter format is 23
d3d      D         d3d_disp.cpp:1184 real_choose_bitmap_format        [   0.92232] Found a format
d3d      I         d3d_disp.cpp:2283 _al_d3d_create_bitmap            [   0.92234] Chose bitmap format 9
dtor     D               dtor.c:184  _al_register_destructor          [   0.92251] added dtor for object 0484EED8, func 0028581E
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   0.92344] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   0.92347] _al_d3d_sync_bitmap (video) ref count == 1
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.92430] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.92433] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.92434] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.92436] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.92437] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.92439] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.92442] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.92444] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.92445] Fake format
d3d      D         d3d_disp.cpp:1174 real_choose_bitmap_format        [   0.92447] Alpha doesn't match
d3d      D         d3d_disp.cpp:1181 real_choose_bitmap_format        [   0.92448] Adapter format is 23
d3d      D         d3d_disp.cpp:1184 real_choose_bitmap_format        [   0.92450] Found a format
d3d      I         d3d_disp.cpp:2283 _al_d3d_create_bitmap            [   0.92451] Chose bitmap format 9
dtor     D               dtor.c:184  _al_register_destructor          [   0.92465] added dtor for object 0484E9D8, func 0028581E
dtor     D               dtor.c:214  _al_unregister_destructor        [   0.92470] removed dtor for object 0484EED8
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.92549] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.92552] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.92554] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.92555] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.92557] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.92559] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.92560] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.92562] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.92564] Fake format
d3d      D         d3d_disp.cpp:1174 real_choose_bitmap_format        [   0.92565] Alpha doesn't match
d3d      D         d3d_disp.cpp:1181 real_choose_bitmap_format        [   0.92568] Adapter format is 23
d3d      D         d3d_disp.cpp:1184 real_choose_bitmap_format        [   0.92570] Found a format
d3d      I         d3d_disp.cpp:2283 _al_d3d_create_bitmap            [   0.92571] Chose bitmap format 9
dtor     D               dtor.c:184  _al_register_destructor          [   0.92597] added dtor for object 0484EDD8, func 0028581E
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   0.92656] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   0.92659] _al_d3d_sync_bitmap (video) ref count == 1
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.92861] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.92864] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.92865] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.92867] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.92868] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.92869] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.92871] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.92872] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.92873] Fake format
d3d      D         d3d_disp.cpp:1174 real_choose_bitmap_format        [   0.92877] Alpha doesn't match
d3d      D         d3d_disp.cpp:1181 real_choose_bitmap_format        [   0.92879] Adapter format is 23
d3d      D         d3d_disp.cpp:1184 real_choose_bitmap_format        [   0.92880] Found a format
d3d      I         d3d_disp.cpp:2283 _al_d3d_create_bitmap            [   0.92882] Chose bitmap format 9
dtor     D               dtor.c:184  _al_register_destructor          [   0.92904] added dtor for object 0484EED8, func 0028581E
dtor     D               dtor.c:214  _al_unregister_destructor        [   0.92910] removed dtor for object 0484EDD8
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.92965] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.92968] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.92969] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.92970] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.92972] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.92973] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.92975] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.92976] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.92977] Fake format
d3d      D         d3d_disp.cpp:1174 real_choose_bitmap_format        [   0.92979] Alpha doesn't match
d3d      D         d3d_disp.cpp:1181 real_choose_bitmap_format        [   0.92980] Adapter format is 23
d3d      D         d3d_disp.cpp:1184 real_choose_bitmap_format        [   0.92982] Found a format
d3d      I         d3d_disp.cpp:2283 _al_d3d_create_bitmap            [   0.92983] Chose bitmap format 9
dtor     D               dtor.c:184  _al_register_destructor          [   0.92996] added dtor for object 0484F8D8, func 0028581E
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   0.93044] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   0.93046] _al_d3d_sync_bitmap (video) ref count == 1
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.93278] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.93281] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.93284] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.93286] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.93287] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.93288] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.93290] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.93291] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.93292] Fake format
d3d      D         d3d_disp.cpp:1174 real_choose_bitmap_format        [   0.93294] Alpha doesn't match
d3d      D         d3d_disp.cpp:1181 real_choose_bitmap_format        [   0.93295] Adapter format is 23
d3d      D         d3d_disp.cpp:1184 real_choose_bitmap_format        [   0.93297] Found a format
d3d      I         d3d_disp.cpp:2283 _al_d3d_create_bitmap            [   0.93298] Chose bitmap format 9
dtor     D               dtor.c:184  _al_register_destructor          [   0.93313] added dtor for object 0484DAD8, func 0028581E
dtor     D               dtor.c:214  _al_unregister_destructor        [   0.93319] removed dtor for object 0484F8D8
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.93752] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.93755] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.93756] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.93758] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.93759] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.93760] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.93762] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.93763] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.93764] Fake format
d3d      D         d3d_disp.cpp:1174 real_choose_bitmap_format        [   0.93766] Alpha doesn't match
d3d      D         d3d_disp.cpp:1181 real_choose_bitmap_format        [   0.93767] Adapter format is 23
d3d      D         d3d_disp.cpp:1184 real_choose_bitmap_format        [   0.93769] Found a format
d3d      I         d3d_disp.cpp:2283 _al_d3d_create_bitmap            [   0.93770] Chose bitmap format 9
dtor     D               dtor.c:184  _al_register_destructor          [   0.93835] added dtor for object 0484F2D8, func 0028581E
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   0.93896] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   0.93899] _al_d3d_sync_bitmap (video) ref count == 1
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.94015] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.94018] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.94019] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.94020] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.94022] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.94023] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.94024] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.94026] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.94027] Fake format
d3d      D         d3d_disp.cpp:1174 real_choose_bitmap_format        [   0.94029] Alpha doesn't match
d3d      D         d3d_disp.cpp:1181 real_choose_bitmap_format        [   0.94030] Adapter format is 23
d3d      D         d3d_disp.cpp:1184 real_choose_bitmap_format        [   0.94032] Found a format
d3d      I         d3d_disp.cpp:2283 _al_d3d_create_bitmap            [   0.94034] Chose bitmap format 9
dtor     D               dtor.c:184  _al_register_destructor          [   0.94051] added dtor for object 0484EDD8, func 0028581E
dtor     D               dtor.c:214  _al_unregister_destructor        [   0.94061] removed dtor for object 0484F2D8
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.94135] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.94137] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.94138] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.94140] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.94141] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.94142] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.94144] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.94145] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.94146] Fake format
d3d      D         d3d_disp.cpp:1174 real_choose_bitmap_format        [   0.94148] Alpha doesn't match
d3d      D         d3d_disp.cpp:1181 real_choose_bitmap_format        [   0.94149] Adapter format is 23
d3d      D         d3d_disp.cpp:1184 real_choose_bitmap_format        [   0.94150] Found a format
d3d      I         d3d_disp.cpp:2283 _al_d3d_create_bitmap            [   0.94152] Chose bitmap format 9
dtor     D               dtor.c:184  _al_register_destructor          [   0.94163] added dtor for object 0484F2D8, func 0028581E
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   0.94233] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   0.94235] _al_d3d_sync_bitmap (video) ref count == 1
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.94460] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.94463] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.94464] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.94465] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.94602] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.94605] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.94606] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.94608] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.94609] Fake format
d3d      D         d3d_disp.cpp:1174 real_choose_bitmap_format        [   0.94611] Alpha doesn't match
d3d      D         d3d_disp.cpp:1181 real_choose_bitmap_format        [   0.94612] Adapter format is 23
d3d      D         d3d_disp.cpp:1184 real_choose_bitmap_format        [   0.94614] Found a format
d3d      I         d3d_disp.cpp:2283 _al_d3d_create_bitmap            [   0.94615] Chose bitmap format 9
dtor     D               dtor.c:184  _al_register_destructor          [   0.94632] added dtor for object 0484DBD8, func 0028581E
dtor     D               dtor.c:214  _al_unregister_destructor        [   0.94638] removed dtor for object 0484F2D8
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.95042] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.95045] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.95046] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.95048] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.95049] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.95051] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.95052] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.95054] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.95055] Fake format
d3d      D         d3d_disp.cpp:1174 real_choose_bitmap_format        [   0.95056] Alpha doesn't match
d3d      D         d3d_disp.cpp:1181 real_choose_bitmap_format        [   0.95058] Adapter format is 23
d3d      D         d3d_disp.cpp:1184 real_choose_bitmap_format        [   0.95059] Found a format
d3d      I         d3d_disp.cpp:2283 _al_d3d_create_bitmap            [   0.95061] Chose bitmap format 9
dtor     D               dtor.c:184  _al_register_destructor          [   0.95073] added dtor for object 0484F8D8, func 0028581E
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   0.95134] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   0.95136] _al_d3d_sync_bitmap (video) ref count == 1
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.95312] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.95315] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.95317] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.95318] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.95319] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.95321] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.95322] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.95323] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.95325] Fake format
d3d      D         d3d_disp.cpp:1174 real_choose_bitmap_format        [   0.95326] Alpha doesn't match
d3d      D         d3d_disp.cpp:1181 real_choose_bitmap_format        [   0.95328] Adapter format is 23
d3d      D         d3d_disp.cpp:1184 real_choose_bitmap_format        [   0.95329] Found a format
d3d      I         d3d_disp.cpp:2283 _al_d3d_create_bitmap            [   0.95331] Chose bitmap format 9
dtor     D               dtor.c:184  _al_register_destructor          [   0.95346] added dtor for object 0484F2D8, func 0028581E
dtor     D               dtor.c:214  _al_unregister_destructor        [   0.95351] removed dtor for object 0484F8D8
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.95414] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.95416] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.95417] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.95419] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.95420] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.95421] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.95423] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.95424] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.95427] Fake format
d3d      D         d3d_disp.cpp:1174 real_choose_bitmap_format        [   0.95428] Alpha doesn't match
d3d      D         d3d_disp.cpp:1181 real_choose_bitmap_format        [   0.95430] Adapter format is 23
d3d      D         d3d_disp.cpp:1184 real_choose_bitmap_format        [   0.95431] Found a format
d3d      I         d3d_disp.cpp:2283 _al_d3d_create_bitmap            [   0.95432] Chose bitmap format 9
dtor     D               dtor.c:184  _al_register_destructor          [   0.95441] added dtor for object 0484F3D8, func 0028581E
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   0.95493] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   0.95495] _al_d3d_sync_bitmap (video) ref count == 1
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.95594] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.95596] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.95598] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.95599] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.95600] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.95602] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.95603] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.95604] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.95606] Fake format
d3d      D         d3d_disp.cpp:1174 real_choose_bitmap_format        [   0.95607] Alpha doesn't match
d3d      D         d3d_disp.cpp:1181 real_choose_bitmap_format        [   0.95608] Adapter format is 23
d3d      D         d3d_disp.cpp:1184 real_choose_bitmap_format        [   0.95610] Found a format
d3d      I         d3d_disp.cpp:2283 _al_d3d_create_bitmap            [   0.95611] Chose bitmap format 9
dtor     D               dtor.c:184  _al_register_destructor          [   0.95626] added dtor for object 0484F4D8, func 0028581E
dtor     D               dtor.c:214  _al_unregister_destructor        [   0.95631] removed dtor for object 0484F3D8
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.95684] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.95686] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.95688] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.95689] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.95690] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.95692] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.95693] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.95694] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.95696] Fake format
d3d      D         d3d_disp.cpp:1174 real_choose_bitmap_format        [   0.95697] Alpha doesn't match
d3d      D         d3d_disp.cpp:1181 real_choose_bitmap_format        [   0.95699] Adapter format is 23
d3d      D         d3d_disp.cpp:1184 real_choose_bitmap_format        [   0.95700] Found a format
d3d      I         d3d_disp.cpp:2283 _al_d3d_create_bitmap            [   0.95701] Chose bitmap format 9
dtor     D               dtor.c:184  _al_register_destructor          [   0.95711] added dtor for object 0484F3D8, func 0028581E
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   0.95760] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   0.95762] _al_d3d_sync_bitmap (video) ref count == 1
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.95828] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.95830] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.95832] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.95835] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.95836] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.95837] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.95839] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.95841] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.95842] Fake format
d3d      D         d3d_disp.cpp:1174 real_choose_bitmap_format        [   0.95843] Alpha doesn't match
d3d      D         d3d_disp.cpp:1181 real_choose_bitmap_format        [   0.95845] Adapter format is 23
d3d      D         d3d_disp.cpp:1184 real_choose_bitmap_format        [   0.95846] Found a format
d3d      I         d3d_disp.cpp:2283 _al_d3d_create_bitmap            [   0.95848] Chose bitmap format 9
dtor     D               dtor.c:184  _al_register_destructor          [   0.95861] added dtor for object 0484DED8, func 0028581E
dtor     D               dtor.c:214  _al_unregister_destructor        [   0.95866] removed dtor for object 0484F3D8
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.95922] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.95924] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.95925] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.95928] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.95930] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.95931] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.95933] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.95934] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.95935] Fake format
d3d      D         d3d_disp.cpp:1174 real_choose_bitmap_format        [   0.95937] Alpha doesn't match
d3d      D         d3d_disp.cpp:1181 real_choose_bitmap_format        [   0.95938] Adapter format is 23
d3d      D         d3d_disp.cpp:1184 real_choose_bitmap_format        [   0.95940] Found a format
d3d      I         d3d_disp.cpp:2283 _al_d3d_create_bitmap            [   0.95941] Chose bitmap format 9
dtor     D               dtor.c:184  _al_register_destructor          [   0.95951] added dtor for object 0484F3D8, func 0028581E
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   0.95996] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   0.95998] _al_d3d_sync_bitmap (video) ref count == 1
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.96146] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.96149] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.96151] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.96152] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.96154] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.96155] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.96157] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.96158] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.96160] Fake format
d3d      D         d3d_disp.cpp:1174 real_choose_bitmap_format        [   0.96162] Alpha doesn't match
d3d      D         d3d_disp.cpp:1181 real_choose_bitmap_format        [   0.96163] Adapter format is 23
d3d      D         d3d_disp.cpp:1184 real_choose_bitmap_format        [   0.96165] Found a format
d3d      I         d3d_disp.cpp:2283 _al_d3d_create_bitmap            [   0.96166] Chose bitmap format 9
dtor     D               dtor.c:184  _al_register_destructor          [   0.96181] added dtor for object 0484F5D8, func 0028581E
dtor     D               dtor.c:214  _al_unregister_destructor        [   0.96187] removed dtor for object 0484F3D8
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.96257] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.96259] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.96260] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.96262] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.96263] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.96264] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.96266] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.96267] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.96268] Fake format
d3d      D         d3d_disp.cpp:1174 real_choose_bitmap_format        [   0.96269] Alpha doesn't match
d3d      D         d3d_disp.cpp:1181 real_choose_bitmap_format        [   0.96271] Adapter format is 23
d3d      D         d3d_disp.cpp:1184 real_choose_bitmap_format        [   0.96272] Found a format
d3d      I         d3d_disp.cpp:2283 _al_d3d_create_bitmap            [   0.96274] Chose bitmap format 9
dtor     D               dtor.c:184  _al_register_destructor          [   0.96290] added dtor for object 0484F3D8, func 0028581E
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   0.96618] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   0.96622] _al_d3d_sync_bitmap (video) ref count == 1
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.97068] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.97071] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.97072] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.97074] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.97075] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.97077] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.97078] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.97079] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.97081] Fake format
d3d      D         d3d_disp.cpp:1174 real_choose_bitmap_format        [   0.97082] Alpha doesn't match
d3d      D         d3d_disp.cpp:1181 real_choose_bitmap_format        [   0.97083] Adapter format is 23
d3d      D         d3d_disp.cpp:1184 real_choose_bitmap_format        [   0.97085] Found a format
d3d      I         d3d_disp.cpp:2283 _al_d3d_create_bitmap            [   0.97086] Chose bitmap format 9
dtor     D               dtor.c:184  _al_register_destructor          [   0.97103] added dtor for object 0484F6D8, func 0028581E
dtor     D               dtor.c:214  _al_unregister_destructor        [   0.97108] removed dtor for object 0484F3D8
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.97164] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.97166] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.97168] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.97169] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.97170] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.97172] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.97173] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.97175] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.97176] Fake format
d3d      D         d3d_disp.cpp:1174 real_choose_bitmap_format        [   0.97178] Alpha doesn't match
d3d      D         d3d_disp.cpp:1181 real_choose_bitmap_format        [   0.97180] Adapter format is 23
d3d      D         d3d_disp.cpp:1184 real_choose_bitmap_format        [   0.97182] Found a format
d3d      I         d3d_disp.cpp:2283 _al_d3d_create_bitmap            [   0.97183] Chose bitmap format 9
dtor     D               dtor.c:184  _al_register_destructor          [   0.97194] added dtor for object 0484F3D8, func 0028581E
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   0.97251] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   0.97253] _al_d3d_sync_bitmap (video) ref count == 1
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.97331] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.97333] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.97335] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.97336] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.97337] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.97339] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.97340] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.97341] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.97343] Fake format
d3d      D         d3d_disp.cpp:1174 real_choose_bitmap_format        [   0.97344] Alpha doesn't match
d3d      D         d3d_disp.cpp:1181 real_choose_bitmap_format        [   0.97345] Adapter format is 23
d3d      D         d3d_disp.cpp:1184 real_choose_bitmap_format        [   0.97347] Found a format
d3d      I         d3d_disp.cpp:2283 _al_d3d_create_bitmap            [   0.97348] Chose bitmap format 9
dtor     D               dtor.c:184  _al_register_destructor          [   0.97362] added dtor for object 0484F8D8, func 0028581E
dtor     D               dtor.c:214  _al_unregister_destructor        [   0.97367] removed dtor for object 0484F3D8
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.97416] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.97418] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.97419] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.97421] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.97422] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.97423] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.97425] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.97426] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.97427] Fake format
d3d      D         d3d_disp.cpp:1174 real_choose_bitmap_format        [   0.97429] Alpha doesn't match
d3d      D         d3d_disp.cpp:1181 real_choose_bitmap_format        [   0.97430] Adapter format is 23
d3d      D         d3d_disp.cpp:1184 real_choose_bitmap_format        [   0.97432] Found a format
d3d      I         d3d_disp.cpp:2283 _al_d3d_create_bitmap            [   0.97433] Chose bitmap format 9
dtor     D               dtor.c:184  _al_register_destructor          [   0.97443] added dtor for object 0484DCD8, func 0028581E
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   0.97489] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   0.97492] _al_d3d_sync_bitmap (video) ref count == 1
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.97564] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.97567] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.97569] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.97570] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.97572] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.97573] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.97574] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.97576] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.97577] Fake format
d3d      D         d3d_disp.cpp:1174 real_choose_bitmap_format        [   0.97593] Alpha doesn't match
d3d      D         d3d_disp.cpp:1181 real_choose_bitmap_format        [   0.97594] Adapter format is 23
d3d      D         d3d_disp.cpp:1184 real_choose_bitmap_format        [   0.97596] Found a format
d3d      I         d3d_disp.cpp:2283 _al_d3d_create_bitmap            [   0.97597] Chose bitmap format 9
dtor     D               dtor.c:184  _al_register_destructor          [   0.97613] added dtor for object 0484F3D8, func 0028581E
dtor     D               dtor.c:214  _al_unregister_destructor        [   0.97619] removed dtor for object 0484DCD8
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.97675] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.97678] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.97680] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.97681] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.97682] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.97684] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.97685] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.97686] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.97687] Fake format
d3d      D         d3d_disp.cpp:1174 real_choose_bitmap_format        [   0.97689] Alpha doesn't match
d3d      D         d3d_disp.cpp:1181 real_choose_bitmap_format        [   0.97690] Adapter format is 23
d3d      D         d3d_disp.cpp:1184 real_choose_bitmap_format        [   0.97692] Found a format
d3d      I         d3d_disp.cpp:2283 _al_d3d_create_bitmap            [   0.97693] Chose bitmap format 9
dtor     D               dtor.c:184  _al_register_destructor          [   0.97720] added dtor for object 0484DCD8, func 0028581E
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   0.97921] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   0.97924] _al_d3d_sync_bitmap (video) ref count == 1
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.98331] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.98334] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.98335] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.98337] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.98338] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.98339] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.98341] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.98342] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.98344] Fake format
d3d      D         d3d_disp.cpp:1174 real_choose_bitmap_format        [   0.98345] Alpha doesn't match
d3d      D         d3d_disp.cpp:1181 real_choose_bitmap_format        [   0.98347] Adapter format is 23
d3d      D         d3d_disp.cpp:1184 real_choose_bitmap_format        [   0.98349] Found a format
d3d      I         d3d_disp.cpp:2283 _al_d3d_create_bitmap            [   0.98350] Chose bitmap format 9
dtor     D               dtor.c:184  _al_register_destructor          [   0.98386] added dtor for object 0484DDD8, func 0028581E
dtor     D               dtor.c:214  _al_unregister_destructor        [   0.98392] removed dtor for object 0484DCD8
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.98505] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.98508] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.98510] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.98511] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.98513] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.98514] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.98515] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.98517] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.98518] Fake format
d3d      D         d3d_disp.cpp:1174 real_choose_bitmap_format        [   0.98520] Alpha doesn't match
d3d      D         d3d_disp.cpp:1181 real_choose_bitmap_format        [   0.98521] Adapter format is 23
d3d      D         d3d_disp.cpp:1184 real_choose_bitmap_format        [   0.98523] Found a format
d3d      I         d3d_disp.cpp:2283 _al_d3d_create_bitmap            [   0.98524] Chose bitmap format 9
dtor     D               dtor.c:184  _al_register_destructor          [   0.98554] added dtor for object 0484DCD8, func 0028581E
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   0.98841] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   0.98844] _al_d3d_sync_bitmap (video) ref count == 1
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.99107] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.99110] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.99111] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.99113] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.99114] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.99115] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.99117] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.99118] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.99119] Fake format
d3d      D         d3d_disp.cpp:1174 real_choose_bitmap_format        [   0.99120] Alpha doesn't match
d3d      D         d3d_disp.cpp:1181 real_choose_bitmap_format        [   0.99122] Adapter format is 23
d3d      D         d3d_disp.cpp:1184 real_choose_bitmap_format        [   0.99123] Found a format
d3d      I         d3d_disp.cpp:2283 _al_d3d_create_bitmap            [   0.99125] Chose bitmap format 9
dtor     D               dtor.c:184  _al_register_destructor          [   0.99155] added dtor for object 0484DFD8, func 0028581E
dtor     D               dtor.c:214  _al_unregister_destructor        [   0.99160] removed dtor for object 0484DCD8
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.99246] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.99248] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.99249] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.99251] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.99252] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.99254] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.99255] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.99256] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.99258] Fake format
d3d      D         d3d_disp.cpp:1174 real_choose_bitmap_format        [   0.99259] Alpha doesn't match
d3d      D         d3d_disp.cpp:1181 real_choose_bitmap_format        [   0.99260] Adapter format is 23
d3d      D         d3d_disp.cpp:1184 real_choose_bitmap_format        [   0.99262] Found a format
d3d      I         d3d_disp.cpp:2283 _al_d3d_create_bitmap            [   0.99263] Chose bitmap format 9
dtor     D               dtor.c:184  _al_register_destructor          [   0.99307] added dtor for object 0484DCD8, func 0028581E
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   0.99586] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   0.99589] _al_d3d_sync_bitmap (video) ref count == 1
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.99866] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.99870] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.99871] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.99873] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.99874] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.99876] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.99877] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.99878] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   0.99880] Fake format
d3d      D         d3d_disp.cpp:1174 real_choose_bitmap_format        [   0.99881] Alpha doesn't match
d3d      D         d3d_disp.cpp:1181 real_choose_bitmap_format        [   0.99883] Adapter format is 23
d3d      D         d3d_disp.cpp:1184 real_choose_bitmap_format        [   0.99884] Found a format
d3d      I         d3d_disp.cpp:2283 _al_d3d_create_bitmap            [   0.99886] Chose bitmap format 9
dtor     D               dtor.c:184  _al_register_destructor          [   0.99912] added dtor for object 04865A38, func 0028581E
dtor     D               dtor.c:214  _al_unregister_destructor        [   0.99918] removed dtor for object 0484DCD8
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.00010] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.00012] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.00014] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.00015] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.00017] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.00018] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.00019] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.00021] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.00022] Fake format
d3d      D         d3d_disp.cpp:1174 real_choose_bitmap_format        [   1.00023] Alpha doesn't match
d3d      D         d3d_disp.cpp:1181 real_choose_bitmap_format        [   1.00025] Adapter format is 23
d3d      D         d3d_disp.cpp:1184 real_choose_bitmap_format        [   1.00027] Found a format
d3d      I         d3d_disp.cpp:2283 _al_d3d_create_bitmap            [   1.00028] Chose bitmap format 9
dtor     D               dtor.c:184  _al_register_destructor          [   1.00056] added dtor for object 04865538, func 0028581E
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   1.00336] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   1.00339] _al_d3d_sync_bitmap (video) ref count == 1
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.00599] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.00602] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.00603] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.00605] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.00606] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.00607] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.00609] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.00610] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.00612] Fake format
d3d      D         d3d_disp.cpp:1174 real_choose_bitmap_format        [   1.00613] Alpha doesn't match
d3d      D         d3d_disp.cpp:1181 real_choose_bitmap_format        [   1.00614] Adapter format is 23
d3d      D         d3d_disp.cpp:1184 real_choose_bitmap_format        [   1.00616] Found a format
d3d      I         d3d_disp.cpp:2283 _al_d3d_create_bitmap            [   1.00618] Chose bitmap format 9
dtor     D               dtor.c:184  _al_register_destructor          [   1.00650] added dtor for object 04864738, func 0028581E
dtor     D               dtor.c:214  _al_unregister_destructor        [   1.00655] removed dtor for object 04865538
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.00748] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.00750] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.00752] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.00753] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.00754] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.00756] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.00757] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.00759] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.00760] Fake format
d3d      D         d3d_disp.cpp:1174 real_choose_bitmap_format        [   1.00761] Alpha doesn't match
d3d      D         d3d_disp.cpp:1181 real_choose_bitmap_format        [   1.00763] Adapter format is 23
d3d      D         d3d_disp.cpp:1184 real_choose_bitmap_format        [   1.00764] Found a format
d3d      I         d3d_disp.cpp:2283 _al_d3d_create_bitmap            [   1.00766] Chose bitmap format 9
dtor     D               dtor.c:184  _al_register_destructor          [   1.00793] added dtor for object 04865338, func 0028581E
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   1.01083] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   1.01126] _al_d3d_sync_bitmap (video) ref count == 1
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.01385] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.01388] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.01390] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.01392] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.01393] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.01394] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.01396] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.01399] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.01400] Fake format
d3d      D         d3d_disp.cpp:1174 real_choose_bitmap_format        [   1.01402] Alpha doesn't match
d3d      D         d3d_disp.cpp:1181 real_choose_bitmap_format        [   1.01403] Adapter format is 23
d3d      D         d3d_disp.cpp:1184 real_choose_bitmap_format        [   1.01405] Found a format
d3d      I         d3d_disp.cpp:2283 _al_d3d_create_bitmap            [   1.01406] Chose bitmap format 9
dtor     D               dtor.c:184  _al_register_destructor          [   1.01432] added dtor for object 04864838, func 0028581E
dtor     D               dtor.c:214  _al_unregister_destructor        [   1.01441] removed dtor for object 04865338
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.01550] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.01553] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.01554] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.01556] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.01557] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.01559] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.01560] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.01562] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.01563] Fake format
d3d      D         d3d_disp.cpp:1174 real_choose_bitmap_format        [   1.01565] Alpha doesn't match
d3d      D         d3d_disp.cpp:1181 real_choose_bitmap_format        [   1.01566] Adapter format is 23
d3d      D         d3d_disp.cpp:1184 real_choose_bitmap_format        [   1.01568] Found a format
d3d      I         d3d_disp.cpp:2283 _al_d3d_create_bitmap            [   1.01570] Chose bitmap format 9
dtor     D               dtor.c:184  _al_register_destructor          [   1.01604] added dtor for object 04865238, func 0028581E
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   1.01867] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   1.01870] _al_d3d_sync_bitmap (video) ref count == 1
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.02140] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.02143] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.02145] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.02146] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.02147] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.02149] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.02150] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.02152] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.02153] Fake format
d3d      D         d3d_disp.cpp:1174 real_choose_bitmap_format        [   1.02155] Alpha doesn't match
d3d      D         d3d_disp.cpp:1181 real_choose_bitmap_format        [   1.02156] Adapter format is 23
d3d      D         d3d_disp.cpp:1184 real_choose_bitmap_format        [   1.02158] Found a format
d3d      I         d3d_disp.cpp:2283 _al_d3d_create_bitmap            [   1.02159] Chose bitmap format 9
dtor     D               dtor.c:184  _al_register_destructor          [   1.02189] added dtor for object 04864238, func 0028581E
dtor     D               dtor.c:214  _al_unregister_destructor        [   1.02194] removed dtor for object 04865238
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.02291] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.02294] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.02296] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.02297] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.02299] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.02300] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.02302] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.02303] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.02304] Fake format
d3d      D         d3d_disp.cpp:1174 real_choose_bitmap_format        [   1.02306] Alpha doesn't match
d3d      D         d3d_disp.cpp:1181 real_choose_bitmap_format        [   1.02307] Adapter format is 23
d3d      D         d3d_disp.cpp:1184 real_choose_bitmap_format        [   1.02309] Found a format
d3d      I         d3d_disp.cpp:2283 _al_d3d_create_bitmap            [   1.02310] Chose bitmap format 9
dtor     D               dtor.c:184  _al_register_destructor          [   1.02323] added dtor for object 04864A38, func 0028581E
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   1.02352] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   1.02354] _al_d3d_sync_bitmap (video) ref count == 1
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.02392] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.02395] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.02396] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.02398] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.02399] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.02400] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.02402] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.02403] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.02405] Fake format
d3d      D         d3d_disp.cpp:1174 real_choose_bitmap_format        [   1.02406] Alpha doesn't match
d3d      D         d3d_disp.cpp:1181 real_choose_bitmap_format        [   1.02408] Adapter format is 23
d3d      D         d3d_disp.cpp:1184 real_choose_bitmap_format        [   1.02409] Found a format
d3d      I         d3d_disp.cpp:2283 _al_d3d_create_bitmap            [   1.02411] Chose bitmap format 9
dtor     D               dtor.c:184  _al_register_destructor          [   1.02420] added dtor for object 04864938, func 0028581E
dtor     D               dtor.c:214  _al_unregister_destructor        [   1.02425] removed dtor for object 04864A38
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.02470] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.02472] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.02474] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.02476] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.02477] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.02479] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.02481] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.02482] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.02484] Fake format
d3d      D         d3d_disp.cpp:1174 real_choose_bitmap_format        [   1.02487] Alpha doesn't match
d3d      D         d3d_disp.cpp:1181 real_choose_bitmap_format        [   1.02489] Adapter format is 23
d3d      D         d3d_disp.cpp:1184 real_choose_bitmap_format        [   1.02491] Found a format
d3d      I         d3d_disp.cpp:2283 _al_d3d_create_bitmap            [   1.02493] Chose bitmap format 9
dtor     D               dtor.c:184  _al_register_destructor          [   1.02506] added dtor for object 04865238, func 0028581E
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   1.02539] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   1.02542] _al_d3d_sync_bitmap (video) ref count == 1
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.02573] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.02575] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.02577] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.02578] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.02580] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.02581] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.02583] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.02585] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.02586] Fake format
d3d      D         d3d_disp.cpp:1174 real_choose_bitmap_format        [   1.02588] Alpha doesn't match
d3d      D         d3d_disp.cpp:1181 real_choose_bitmap_format        [   1.02589] Adapter format is 23
d3d      D         d3d_disp.cpp:1184 real_choose_bitmap_format        [   1.02591] Found a format
d3d      I         d3d_disp.cpp:2283 _al_d3d_create_bitmap            [   1.02592] Chose bitmap format 9
dtor     D               dtor.c:184  _al_register_destructor          [   1.02604] added dtor for object 04865038, func 0028581E
dtor     D               dtor.c:214  _al_unregister_destructor        [   1.02610] removed dtor for object 04865238
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.02659] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.02661] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.02662] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.02664] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.02665] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.02667] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.02668] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.02669] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.02671] Fake format
d3d      D         d3d_disp.cpp:1174 real_choose_bitmap_format        [   1.02672] Alpha doesn't match
d3d      D         d3d_disp.cpp:1181 real_choose_bitmap_format        [   1.02674] Adapter format is 23
d3d      D         d3d_disp.cpp:1184 real_choose_bitmap_format        [   1.02675] Found a format
d3d      I         d3d_disp.cpp:2283 _al_d3d_create_bitmap            [   1.02677] Chose bitmap format 9
dtor     D               dtor.c:184  _al_register_destructor          [   1.02686] added dtor for object 04864338, func 0028581E
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   1.02709] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   1.02711] _al_d3d_sync_bitmap (video) ref count == 1
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.02740] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.02742] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.02745] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.02747] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.02749] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.02750] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.02752] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.02754] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.02755] Fake format
d3d      D         d3d_disp.cpp:1174 real_choose_bitmap_format        [   1.02756] Alpha doesn't match
d3d      D         d3d_disp.cpp:1181 real_choose_bitmap_format        [   1.02758] Adapter format is 23
d3d      D         d3d_disp.cpp:1184 real_choose_bitmap_format        [   1.02760] Found a format
d3d      I         d3d_disp.cpp:2283 _al_d3d_create_bitmap            [   1.02761] Chose bitmap format 9
dtor     D               dtor.c:184  _al_register_destructor          [   1.02770] added dtor for object 04864B38, func 0028581E
dtor     D               dtor.c:214  _al_unregister_destructor        [   1.02776] removed dtor for object 04864338
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.02837] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.02839] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.02841] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.02842] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.02843] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.02845] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.02846] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.02848] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.02849] Fake format
d3d      D         d3d_disp.cpp:1174 real_choose_bitmap_format        [   1.02850] Alpha doesn't match
d3d      D         d3d_disp.cpp:1181 real_choose_bitmap_format        [   1.02852] Adapter format is 23
d3d      D         d3d_disp.cpp:1184 real_choose_bitmap_format        [   1.02853] Found a format
d3d      I         d3d_disp.cpp:2283 _al_d3d_create_bitmap            [   1.02855] Chose bitmap format 9
dtor     D               dtor.c:184  _al_register_destructor          [   1.02863] added dtor for object 04864A38, func 0028581E
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   1.02973] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   1.02976] _al_d3d_sync_bitmap (video) ref count == 1
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.03023] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.03026] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.03027] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.03029] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.03031] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.03032] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.03034] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.03035] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.03037] Fake format
d3d      D         d3d_disp.cpp:1174 real_choose_bitmap_format        [   1.03038] Alpha doesn't match
d3d      D         d3d_disp.cpp:1181 real_choose_bitmap_format        [   1.03040] Adapter format is 23
d3d      D         d3d_disp.cpp:1184 real_choose_bitmap_format        [   1.03042] Found a format
d3d      I         d3d_disp.cpp:2283 _al_d3d_create_bitmap            [   1.03044] Chose bitmap format 9
dtor     D               dtor.c:184  _al_register_destructor          [   1.03056] added dtor for object 04864138, func 0028581E
dtor     D               dtor.c:214  _al_unregister_destructor        [   1.03061] removed dtor for object 04864A38
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.03124] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.03126] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.03127] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.03129] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.03130] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.03132] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.03134] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.03135] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.03137] Fake format
d3d      D         d3d_disp.cpp:1174 real_choose_bitmap_format        [   1.03138] Alpha doesn't match
d3d      D         d3d_disp.cpp:1181 real_choose_bitmap_format        [   1.03139] Adapter format is 23
d3d      D         d3d_disp.cpp:1184 real_choose_bitmap_format        [   1.03141] Found a format
d3d      I         d3d_disp.cpp:2283 _al_d3d_create_bitmap            [   1.03143] Chose bitmap format 9
dtor     D               dtor.c:184  _al_register_destructor          [   1.03153] added dtor for object 04865638, func 0028581E
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   1.03184] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   1.03186] _al_d3d_sync_bitmap (video) ref count == 1
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.03230] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.03235] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.03237] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.03238] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.03240] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.03241] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.03242] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.03244] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.03245] Fake format
d3d      D         d3d_disp.cpp:1174 real_choose_bitmap_format        [   1.03247] Alpha doesn't match
d3d      D         d3d_disp.cpp:1181 real_choose_bitmap_format        [   1.03248] Adapter format is 23
d3d      D         d3d_disp.cpp:1184 real_choose_bitmap_format        [   1.03250] Found a format
d3d      I         d3d_disp.cpp:2283 _al_d3d_create_bitmap            [   1.03252] Chose bitmap format 9
dtor     D               dtor.c:184  _al_register_destructor          [   1.03261] added dtor for object 04864638, func 0028581E
dtor     D               dtor.c:214  _al_unregister_destructor        [   1.03267] removed dtor for object 04865638
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.03328] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.03330] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.03332] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.03334] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.03336] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.03337] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.03339] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.03341] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.03342] Fake format
d3d      D         d3d_disp.cpp:1174 real_choose_bitmap_format        [   1.03343] Alpha doesn't match
d3d      D         d3d_disp.cpp:1181 real_choose_bitmap_format        [   1.03345] Adapter format is 23
d3d      D         d3d_disp.cpp:1184 real_choose_bitmap_format        [   1.03347] Found a format
d3d      I         d3d_disp.cpp:2283 _al_d3d_create_bitmap            [   1.03348] Chose bitmap format 9
dtor     D               dtor.c:184  _al_register_destructor          [   1.03358] added dtor for object 04865138, func 0028581E
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   1.03384] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   1.03386] _al_d3d_sync_bitmap (video) ref count == 1
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.03416] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.03418] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.03420] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.03421] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.03423] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.03424] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.03426] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.03427] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.03429] Fake format
d3d      D         d3d_disp.cpp:1174 real_choose_bitmap_format        [   1.03430] Alpha doesn't match
d3d      D         d3d_disp.cpp:1181 real_choose_bitmap_format        [   1.03433] Adapter format is 23
d3d      D         d3d_disp.cpp:1184 real_choose_bitmap_format        [   1.03435] Found a format
d3d      I         d3d_disp.cpp:2283 _al_d3d_create_bitmap            [   1.03436] Chose bitmap format 9
dtor     D               dtor.c:184  _al_register_destructor          [   1.03446] added dtor for object 04864F38, func 0028581E
dtor     D               dtor.c:214  _al_unregister_destructor        [   1.03451] removed dtor for object 04865138
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.03510] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.03512] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.03514] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.03515] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.03517] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.03518] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.03520] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.03521] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.03523] Fake format
d3d      D         d3d_disp.cpp:1174 real_choose_bitmap_format        [   1.03524] Alpha doesn't match
d3d      D         d3d_disp.cpp:1181 real_choose_bitmap_format        [   1.03526] Adapter format is 23
d3d      D         d3d_disp.cpp:1184 real_choose_bitmap_format        [   1.03527] Found a format
d3d      I         d3d_disp.cpp:2283 _al_d3d_create_bitmap            [   1.03529] Chose bitmap format 9
dtor     D               dtor.c:184  _al_register_destructor          [   1.03538] added dtor for object 04865338, func 0028581E
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   1.03573] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   1.03575] _al_d3d_sync_bitmap (video) ref count == 1
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.03613] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.03615] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.03617] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.03619] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.03620] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.03621] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.03623] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.03624] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.03626] Fake format
d3d      D         d3d_disp.cpp:1174 real_choose_bitmap_format        [   1.03627] Alpha doesn't match
d3d      D         d3d_disp.cpp:1181 real_choose_bitmap_format        [   1.03629] Adapter format is 23
d3d      D         d3d_disp.cpp:1184 real_choose_bitmap_format        [   1.03630] Found a format
d3d      I         d3d_disp.cpp:2283 _al_d3d_create_bitmap            [   1.03632] Chose bitmap format 9
dtor     D               dtor.c:184  _al_register_destructor          [   1.03643] added dtor for object 04864438, func 0028581E
dtor     D               dtor.c:214  _al_unregister_destructor        [   1.03648] removed dtor for object 04865338
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.03700] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.03702] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.03704] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.03706] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.03707] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.03709] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.03710] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.03712] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.03713] Fake format
d3d      D         d3d_disp.cpp:1174 real_choose_bitmap_format        [   1.03715] Alpha doesn't match
d3d      D         d3d_disp.cpp:1181 real_choose_bitmap_format        [   1.03717] Adapter format is 23
d3d      D         d3d_disp.cpp:1184 real_choose_bitmap_format        [   1.03718] Found a format
d3d      I         d3d_disp.cpp:2283 _al_d3d_create_bitmap            [   1.03720] Chose bitmap format 9
dtor     D               dtor.c:184  _al_register_destructor          [   1.03729] added dtor for object 04864E38, func 0028581E
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   1.03754] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   1.03758] _al_d3d_sync_bitmap (video) ref count == 1
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.03785] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.03787] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.03788] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.03790] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.03791] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.03792] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.03794] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.03796] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.03797] Fake format
d3d      D         d3d_disp.cpp:1174 real_choose_bitmap_format        [   1.03799] Alpha doesn't match
d3d      D         d3d_disp.cpp:1181 real_choose_bitmap_format        [   1.03800] Adapter format is 23
d3d      D         d3d_disp.cpp:1184 real_choose_bitmap_format        [   1.03802] Found a format
d3d      I         d3d_disp.cpp:2283 _al_d3d_create_bitmap            [   1.03803] Chose bitmap format 9
dtor     D               dtor.c:184  _al_register_destructor          [   1.03811] added dtor for object 04864538, func 0028581E
dtor     D               dtor.c:214  _al_unregister_destructor        [   1.03816] removed dtor for object 04864E38
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.03898] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.03901] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.03902] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.03904] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.03905] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.03907] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.03909] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.03910] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.03912] Fake format
d3d      D         d3d_disp.cpp:1174 real_choose_bitmap_format        [   1.03913] Alpha doesn't match
d3d      D         d3d_disp.cpp:1181 real_choose_bitmap_format        [   1.03915] Adapter format is 23
d3d      D         d3d_disp.cpp:1184 real_choose_bitmap_format        [   1.03916] Found a format
d3d      I         d3d_disp.cpp:2283 _al_d3d_create_bitmap            [   1.03918] Chose bitmap format 9
dtor     D               dtor.c:184  _al_register_destructor          [   1.03949] added dtor for object 04864C38, func 0028581E
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   1.04260] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   1.04264] _al_d3d_sync_bitmap (video) ref count == 1
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.04586] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.04590] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.04591] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.04593] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.04594] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.04596] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.04597] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.04599] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.04600] Fake format
d3d      D         d3d_disp.cpp:1174 real_choose_bitmap_format        [   1.04602] Alpha doesn't match
d3d      D         d3d_disp.cpp:1181 real_choose_bitmap_format        [   1.04603] Adapter format is 23
d3d      D         d3d_disp.cpp:1184 real_choose_bitmap_format        [   1.04605] Found a format
d3d      I         d3d_disp.cpp:2283 _al_d3d_create_bitmap            [   1.04607] Chose bitmap format 9
dtor     D               dtor.c:184  _al_register_destructor          [   1.04641] added dtor for object 04865638, func 0028581E
dtor     D               dtor.c:214  _al_unregister_destructor        [   1.04647] removed dtor for object 04864C38
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.04770] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.04773] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.04775] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.04777] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.04778] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.04780] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.04781] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.04783] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.04785] Fake format
d3d      D         d3d_disp.cpp:1174 real_choose_bitmap_format        [   1.04786] Alpha doesn't match
d3d      D         d3d_disp.cpp:1181 real_choose_bitmap_format        [   1.04788] Adapter format is 23
d3d      D         d3d_disp.cpp:1184 real_choose_bitmap_format        [   1.04790] Found a format
d3d      I         d3d_disp.cpp:2283 _al_d3d_create_bitmap            [   1.04791] Chose bitmap format 9
dtor     D               dtor.c:184  _al_register_destructor          [   1.04829] added dtor for object 04864A38, func 0028581E
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   1.05096] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   1.05100] _al_d3d_sync_bitmap (video) ref count == 1
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.05416] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.05419] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.05420] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.05422] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.05423] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.05425] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.05426] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.05428] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.05429] Fake format
d3d      D         d3d_disp.cpp:1174 real_choose_bitmap_format        [   1.05430] Alpha doesn't match
d3d      D         d3d_disp.cpp:1181 real_choose_bitmap_format        [   1.05432] Adapter format is 23
d3d      D         d3d_disp.cpp:1184 real_choose_bitmap_format        [   1.05439] Found a format
d3d      I         d3d_disp.cpp:2283 _al_d3d_create_bitmap            [   1.05440] Chose bitmap format 9
dtor     D               dtor.c:184  _al_register_destructor          [   1.05476] added dtor for object 04864C38, func 0028581E
dtor     D               dtor.c:214  _al_unregister_destructor        [   1.05481] removed dtor for object 04864A38
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.05622] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.05624] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.05626] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.05627] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.05629] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.05630] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.05632] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.05633] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.05635] Fake format
d3d      D         d3d_disp.cpp:1174 real_choose_bitmap_format        [   1.05636] Alpha doesn't match
d3d      D         d3d_disp.cpp:1181 real_choose_bitmap_format        [   1.05638] Adapter format is 23
d3d      D         d3d_disp.cpp:1184 real_choose_bitmap_format        [   1.05640] Found a format
d3d      I         d3d_disp.cpp:2283 _al_d3d_create_bitmap            [   1.05641] Chose bitmap format 9
dtor     D               dtor.c:184  _al_register_destructor          [   1.05671] added dtor for object 04864A38, func 0028581E
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   1.05927] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   1.05930] _al_d3d_sync_bitmap (video) ref count == 1
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.06392] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.06395] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.06397] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.06399] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.06400] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.06402] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.06404] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.06405] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.06407] Fake format
d3d      D         d3d_disp.cpp:1174 real_choose_bitmap_format        [   1.06408] Alpha doesn't match
d3d      D         d3d_disp.cpp:1181 real_choose_bitmap_format        [   1.06410] Adapter format is 23
d3d      D         d3d_disp.cpp:1184 real_choose_bitmap_format        [   1.06412] Found a format
d3d      I         d3d_disp.cpp:2283 _al_d3d_create_bitmap            [   1.06413] Chose bitmap format 9
dtor     D               dtor.c:184  _al_register_destructor          [   1.06450] added dtor for object 04864338, func 0028581E
dtor     D               dtor.c:214  _al_unregister_destructor        [   1.06458] removed dtor for object 04864A38
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.06591] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.06594] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.06595] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.06597] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.06598] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.06600] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.06601] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.06603] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.06604] Fake format
d3d      D         d3d_disp.cpp:1174 real_choose_bitmap_format        [   1.06606] Alpha doesn't match
d3d      D         d3d_disp.cpp:1181 real_choose_bitmap_format        [   1.06607] Adapter format is 23
d3d      D         d3d_disp.cpp:1184 real_choose_bitmap_format        [   1.06609] Found a format
d3d      I         d3d_disp.cpp:2283 _al_d3d_create_bitmap            [   1.06610] Chose bitmap format 9
dtor     D               dtor.c:184  _al_register_destructor          [   1.06649] added dtor for object 04865D38, func 0028581E
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   1.06926] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   1.06930] _al_d3d_sync_bitmap (video) ref count == 1
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.07246] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.07250] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.07252] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.07254] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.07255] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.07257] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.07258] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.07260] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.07261] Fake format
d3d      D         d3d_disp.cpp:1174 real_choose_bitmap_format        [   1.07263] Alpha doesn't match
d3d      D         d3d_disp.cpp:1181 real_choose_bitmap_format        [   1.07265] Adapter format is 23
d3d      D         d3d_disp.cpp:1184 real_choose_bitmap_format        [   1.07266] Found a format
d3d      I         d3d_disp.cpp:2283 _al_d3d_create_bitmap            [   1.07268] Chose bitmap format 9
dtor     D               dtor.c:184  _al_register_destructor          [   1.07317] added dtor for object 04864A38, func 0028581E
dtor     D               dtor.c:214  _al_unregister_destructor        [   1.07323] removed dtor for object 04865D38
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.07449] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.07451] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.07453] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.07454] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.07456] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.07457] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.07459] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.07460] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.07462] Fake format
d3d      D         d3d_disp.cpp:1174 real_choose_bitmap_format        [   1.07463] Alpha doesn't match
d3d      D         d3d_disp.cpp:1181 real_choose_bitmap_format        [   1.07465] Adapter format is 23
d3d      D         d3d_disp.cpp:1184 real_choose_bitmap_format        [   1.07466] Found a format
d3d      I         d3d_disp.cpp:2283 _al_d3d_create_bitmap            [   1.07468] Chose bitmap format 9
dtor     D               dtor.c:184  _al_register_destructor          [   1.07498] added dtor for object 04865738, func 0028581E
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   1.07744] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   1.07748] _al_d3d_sync_bitmap (video) ref count == 1
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.08054] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.08057] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.08058] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.08060] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.08061] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.08063] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.08064] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.08065] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.08067] Fake format
d3d      D         d3d_disp.cpp:1174 real_choose_bitmap_format        [   1.08068] Alpha doesn't match
d3d      D         d3d_disp.cpp:1181 real_choose_bitmap_format        [   1.08070] Adapter format is 23
d3d      D         d3d_disp.cpp:1184 real_choose_bitmap_format        [   1.08072] Found a format
d3d      I         d3d_disp.cpp:2283 _al_d3d_create_bitmap            [   1.08073] Chose bitmap format 9
dtor     D               dtor.c:184  _al_register_destructor          [   1.08107] added dtor for object 04865138, func 0028581E
dtor     D               dtor.c:214  _al_unregister_destructor        [   1.08113] removed dtor for object 04865738
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.08232] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.08235] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.08237] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.08238] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.08240] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.08241] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.08243] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.08244] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.08246] Fake format
d3d      D         d3d_disp.cpp:1174 real_choose_bitmap_format        [   1.08247] Alpha doesn't match
d3d      D         d3d_disp.cpp:1181 real_choose_bitmap_format        [   1.08249] Adapter format is 23
d3d      D         d3d_disp.cpp:1184 real_choose_bitmap_format        [   1.08251] Found a format
d3d      I         d3d_disp.cpp:2283 _al_d3d_create_bitmap            [   1.08252] Chose bitmap format 9
dtor     D               dtor.c:184  _al_register_destructor          [   1.08267] added dtor for object 04865238, func 0028581E
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   1.08525] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   1.08529] _al_d3d_sync_bitmap (video) ref count == 1
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.08922] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.08925] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.08927] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.08928] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.08930] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.08931] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.08933] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.08934] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.08936] Fake format
d3d      D         d3d_disp.cpp:1174 real_choose_bitmap_format        [   1.08937] Alpha doesn't match
d3d      D         d3d_disp.cpp:1181 real_choose_bitmap_format        [   1.08938] Adapter format is 23
d3d      D         d3d_disp.cpp:1184 real_choose_bitmap_format        [   1.08940] Found a format
d3d      I         d3d_disp.cpp:2283 _al_d3d_create_bitmap            [   1.08942] Chose bitmap format 9
dtor     D               dtor.c:184  _al_register_destructor          [   1.08979] added dtor for object 04865B38, func 0028581E
dtor     D               dtor.c:214  _al_unregister_destructor        [   1.08986] removed dtor for object 04865238
audio-dsound D           dsound.cpp:244  _dsound_open                     [   1.09058] Loading DirectSound module
system   D            wsystem.c:583  maybe_parent_dir                 [   1.09076] Also searching C:\Users\NEGU\Documents\ForbiddenDesert\TPFinal\
system   D            wsystem.c:633  _al_win_safe_load_library        [   1.09094] PathFindOnPath found: C:\WINDOWS\system32\dsound.dll
system   D            wsystem.c:544  load_library_at_path             [   1.09097] Calling LoadLibrary C:\WINDOWS\system32\dsound.dll
system   I            wsystem.c:547  load_library_at_path             [   1.09386] Loaded C:\WINDOWS\system32\dsound.dll
audio-dsound I           dsound.cpp:261  _dsound_open                     [   1.09392] Starting DirectSound...
audio-dsound D           dsound.cpp:271  _dsound_open                     [   1.13753] DirectSoundCreate8 succeeded
audio    I              audio.c:288  do_install_audio                 [   1.14000] Using DirectSound driver
audio-dsound D           dsound.cpp:306  _dsound_allocate_voice           [   1.14008] Allocating voice
audio-dsound D           dsound.cpp:365  _dsound_allocate_voice           [   1.14011] Allocated voice
dtor     D               dtor.c:184  _al_register_destructor          [   1.14013] added dtor for object 04819F28, func 00285751
dtor     D               dtor.c:184  _al_register_destructor          [   1.14018] added dtor for object 04D5B050, func 002860A7
audio-dsound D           dsound.cpp:462  _dsound_start_voice              [   1.14021] Starting voice
audio-dsound D           dsound.cpp:491  _dsound_start_voice              [   1.14023] CreateSoundBuffer
audio-dsound D           dsound.cpp:500  _dsound_start_voice              [   1.14185] CreateSoundBuffer succeeded
audio-dsound D           dsound.cpp:506  _dsound_start_voice              [   1.14189] Starting _dsound_update thread
audio-dsound I           dsound.cpp:516  _dsound_start_voice              [   1.14197] Voice started
dtor     D               dtor.c:184  _al_register_destructor          [   1.14201] added dtor for object 04E29D80, func 00285521
audio    D          kcm_mixer.c:121  _al_rechannel_matrix             [   1.14207] sample matrix:
audio    D          kcm_mixer.c:127  _al_rechannel_matrix             [   1.14209] 
audio    D          kcm_mixer.c:127  _al_rechannel_matrix             [   1.14211] 
dtor     D               dtor.c:184  _al_register_destructor          [   1.14213] added dtor for object 04E29858, func 00285521
audio    D          kcm_mixer.c:121  _al_rechannel_matrix             [   1.14215] sample matrix:
audio    D          kcm_mixer.c:127  _al_rechannel_matrix             [   1.14217] 
audio    D          kcm_mixer.c:127  _al_rechannel_matrix             [   1.14218] 
dtor     D               dtor.c:184  _al_register_destructor          [   1.14220] added dtor for object 04E29B70, func 00285521
audio    D          kcm_mixer.c:121  _al_rechannel_matrix             [   1.14222] sample matrix:
audio    D          kcm_mixer.c:127  _al_rechannel_matrix             [   1.14224] 
audio    D          kcm_mixer.c:127  _al_rechannel_matrix             [   1.14226] 
dtor     D               dtor.c:184  _al_register_destructor          [   1.14833] added dtor for object 048EA498, func 002853C8
dtor     D               dtor.c:184  _al_register_destructor          [   1.15631] added dtor for object 048EA1C8, func 002853C8
dtor     D               dtor.c:184  _al_register_destructor          [   1.15647] added dtor for object 048E9E68, func 002853C8
dtor     D               dtor.c:184  _al_register_destructor          [   1.15662] added dtor for object 048E9F40, func 002853C8
dtor     D               dtor.c:184  _al_register_destructor          [   1.15675] added dtor for object 048EA210, func 002853C8
dtor     D               dtor.c:184  _al_register_destructor          [   1.15690] added dtor for object 048EA018, func 002853C8
dtor     D               dtor.c:184  _al_register_destructor          [   1.15708] added dtor for object 048EA060, func 002853C8
dtor     D               dtor.c:184  _al_register_destructor          [   1.15724] added dtor for object 00C99BA8, func 002853C8
wav      I                wav.c:107  wav_open                         [   1.15737] Ignoring chunk: LIST
dtor     D               dtor.c:184  _al_register_destructor          [   1.15807] added dtor for object 00C99DA0, func 002853C8
dtor     D               dtor.c:184  _al_register_destructor          [   1.15911] added dtor for object 048E9EB0, func 002853C8
dtor     D               dtor.c:184  _al_register_destructor          [   1.15930] added dtor for object 04E531E0, func 002853C8
dtor     D               dtor.c:184  _al_register_destructor          [   1.15947] added dtor for object 04E530C0, func 002853C8
dtor     D               dtor.c:184  _al_register_destructor          [   1.15961] added dtor for object 04E53270, func 002853C8
font     D                ttf.c:792  al_load_ttf_font_stretch_f       [   1.16049] Font Resources/Papyrus.ttf loaded with pixel size 0 x 25.
font     D                ttf.c:794  al_load_ttf_font_stretch_f       [   1.16051]     ascent=24.0, descent=-13.0, height=36.0
dtor     D               dtor.c:184  _al_register_destructor          [   1.16054] added dtor for object 048F19B8, func 00284545
font     D                ttf.c:792  al_load_ttf_font_stretch_f       [   1.16095] Font Resources/consola.ttf loaded with pixel size 0 x 12.
font     D                ttf.c:794  al_load_ttf_font_stretch_f       [   1.16097]     ascent=9.0, descent=-3.0, height=14.0
dtor     D               dtor.c:184  _al_register_destructor          [   1.16100] added dtor for object 00C83550, func 00284545
font     D                ttf.c:792  al_load_ttf_font_stretch_f       [   1.16132] Font Resources/Papyrus.ttf loaded with pixel size 0 x 60.
font     D                ttf.c:794  al_load_ttf_font_stretch_f       [   1.16134]     ascent=56.0, descent=-30.0, height=86.0
dtor     D               dtor.c:184  _al_register_destructor          [   1.16137] added dtor for object 04E59768, func 00284545
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   1.16201] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   1.16207] _al_d3d_sync_bitmap (video) ref count == 2
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   1.16328] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   1.16331] _al_d3d_sync_bitmap (video) ref count == 2
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   1.16600] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   1.16615] _al_d3d_sync_bitmap (video) ref count == 2
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   1.16926] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   1.16930] _al_d3d_sync_bitmap (video) ref count == 2
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   1.17211] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   1.17215] _al_d3d_sync_bitmap (video) ref count == 2
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   1.17600] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   1.17604] _al_d3d_sync_bitmap (video) ref count == 2
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   1.17869] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   1.17872] _al_d3d_sync_bitmap (video) ref count == 2
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   1.18078] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   1.18082] _al_d3d_sync_bitmap (video) ref count == 2
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   1.18416] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   1.18420] _al_d3d_sync_bitmap (video) ref count == 2
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   1.18643] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   1.18647] _al_d3d_sync_bitmap (video) ref count == 2
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   1.18925] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   1.18929] _al_d3d_sync_bitmap (video) ref count == 2
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   1.19148] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   1.19152] _al_d3d_sync_bitmap (video) ref count == 2
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   1.19417] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   1.19452] _al_d3d_sync_bitmap (video) ref count == 2
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   1.19662] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   1.19665] _al_d3d_sync_bitmap (video) ref count == 2
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   1.19791] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   1.19794] _al_d3d_sync_bitmap (video) ref count == 2
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   1.20121] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   1.20125] _al_d3d_sync_bitmap (video) ref count == 2
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   1.21808] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   1.21812] _al_d3d_sync_bitmap (video) ref count == 2
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   1.22365] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   1.22369] _al_d3d_sync_bitmap (video) ref count == 2
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   1.22405] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   1.22407] _al_d3d_sync_bitmap (video) ref count == 2
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   1.22443] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   1.22446] _al_d3d_sync_bitmap (video) ref count == 2
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   1.22478] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   1.22481] _al_d3d_sync_bitmap (video) ref count == 2
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   1.22512] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   1.22514] _al_d3d_sync_bitmap (video) ref count == 2
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   1.22547] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   1.22549] _al_d3d_sync_bitmap (video) ref count == 2
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   1.22582] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   1.22584] _al_d3d_sync_bitmap (video) ref count == 2
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   1.22642] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   1.22645] _al_d3d_sync_bitmap (video) ref count == 2
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   1.22677] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   1.22680] _al_d3d_sync_bitmap (video) ref count == 2
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   1.22717] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   1.22720] _al_d3d_sync_bitmap (video) ref count == 2
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   1.22756] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   1.22758] _al_d3d_sync_bitmap (video) ref count == 2
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   1.22791] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   1.22794] _al_d3d_sync_bitmap (video) ref count == 2
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   1.22824] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   1.22827] _al_d3d_sync_bitmap (video) ref count == 2
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   1.22895] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   1.22897] _al_d3d_sync_bitmap (video) ref count == 2
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   1.22963] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   1.22966] _al_d3d_sync_bitmap (video) ref count == 2
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   1.23036] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   1.23039] _al_d3d_sync_bitmap (video) ref count == 2
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   1.23114] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   1.23117] _al_d3d_sync_bitmap (video) ref count == 2
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   1.23191] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   1.23193] _al_d3d_sync_bitmap (video) ref count == 2
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   1.23327] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   1.23330] _al_d3d_sync_bitmap (video) ref count == 2
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   1.23359] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   1.23362] _al_d3d_sync_bitmap (video) ref count == 2
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   1.23384] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   1.23387] _al_d3d_sync_bitmap (video) ref count == 2
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   1.23410] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   1.23412] _al_d3d_sync_bitmap (video) ref count == 2
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   1.23435] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   1.23438] _al_d3d_sync_bitmap (video) ref count == 2
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   1.23461] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   1.23463] _al_d3d_sync_bitmap (video) ref count == 2
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   1.23489] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   1.23492] _al_d3d_sync_bitmap (video) ref count == 2
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   1.23514] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   1.23516] _al_d3d_sync_bitmap (video) ref count == 2
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   1.23539] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   1.23542] _al_d3d_sync_bitmap (video) ref count == 2
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   1.23627] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   1.23629] _al_d3d_sync_bitmap (video) ref count == 2
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   1.23717] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   1.23720] _al_d3d_sync_bitmap (video) ref count == 2
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   1.23806] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   1.23809] _al_d3d_sync_bitmap (video) ref count == 2
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   1.23886] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   1.23889] _al_d3d_sync_bitmap (video) ref count == 2
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   1.23971] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   1.23973] _al_d3d_sync_bitmap (video) ref count == 2
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.24222] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.24225] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.24227] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.24229] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.24231] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.24232] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.24233] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.24235] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.24237] Fake format
d3d      D         d3d_disp.cpp:1174 real_choose_bitmap_format        [   1.24238] Alpha doesn't match
d3d      D         d3d_disp.cpp:1181 real_choose_bitmap_format        [   1.24240] Adapter format is 23
d3d      D         d3d_disp.cpp:1184 real_choose_bitmap_format        [   1.24241] Found a format
d3d      I         d3d_disp.cpp:2283 _al_d3d_create_bitmap            [   1.24243] Chose bitmap format 9
font     D                ttf.c:217  alloc_glyph_region               [   1.24272] Glyph 52: 17x18 (20x20)
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   1.24408] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   1.24411] _al_d3d_sync_bitmap (video) ref count == 2
font     D                ttf.c:217  alloc_glyph_region               [   1.24511] Glyph 80: 6x25 (8x28)
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   1.24529] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   1.24532] _al_d3d_sync_bitmap (video) ref count == 2
font     D                ttf.c:217  alloc_glyph_region               [   1.24609] Glyph 73: 14x13 (16x16)
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   1.24623] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   1.24634] _al_d3d_sync_bitmap (video) ref count == 2
font     D                ttf.c:217  alloc_glyph_region               [   1.24678] Glyph 69: 14x13 (16x16)
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   1.24692] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   1.24694] _al_d3d_sync_bitmap (video) ref count == 2
font     D                ttf.c:217  alloc_glyph_region               [   1.24750] Glyph 87: 13x13 (16x16)
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   1.24770] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   1.24773] _al_d3d_sync_bitmap (video) ref count == 2
font     D                ttf.c:217  alloc_glyph_region               [   1.24814] Glyph 16: 6x9 (8x12)
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   1.24829] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   1.24831] _al_d3d_sync_bitmap (video) ref count == 2
font     D                ttf.c:406  cache_glyph                      [   1.24865] Glyph 4 has zero size.
font     D                ttf.c:217  alloc_glyph_region               [   1.24876] Glyph 82: 14x13 (16x16)
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   1.24893] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   1.24895] _al_d3d_sync_bitmap (video) ref count == 2
font     D                ttf.c:217  alloc_glyph_region               [   1.24940] Glyph 88: 13x18 (16x20)
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   1.24971] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   1.24974] _al_d3d_sync_bitmap (video) ref count == 2
font     D                ttf.c:217  alloc_glyph_region               [   1.25019] Glyph 86: 12x13 (12x16)
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   1.25034] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   1.25037] _al_d3d_sync_bitmap (video) ref count == 2
font     D                ttf.c:217  alloc_glyph_region               [   1.25080] Glyph 45: 6x18 (8x20)
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   1.25094] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   1.25096] _al_d3d_sync_bitmap (video) ref count == 2
font     D                ttf.c:217  alloc_glyph_region               [   1.25135] Glyph 30: 7x11 (8x12)
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   1.25150] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   1.25153] _al_d3d_sync_bitmap (video) ref count == 2
font     D                ttf.c:217  alloc_glyph_region               [   1.25199] Glyph 61: 19x18 (20x20)
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   1.25214] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   1.25217] _al_d3d_sync_bitmap (video) ref count == 2
font     D                ttf.c:217  alloc_glyph_region               [   1.25259] Glyph 83: 16x13 (16x16)
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   1.25271] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   1.25273] _al_d3d_sync_bitmap (video) ref count == 2
font     D                ttf.c:217  alloc_glyph_region               [   1.25318] Glyph 89: 15x13 (16x16)
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   1.25330] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   1.25333] _al_d3d_sync_bitmap (video) ref count == 2
font     D                ttf.c:217  alloc_glyph_region               [   1.25379] Glyph 81: 18x13 (20x16)
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   1.25391] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   1.25394] _al_d3d_sync_bitmap (video) ref count == 2
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.25515] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.25517] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.25519] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.25520] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.25522] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.25523] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.25524] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.25526] Fake format
d3d      D         d3d_disp.cpp:1166 real_choose_bitmap_format        [   1.25527] Fake format
d3d      D         d3d_disp.cpp:1174 real_choose_bitmap_format        [   1.25529] Alpha doesn't match
d3d      D         d3d_disp.cpp:1181 real_choose_bitmap_format        [   1.25530] Adapter format is 23
d3d      D         d3d_disp.cpp:1184 real_choose_bitmap_format        [   1.25532] Found a format
d3d      I         d3d_disp.cpp:2283 _al_d3d_create_bitmap            [   1.25533] Chose bitmap format 9
font     D                ttf.c:217  alloc_glyph_region               [   1.25567] Glyph 19: 8x10 (8x12)
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   1.25621] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   1.25623] _al_d3d_sync_bitmap (video) ref count == 2
font     D                ttf.c:217  alloc_glyph_region               [   1.25712] Glyph 142: 7x10 (8x12)
font     D                ttf.c:217  alloc_glyph_region               [   1.25720] Glyph 135: 8x8 (8x8)
font     D                ttf.c:217  alloc_glyph_region               [   1.25728] Glyph 131: 8x8 (8x8)
font     D                ttf.c:217  alloc_glyph_region               [   1.25735] Glyph 149: 7x8 (8x8)
font     D                ttf.c:217  alloc_glyph_region               [   1.25741] Glyph 345: 6x6 (8x8)
font     D                ttf.c:406  cache_glyph                      [   1.25743] Glyph 3 has zero size.
font     D                ttf.c:217  alloc_glyph_region               [   1.25750] Glyph 144: 8x8 (8x8)
font     D                ttf.c:217  alloc_glyph_region               [   1.25755] Glyph 150: 7x10 (8x12)
font     D                ttf.c:217  alloc_glyph_region               [   1.25761] Glyph 148: 8x8 (8x8)
font     D                ttf.c:217  alloc_glyph_region               [   1.25766] Glyph 138: 8x10 (8x12)
font     D                ttf.c:217  alloc_glyph_region               [   1.25771] Glyph 12: 8x10 (8x12)
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   1.25832] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   1.25835] _al_d3d_sync_bitmap (video) ref count == 2
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [   1.25911] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [   1.25914] _al_d3d_sync_bitmap (video) ref count == 2
font     D                ttf.c:217  alloc_glyph_region               [  12.17144] Glyph 21: 6x18 (8x20)
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [  12.17157] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [  12.17162] _al_d3d_sync_bitmap (video) ref count == 2
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [  12.17262] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [  12.17265] _al_d3d_sync_bitmap (video) ref count == 2
font     D                ttf.c:217  alloc_glyph_region               [  12.22988] Glyph 29: 15x23 (16x24)
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [  12.22998] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [  12.23001] _al_d3d_sync_bitmap (video) ref count == 2
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [  12.23095] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [  12.23098] _al_d3d_sync_bitmap (video) ref count == 2
font     D                ttf.c:217  alloc_glyph_region               [  12.77398] Glyph 22: 17x19 (20x20)
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [  12.77409] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [  12.77413] _al_d3d_sync_bitmap (video) ref count == 2
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [  12.77501] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [  12.77504] _al_d3d_sync_bitmap (video) ref count == 2
font     D                ttf.c:217  alloc_glyph_region               [  12.94061] Glyph 18: 7x4 (8x4)
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [  12.94070] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [  12.94073] _al_d3d_sync_bitmap (video) ref count == 2
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [  12.94163] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [  12.94165] _al_d3d_sync_bitmap (video) ref count == 2
font     D                ttf.c:217  alloc_glyph_region               [  13.19468] Glyph 26: 15x22 (16x24)
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [  13.19480] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [  13.19483] _al_d3d_sync_bitmap (video) ref count == 2
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [  13.19572] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [  13.19575] _al_d3d_sync_bitmap (video) ref count == 2
font     D                ttf.c:217  alloc_glyph_region               [  13.38931] Glyph 28: 14x18 (16x20)
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [  13.38955] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [  13.38964] _al_d3d_sync_bitmap (video) ref count == 2
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [  13.39088] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [  13.39093] _al_d3d_sync_bitmap (video) ref count == 2
font     D                ttf.c:217  alloc_glyph_region               [  13.91155] Glyph 27: 16x24 (16x24)
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [  13.91164] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [  13.91166] _al_d3d_sync_bitmap (video) ref count == 2
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [  13.91267] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [  13.91271] _al_d3d_sync_bitmap (video) ref count == 2
font     D                ttf.c:217  alloc_glyph_region               [  14.57612] Glyph 20: 18x18 (20x20)
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [  14.57635] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [  14.57638] _al_d3d_sync_bitmap (video) ref count == 2
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [  14.57711] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [  14.57714] _al_d3d_sync_bitmap (video) ref count == 2
font     D                ttf.c:217  alloc_glyph_region               [  16.06052] Glyph 23: 8x10 (8x12)
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [  16.06070] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [  16.06072] _al_d3d_sync_bitmap (video) ref count == 2
font     D                ttf.c:217  alloc_glyph_region               [  16.06126] Glyph 155: 9x10 (12x12)
font     D                ttf.c:217  alloc_glyph_region               [  16.06132] Glyph 139: 7x11 (8x12)
font     D                ttf.c:217  alloc_glyph_region               [  16.06140] Glyph 137: 9x10 (12x12)
font     D                ttf.c:217  alloc_glyph_region               [  16.06145] Glyph 6: 7x10 (8x12)
font     D                ttf.c:217  alloc_glyph_region               [  16.06149] Glyph 145: 8x8 (8x8)
font     D                ttf.c:217  alloc_glyph_region               [  16.06153] Glyph 133: 7x8 (8x8)
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [  16.06187] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [  16.06188] _al_d3d_sync_bitmap (video) ref count == 2
font     D                ttf.c:217  alloc_glyph_region               [  16.06272] Glyph 22: 8x10 (8x12)
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [  16.06283] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [  16.06285] _al_d3d_sync_bitmap (video) ref count == 2
font     D                ttf.c:217  alloc_glyph_region               [  16.06326] Glyph 151: 8x8 (8x8)
font     D                ttf.c:217  alloc_glyph_region               [  16.06331] Glyph 136: 9x10 (12x12)
font     D                ttf.c:217  alloc_glyph_region               [  16.06335] Glyph 352: 5x10 (8x12)
d3d      D          d3d_bmp.cpp:467  _al_d3d_sync_bitmap              [  16.06367] _al_d3d_sync_bitmap (system) ref count == 1
d3d      D          d3d_bmp.cpp:473  _al_d3d_sync_bitmap              [  16.06369] _al_d3d_sync_bitmap (video) ref count == 2
</file>

<file path="CMakeLists.txt">
# Specify the minimum version for CMake
cmake_minimum_required(VERSION 3.1)
# CMAKE_POLICY(SET CMP0072 NEW)
# Project name
project(ForbiddenDesert)

set(CMAKE_CXX_STANDARD 11)  # enable C++11 standard

set(EXECUTABLE_OUTPUT_PATH ${CMAKE_BINARY_DIR})
set(LIBRARY_OUTPUT_PATH ${CMAKE_BINARY_DIR})

set(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} "${CMAKE_SOURCE_DIR}/cmake/")
# Finds Allegro using pkgconfig, so it must be configured correctly
find_package(Allegro5 REQUIRED)

include_directories(${ALLEGRO_INCLUDE_DIR})
include_directories("${PROJECT_SOURCE_DIR}")

find_package(OpenGL REQUIRED)
find_package(GLUT REQUIRED)
include_directories(
		${PROJECT_SOURCE_DIR}/include
		${PROJECT_SOURCE_DIR}/src
)
include_directories( ${OPENGL_INCLUDE_DIRS}  ${GLUT_INCLUDE_DIRS} )


file(GLOB all_SRCS
        "${PROJECT_SOURCE_DIR}/include/*.h"
		"${PROJECT_SOURCE_DIR}/include/*.hpp"
        "${PROJECT_SOURCE_DIR}/src/*.cpp"
		"${PROJECT_SOURCE_DIR}/src/*.c"
        )

add_executable(ForbiddenDesert ${all_SRCS})
target_link_libraries(${PROJECT_NAME} ${ALLEGRO_LIBRARIES} ${OPENGL_LIBRARIES} ${GLUT_LIBRARY})
</file>

<file path="README.md">
# Forbidden Desert

[![Cpp Lines of Code](https://tokei.rs/b1/github/NEGU93/ForbiddenDesert?category=code&lang=cpp)](https://github.com/NEGU93/ForbiddenDesert)

## Installing

### Dependencies
```
sudo apt-get install liballegro5-dev
sudo apt-get install freeglut3-dev libftgl-dev
sudo apt-get install liballegro-image5-dev liballegro-ttf5-dev liballegro-audio5-dev liballegro-video5-dev liballegro-physfs5-dev liballegro-acodec5-dev liballegro-acodec5-dev liballegro-dialog5-dev
```

### Debugging allegro 5
Inside `testingAllegro/` folder you can run:
```
gcc hello.c -o hello $(pkg-config allegro-5 allegro_font-5 --libs --cflags)
```

## How to Play

The game rules can be found on: [ForbiddenDesert-RULES](https://www.gamewright.com/gamewright/pdfs/Rules/ForbiddenDesertTM-RULES.pdf). The pdf was also downloaded on the main folder of the project.

## Gameplay

Here are some screencaptures of the game itself.

<div style="text-align:center">
<img src="Resources/gameplay/Screenshot from 2019-01-03 16-17-16.png" alt="Start Menu" width="400"/>
</div>

<div style="text-align:center">
<img src="Resources/gameplay/Screenshot from 2019-01-03 16-17-29.png" alt="Start Menu" width="900"/>
</div>

<div style="text-align:center">
<img src="Resources/gameplay/Screenshot from 2019-01-03 16-18-20.png" alt="Start Menu" width="900"/>
</div>
</file>

</files>
