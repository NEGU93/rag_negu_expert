This file is a merged representation of the entire codebase, combined into a single document by Repomix.
The content has been processed where security check has been disabled.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Security check has been disabled - content may contain sensitive information
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.gitignore
allegro.cpp
allegro.h
def.h
main.cpp
Makefile
node.cpp
Node.h
programCore.cpp
programCore.h
README.md
Resistor.cpp
Resistor.h
setValue.cpp
setValue.h
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".gitignore">
## Ignore Visual Studio temporary files, build results, and
## files generated by popular Visual Studio add-ons.

#VisualStudio
*.vcxproj
*.filters
*.vcxproj.filters
*.vcxproj.user
*.sln
*.sdf
*.v11.suo
*.suo
*.user

#Ignore Folders
Debug/
.vs/

# User-specific files
*.suo
*.user
*.userosscache
*.sln.docstates

# User-specific files (MonoDevelop/Xamarin Studio)
*.userprefs

# Build results
[Dd]ebug/
[Dd]ebugPublic/
[Rr]elease/
[Rr]eleases/
x64/
x86/
bld/
[Bb]in/
[Oo]bj/
[Ll]og/

# Visual Studio 2015 cache/options directory
.vs/
# Uncomment if you have tasks that create the project's static files in wwwroot
#wwwroot/

# MSTest test Results
[Tt]est[Rr]esult*/
[Bb]uild[Ll]og.*

# NUNIT
*.VisualState.xml
TestResult.xml

# Build Results of an ATL Project
[Dd]ebugPS/
[Rr]eleasePS/
dlldata.c

# DNX
project.lock.json
artifacts/

*_i.c
*_p.c
*_i.h
*.ilk
*.meta
*.obj
*.pch
*.pdb
*.pgc
*.pgd
*.rsp
*.sbr
*.tlb
*.tli
*.tlh
*.tmp
*.tmp_proj
*.log
*.vspscc
*.vssscc
.builds
*.pidb
*.svclog
*.scc

# Chutzpah Test files
_Chutzpah*

# Visual C++ cache files
ipch/
*.aps
*.ncb
*.opendb
*.opensdf
*.sdf
*.cachefile

# Visual Studio profiler
*.psess
*.vsp
*.vspx
*.sap

# TFS 2012 Local Workspace
$tf/

# Guidance Automation Toolkit
*.gpState

# ReSharper is a .NET coding add-in
_ReSharper*/
*.[Rr]e[Ss]harper
*.DotSettings.user

# JustCode is a .NET coding add-in
.JustCode

# TeamCity is a build add-in
_TeamCity*

# DotCover is a Code Coverage Tool
*.dotCover

# NCrunch
_NCrunch_*
.*crunch*.local.xml
nCrunchTemp_*

# MightyMoose
*.mm.*
AutoTest.Net/

# Web workbench (sass)
.sass-cache/

# Installshield output folder
[Ee]xpress/

# DocProject is a documentation generator add-in
DocProject/buildhelp/
DocProject/Help/*.HxT
DocProject/Help/*.HxC
DocProject/Help/*.hhc
DocProject/Help/*.hhk
DocProject/Help/*.hhp
DocProject/Help/Html2
DocProject/Help/html

# Click-Once directory
publish/

# Publish Web Output
*.[Pp]ublish.xml
*.azurePubxml
# TODO: Comment the next line if you want to checkin your web deploy settings 
# but database connection strings (with potential passwords) will be unencrypted
*.pubxml
*.publishproj

# NuGet Packages
*.nupkg
# The packages folder can be ignored because of Package Restore
**/packages/*
# except build/, which is used as an MSBuild target.
!**/packages/build/
# Uncomment if necessary however generally it will be regenerated when needed
#!**/packages/repositories.config
# NuGet v3's project.json files produces more ignoreable files
*.nuget.props
*.nuget.targets

# Microsoft Azure Build Output
csx/
*.build.csdef

# Microsoft Azure Emulator
ecf/
rcf/

# Windows Store app package directories and files
AppPackages/
BundleArtifacts/
Package.StoreAssociation.xml
_pkginfo.txt

# Visual Studio cache files
# files ending in .cache can be ignored
*.[Cc]ache
# but keep track of directories ending in .cache
!*.[Cc]ache/

# Others
ClientBin/
~$*
*~
*.dbmdl
*.dbproj.schemaview
*.pfx
*.publishsettings
node_modules/
orleans.codegen.cs

# Since there are multiple workflows, uncomment next line to ignore bower_components 
# (https://github.com/github/gitignore/pull/1529#issuecomment-104372622)
#bower_components/

# RIA/Silverlight projects
Generated_Code/

# Backup & report files from converting an old project file
# to a newer Visual Studio version. Backup files are not needed,
# because we have git ;-)
_UpgradeReport_Files/
Backup*/
UpgradeLog*.XML
UpgradeLog*.htm

# SQL Server files
*.mdf
*.ldf

# Business Intelligence projects
*.rdl.data
*.bim.layout
*.bim_*.settings

# Microsoft Fakes
FakesAssemblies/

# GhostDoc plugin setting file
*.GhostDoc.xml

# Node.js Tools for Visual Studio
.ntvs_analysis.dat

# Visual Studio 6 build log
*.plg

# Visual Studio 6 workspace options file
*.opt

# Visual Studio LightSwitch build output
**/*.HTMLClient/GeneratedArtifacts
**/*.DesktopClient/GeneratedArtifacts
**/*.DesktopClient/ModelManifest.xml
**/*.Server/GeneratedArtifacts
**/*.Server/ModelManifest.xml
_Pvt_Extensions

# Paket dependency manager
.paket/paket.exe
paket-files/

# FAKE - F# Make
.fake/

# JetBrains Rider
.idea/
*.sln.iml

#OS junk files
[Tt]humbs.db
*.DS_Store

#Visual Studio files
*.[Oo]bj
*.user
*.aps
*.pch
*.vspscc
*.vssscc
*_i.c
*_p.c
*.ncb
*.suo
*.tlb
*.tlh
*.bak
*.[Cc]ache
*.ilk
*.log
*.lib
*.sbr
*.sdf
ipch/
obj/
[Bb]in
[Dd]ebug*/
[Rr]elease*/
Ankh.NoLoad

#Tooling
_ReSharper*/
*.resharper
[Tt]est[Rr]esult*

#Project files
[Bb]uild/

#Subversion files
.svn

# Office Temp Files
~$*
</file>

<file path="allegro.cpp">
#include "allegro.h"
#include "def.h"


#define FPS 30
#define FONTSIZE 60

#define OK 0
#define READY 1
#define EXIT -1

#define DIAGONALLY 1 //1 = lines in diagonall, 0 = Rectas

//////////////////////////////////////////////////////////////////////////////////////////////
//				INICIALIZO ALLEGRO Y TODOS LOS COMPLEMENTOS QUE SE USAN						//
//////////////////////////////////////////////////////////////////////////////////////////////
int init_allegro(ALL *allegro) {
	int state = FALSE;
	//Initialize Allegro
	if (al_init()) {
		if (al_init_primitives_addon()) {
			if (al_init_image_addon()) {
				if (al_install_mouse()) {
					if (al_install_keyboard()) {
						if (allegro->display = al_create_display(SCREEN_X, SCREEN_Y)) {
							al_set_window_title(allegro->display, "Resistor Calulator by NEGU");
							//CODE TO FULLSCREEN, CHANGE IN CASE OF MULFUNCTION
							/*TODO: lo comento porque es dificil para debuguear... luego agregarlo. tira mas facha*/
							/*ALLEGRO_DISPLAY_MODE   disp_data;
							al_get_display_mode(al_get_num_display_modes() - 1, &disp_data);
							al_set_new_display_flags(ALLEGRO_FULLSCREEN);
							allegro->display = al_create_display(disp_data.width, disp_data.height);
							allegro->screenWidth = disp_data.width;
							allegro->screenHeight = disp_data.height;*/
							//allegro->display = al_create_display(SCREEN_X, SCREEN_Y);
							allegro->screenWidth = SCREEN_X;
							allegro->screenHeight = SCREEN_Y;

							if (allegro->downBar = al_load_bitmap("Resources/DownBar.png")) {
								if (allegro->fondo = al_load_bitmap("Resources/BackImage.png")) {
									state = TRUE;
								}
								else { printf("Couldn't load BackImage.png\n"); }
							}
							else { printf("Couldn't load DownBar.png\n"); }
						}
						else { printf("Failed to create display"); }
					}
					else { printf( "Failed to initialize keyboard" ); al_uninstall_mouse(); }
				}
				else { printf( "Failed to initialize mouse" ); al_shutdown_image_addon(); }
			}
			else { printf( "Failed to initialize image addon" ); al_shutdown_primitives_addon(); }
		}
		else { printf( "Failed to initialize primitives addon" ); }
	}
	else { printf( "Failed to initialize allegro" ); }
	
	//Initialize events
	if (state) {
		state = FALSE;
		if (allegro->timer = al_create_timer(1.0 / FPS)) {
			al_start_timer(allegro->timer);
			if (allegro->events_queue = al_create_event_queue()) {
				al_register_event_source(allegro->events_queue, al_get_timer_event_source(allegro->timer));
				al_register_event_source(allegro->events_queue, al_get_keyboard_event_source());
				al_register_event_source(allegro->events_queue, al_get_mouse_event_source());
				al_register_event_source(allegro->events_queue, al_get_display_event_source(allegro->display));
				state = TRUE;
			}
		}
		else { printf( "Failed to initialize timer" ); }
	}
	//Initialize fonts
	if (state) {
		state = FALSE;
		al_init_font_addon();
		if (al_init_ttf_addon()) {
			if (allegro->font = al_load_ttf_font("Resources/consola.ttf", 12, 0)) {
				state = TRUE;
			}
			else { printf( "Failed to initialize arial.ttf" ); }
		}
		else { printf( "Failed to initialize ttf addon" ); }
	}

	al_flip_display();
	al_start_timer(allegro->timer);

	return state;
}

void destroyAll(ALL *allegro) {
	al_destroy_event_queue(allegro->events_queue);
	//Timers
	al_destroy_timer(allegro->timer);
	//Fonts
	al_destroy_font(allegro->font);
	//Bitmaps
	al_destroy_bitmap(allegro->fondo);
	al_destroy_bitmap(allegro->downBar);
	//Addons
	al_uninstall_keyboard();
	al_uninstall_mouse();
	al_shutdown_image_addon();
	al_shutdown_ttf_addon();
	al_shutdown_primitives_addon();
	al_uninstall_audio();
}

ALLEGRO_BITMAP *al_load_bitmap_resized(const char *filename, ALL* allegro) {
	ALLEGRO_BITMAP *resized_bmp, *loaded_bmp, *prev_target;
	//Same as al_load_bitmap but resized according to the display size

	// 1. load the bitmap at the original size				 
	loaded_bmp = al_load_bitmap(filename);
	if (!loaded_bmp) return NULL;

	// 2. create a temporary bitmap of size we want
	resized_bmp = al_create_bitmap(al_get_bitmap_width(loaded_bmp) * allegro->screenWidth / MAXRESOLUTION_X, al_get_bitmap_height(loaded_bmp) * allegro->screenHeight / MAXRESOLUTION_Y);
	if (!resized_bmp) {
		al_destroy_bitmap(loaded_bmp);
		return NULL;
	}

	// 3. set the target bitmap to the resized bmp
	prev_target = al_get_target_bitmap();
	al_set_target_bitmap(resized_bmp);

	// 4. copy the loaded bitmap to the resized bmp
	al_draw_scaled_bitmap(loaded_bmp,
		0, 0,                                // source origin
		al_get_bitmap_width(loaded_bmp),     // source width
		al_get_bitmap_height(loaded_bmp),    // source height
		0, 0,                                // target origin
		al_get_bitmap_width(loaded_bmp) * allegro->screenWidth / MAXRESOLUTION_X,		// target dimensions
		al_get_bitmap_height(loaded_bmp) * allegro->screenHeight / MAXRESOLUTION_Y,
		0                                    // flags
		);

	// 5. restore the previous target and clean up
	al_set_target_bitmap(prev_target);
	al_destroy_bitmap(loaded_bmp);

	return resized_bmp;
}

void draw_line(int x1, int y1, int x2, int y2, ALLEGRO_COLOR color, float thickness, bool diagonally) {
	if (diagonally) {
		al_draw_line(x1, y1, x2, y2, color, thickness);
	}
	else {
		if (y1 < y2) {
			al_draw_line(x1, y1, x2, y1, color, thickness);
			al_draw_line(x2, y1, x2, y2, color, thickness);
		}
		else {
			al_draw_line(x1, y1, x1, y2, color, thickness);
			al_draw_line(x1, y2, x2, y2, color, thickness);
		}
	}
}
void draw_line_inverted(int x1, int y1, int x2, int y2, ALLEGRO_COLOR color, float thickness, bool diagonally) {
	if (diagonally) {
		al_draw_line(x1, y1, x2, y2, color, thickness);
	}
	else {
		if (y1 > y2) {
			al_draw_line(x1, y1, x2, y1, color, thickness);
			al_draw_line(x2, y1, x2, y2, color, thickness);
		}
		else {
			al_draw_line(x1, y1, x1, y2, color, thickness);
			al_draw_line(x1, y2, x2, y2, color, thickness);
		}
	}
}
</file>

<file path="allegro.h">
#ifndef ALLEGRO_H_INCLUDED
#define ALLEGRO_H_INCLUDED

#define ALLEGRO_STATICLINK 
#include<allegro5\allegro.h>
#include<allegro5\allegro_primitives.h>
#include <allegro5\allegro_font.h>
#include <allegro5\allegro_ttf.h>
#include <allegro5\allegro_image.h>
#include <allegro5\allegro_acodec.h>

#define SCREEN_X 1280	
#define SCREEN_Y 720

#define MAXRESOLUTION_X SCREEN_X
#define MAXRESOLUTION_Y SCREEN_Y

typedef struct {
	int screenWidth;
	int screenHeight;
	//DISPLAYS
	ALLEGRO_DISPLAY *display;
	//EVENT QUEUE
	ALLEGRO_EVENT_QUEUE *events_queue;
	//TIMERS
	ALLEGRO_TIMER * timer;
	//FONTS
	ALLEGRO_FONT *font;
	//BITMAPS
	ALLEGRO_BITMAP* fondo;
	ALLEGRO_BITMAP* downBar;
} ALL;

int init_allegro(ALL *allegro);
void destroyAll(ALL *allegro);
ALLEGRO_BITMAP *al_load_bitmap_resized(const char *filename, ALL* allegro); //TODO: que pase solo los ints que necesito y no toda la struct
void draw_line(int x1, int y1, int x2, int y2, ALLEGRO_COLOR color, float thickness, bool diagonally);
void draw_line_inverted(int x1, int y1, int x2, int y2, ALLEGRO_COLOR color, float thickness, bool diagonally);

#endif
</file>

<file path="def.h">
#ifndef DEF_H_INCLUDED
#define DEF_H_INCLUDED

#include <stdio.h>
#include <iostream>
#include <vector>

using namespace std;

#define WHITE 255,255,255
#define BLACK 0,0,0
#define GRAY 100,100,100
#define DARKBLUE 0,0,100
#define LINECOLOUR DARKBLUE

#define PI 3.14159265358979323846
#define DELTA 5
#define LINEWIDTH 2
#define MULTIPLE 32

#define TRUE 1
#define FALSE 0

enum UpperLowerEnum { NOTOVER, UPPERPART, LOWERPART, NODEVCC, NODEGND };

typedef struct {
	int x;
	int y;
} pos;

typedef int BOOL;
typedef unsigned char uchar;
typedef unsigned long int uint;

#endif
</file>

<file path="main.cpp">
#include "def.h"
#include "allegro.h"
#include "programCore.h"
#include "Resistor.h"

void main(void) {
	//Allegro initialization
	ALL allegroData = { 0, 0, NULL, NULL, NULL, NULL, };
	ALL* allegro = &allegroData;
	int i = init_allegro(allegro);
	//Program and Gui elements
	ProgramElements programElements = { {0, 0}, FALSE, TRUE, NORMAL };
	ProgramElements *elements = &programElements;
	GUIElements guiElements;
	GUIElements* gui = &guiElements;
	//Initialize program Core
	ProgramCore *programCore = NULL;
	if (programCore != NULL) { delete programCore; }
	programCore = new ProgramCore(gui);
	//Principal loop
	while (programElements.stillRunning == TRUE) {
		programElements.stillRunning = programCore->eventHandler(allegro, elements, gui);
	}
	//End Program
	al_destroy_display(allegro->display);
	destroyAll(allegro);

	getchar();
}
</file>

<file path="Makefile">
#Makefile para el programa final de programacion.

CXX=g++
CFLAGS=
LDFLAGS=-L/usr/lib -liballegro -liballegro_primitives -liballegro_image -liballegro_acodec -liballegro_font -liballegro_ttf -liballegro_main -lm 
INCLUDE= -I/usr/include/allegro5 


OBJS = main.o Resistor.o allegro.o node.o programCore.o SetValue.o
OUT = program

all: program
	
clear:
	rm -rf *.o program
	
program: $(OBJS)
	$(CXX) -o $(OBJS) $(OUT) $(INCLUDE) $(CFLAGS) $(LDFLAGS)
	
main.o: main.cpp def.h allegro.h programCore.h Resistor.h
	$(CXX) -c main.cpp 

Resistor.o: Resistor.cpp Resistor.h
	$(CXX) -c Resistor.cpp
	
allegro.o: allegro.cpp allegro.h def.h
	$(CXX) -c allegro.cpp

node.o: node.cpp Node.h
	$(CXX) -c node.cpp

programCore.o: programCore.cpp programCore.h setValue.h
	$(CXX) -c programCore.cpp

setValue.o: setValue.cpp setValue.h def.h
	$(CXX) -c setValue.cpp
</file>

<file path="node.cpp">
#include "Node.h"

Node::Node(ALLEGRO_BITMAP* image, bool type) {
	if (image != NULL) {
		this->image = image;
		this->index = -1;
		nodeCoords.x = -1;
		nodeCoords.y = -1;
		nodeType = type;
	}
}
Node::Node() {
	this->image = NULL;
	this->index = -1;
	nodeCoords.x = -1;
	nodeCoords.y = -1;
	nodeType = false;
}
void Node::updateNode(vector<Resistor> &resistorArray, ALLEGRO_BITMAP* resistorImage, bool diagonally) {
	if ((nodeCoords.x != -1) && (nodeCoords.y != -1)) {
		al_draw_bitmap(image, nodeCoords.x, nodeCoords.y, 0);
	}
	if (index != -1) {
		if (index < resistorArray.size()) { // Just in case, It should always enter here.
			if (nodeType) { //If VCC
				pos firstRes = resistorArray[index].getCoords();
				draw_line(nodeCoords.x + al_get_bitmap_width(image) / 2, nodeCoords.y + al_get_bitmap_height(image), firstRes.x, firstRes.y, al_map_rgb(LINECOLOUR), LINEWIDTH, diagonally);
			}
			else {
				pos lastRes = resistorArray[index].getCoords();
				if (resistorArray[index].getHoriz()) {
					draw_line_inverted(nodeCoords.x + al_get_bitmap_width(image) / 2, nodeCoords.y, lastRes.x + al_get_bitmap_width(resistorImage), lastRes.y, al_map_rgb(LINECOLOUR), LINEWIDTH, diagonally);
				}
				else {
					draw_line_inverted(nodeCoords.x + al_get_bitmap_width(image) / 2, nodeCoords.y, lastRes.x, lastRes.y + al_get_bitmap_width(resistorImage), al_map_rgb(LINECOLOUR), LINEWIDTH, diagonally);
				}
			}
		}
		else { cout << "VCC is pointing outside the array" << endl; }
	}
}
void Node::setCoords(int x, int y) {
	nodeCoords.x = x;
	nodeCoords.y = y;
}
bool Node::mouseOverNode(pos mouse) {
	if ((mouse.x > nodeCoords.x) && (mouse.x < nodeCoords.x + al_get_bitmap_width(image))) {
		if ((mouse.y > nodeCoords.y) && (mouse.y < nodeCoords.y + al_get_bitmap_height(image))) {
			return true;
		}
	}
	return false;
}
bool Node::wireNode(pos mouse, int &selectedResIndex, UpperLowerEnum& resStart) {
	if (mouseOverNode(mouse)) {
		if (resStart == NOTOVER) { 
			if (nodeType) { resStart = NODEVCC; }
			else { resStart = NODEGND; }
		}
		else if (resStart != NOTOVER && selectedResIndex != -1) {	// The second is to make sure GND is not connected to VCC
			setIndex(selectedResIndex);
			resStart = NOTOVER;
			selectedResIndex = -1;
		}
		else {
			selectedResIndex = -1;
			resStart = NOTOVER;
			return true;
		}
	}
	return false;
}
</file>

<file path="Node.h">
#ifndef NODE_H_INCLUDED
#define NODE_H_INCLUDED	

#include "def.h"
#include "allegro.h"
#include "Resistor.h"

#define VCC 1
#define GND 0

class Node {
public:
	Node();
	Node(ALLEGRO_BITMAP* image, bool type);
	void updateNode(vector<Resistor> &resistorArray, ALLEGRO_BITMAP* resistorImage, bool diagonally);
	bool mouseOverNode(pos mouse);
	bool wireNode(pos mouse, int &selectedResIndex, UpperLowerEnum& resStart);
	//Setters
	void setIndex(int i) { index = i; }
	void setCoords(int x, int y);
	void decreseIndex() { index = index - 1; }
	//Getters
	pos getCorrds() { return nodeCoords; }
	int getIndex() { return index; }
private:
	int index;
	pos nodeCoords;
	ALLEGRO_BITMAP* image;
	bool nodeType; //true == VCC, false == GND
};

#endif
</file>

<file path="programCore.cpp">
//#include <math.h>
#include "programCore.h"
#include "setValue.h"
#include <stdlib.h>
#define TIMEPAUSE 1000
#define PI 3.14159265358979323846

ProgramCore::ProgramCore(GUIElements* gui) {
	if (!initializeGUIElements(gui)) {
		printf("Error initializing guiElements\n");
	}
	resStart = NOTOVER;
	selectedResIndex = -1;
	vcc = Node(gui->vccImage, true);
	gnd = Node(gui->gndImage, false);
	backupPos.x = 0;
	backupPos.y = 0;
	grid = true;
	stepMode = true;
	diagonally = false;
}
ProgramCore::~ProgramCore() {
	resistorArray.clear();
}

//Destroyers
void destroyButton(Button* button) {
	al_destroy_bitmap(button->buttonImage);
	al_destroy_bitmap(button->mouseOverButtonImage);
}
void destroyGuiElments(GUIElements* guiElements) {
	// Destroy Buttons
	destroyButton(&(guiElements->resistorButton));
	destroyButton(&(guiElements->wireButton));
	destroyButton(&(guiElements->gndButton));
	destroyButton(&(guiElements->vccButton));
	destroyButton(&(guiElements->runCalcul));
	for (int i = 0; i < MENUSIZE; i++) { destroyButton(&(guiElements->menuButtons[i])); }
	// Destroy Images
	al_destroy_bitmap(guiElements->resistorImage);
	al_destroy_bitmap(guiElements->gndImage);
	al_destroy_bitmap(guiElements->vccImage);
}

BOOL ProgramCore::eventHandler(ALL* allegro, ProgramElements* elements, GUIElements* gui) {
	int stillPlaying = TRUE;
	ALLEGRO_EVENT ev;
	al_wait_for_event(allegro->events_queue, &ev);

	if (ev.type == ALLEGRO_EVENT_TIMER) { elements->redraw = TRUE; }
	else if (ev.type == ALLEGRO_EVENT_DISPLAY_CLOSE) {
		stillPlaying = FALSE;
	}
	else if (ev.type == ALLEGRO_EVENT_MOUSE_AXES || ev.type == ALLEGRO_EVENT_MOUSE_ENTER_DISPLAY) {
		elements->mouse.x = ev.mouse.x;
		elements->mouse.y = ev.mouse.y;
		if (elements->modeEnum == MOVEMODE) {
			resistorArray[selectedResIndex].moveResistor(elements->mouse.x, elements->mouse.y, stepMode);
		}
	}
	else if (ev.type == ALLEGRO_EVENT_MOUSE_BUTTON_UP) { 
		if (ev.mouse.button == 2) { //Right Click
			rightClick(elements, gui);
		}
		else { click(allegro, elements->mouse, gui, elements); } //Left Click
	}
	else if (ev.type == ALLEGRO_EVENT_KEY_UP) { //Keyboard
		switch (ev.keyboard.keycode) {
		case ALLEGRO_KEY_SPACE:
			if (gui->resistorAngle == 0) { gui->resistorAngle = PI / 2; }
			else { gui->resistorAngle = 0; }
			break;
		case ALLEGRO_KEY_TAB:
			stepMode = !stepMode;
			break;
		case ALLEGRO_KEY_G:
			grid = !grid;
			break;
		case ALLEGRO_KEY_ESCAPE:
			selectedResIndex = -1;
			resStart = NOTOVER;
			elements->modeEnum = NORMAL;
			break;
		case ALLEGRO_KEY_L:
			diagonally = !diagonally;
			break;
		}
	}
	//if redraw then update screen
	if ( elements->redraw == TRUE ) {
		updateScreen(allegro, gui, elements->mouse, elements->modeEnum);
		elements->redraw = FALSE;
	}
	return stillPlaying;
}
//Initializers
BOOL ProgramCore::initializeGUIElements(GUIElements* gui) {
	if (initializeMenu(gui)) {
		if (gui->resistorButton.buttonImage = al_load_bitmap("Resources/Buttons/resistorButtonImage1.png")) {
			if (gui->resistorButton.mouseOverButtonImage = al_load_bitmap("Resources/Buttons/resistorButtonImage2.png")) {
				gui->resistorButton.buttonPos.x = SCREEN_X - 3 * al_get_bitmap_width(gui->resistorButton.buttonImage) / 2;
				gui->resistorButton.buttonPos.y = 0 * al_get_bitmap_height(gui->resistorButton.buttonImage);
				if (gui->wireButton.buttonImage = al_load_bitmap("Resources/Buttons/wireButtonImage1.png")) {
					if (gui->wireButton.mouseOverButtonImage = al_load_bitmap("Resources/Buttons/wireButtonImage2.png")) {
						gui->wireButton.buttonPos.x = SCREEN_X - 3 * al_get_bitmap_width(gui->resistorButton.buttonImage) / 2;
						gui->wireButton.buttonPos.y = 1 * al_get_bitmap_height(gui->resistorButton.buttonImage);
						if (gui->gndButton.buttonImage = al_load_bitmap("Resources/Buttons/gndButtonImage1.png")) {
							if (gui->gndButton.mouseOverButtonImage = al_load_bitmap("Resources/Buttons/gndButtonImage2.png")) {
								gui->gndButton.buttonPos.x = SCREEN_X - 3 * al_get_bitmap_width(gui->resistorButton.buttonImage) / 2;
								gui->gndButton.buttonPos.y = 2 * al_get_bitmap_height(gui->resistorButton.buttonImage);
								if (gui->vccButton.buttonImage = al_load_bitmap("Resources/Buttons/vccButtonImage1.png")) {
									if (gui->vccButton.mouseOverButtonImage = al_load_bitmap("Resources/Buttons/vccButtonImage2.png")) {
										gui->vccButton.buttonPos.x = SCREEN_X - 3 * al_get_bitmap_width(gui->resistorButton.buttonImage) / 2;
										gui->vccButton.buttonPos.y = 3 * al_get_bitmap_height(gui->resistorButton.buttonImage);
										if (gui->resistorImage = al_load_bitmap("Resources/resistor.png")) {
											if (gui->gndImage = al_load_bitmap("Resources/Ground.png")) {
												if (gui->vccImage = al_load_bitmap("Resources/connector.png")) {
													if (gui->runCalcul.buttonImage = al_load_bitmap("Resources/Buttons/runButtonImage1.png")) {
														if (gui->runCalcul.mouseOverButtonImage = al_load_bitmap("Resources/Buttons/runButtonImage2.png")) {
															gui->runCalcul.buttonPos.x = SCREEN_X - al_get_bitmap_width(gui->runCalcul.buttonImage) - al_get_bitmap_width(gui->resistorButton.buttonImage) / 2;
															gui->runCalcul.buttonPos.y = SCREEN_Y - 2 * al_get_bitmap_height(gui->runCalcul.buttonImage);
															gui->resistorAngle = 0;
															return TRUE;
														}
													}
												}
												else { printf("Unable to load connector Image\n"); }
											}
											else { printf("Unable to load gnd image\n"); }
										}
										else { printf("Unable to load resistor Image\n"); }
									}
									else { printf("Unable to load connect Image 2\n"); }
								}
								else { printf("Unable to load connector Image 1\n"); }
							}
							else { printf("unable to load gnd image 2\n"); }
						}
						else { printf("unable to load gnd image 1\n"); }
					}
					else { printf("Unable to load wire button Image 2\n"); }
				}
				else { printf("Unable to load wire button Image 1\n"); }
			}
			else { printf("Unable to load resistor button image 2\n"); }
		}
		else { printf("Unable to load resistor button image 1\n"); }
	}
	else { printf("Failed to initialize the Menu\n"); }

	return FALSE;
}
BOOL ProgramCore::initializeMenu(GUIElements* gui) {
	int i = 0;
	if (gui->menuButtons[0].buttonImage = al_load_bitmap("Resources/Desplegable/DeleteMenu.png")) {
		if (gui->menuButtons[0].mouseOverButtonImage = al_load_bitmap("Resources/Desplegable/mouseOverDeleteMenu.png")) {
			if (gui->menuButtons[1].buttonImage = al_load_bitmap("Resources/Desplegable/MoveMenu.png")) {
				if (gui->menuButtons[1].mouseOverButtonImage = al_load_bitmap("Resources/Desplegable/mouseOverMoveMenu.png")) {
					if (gui->menuButtons[2].buttonImage = al_load_bitmap("Resources/Desplegable/RotateMenu.png")) {
						if (gui->menuButtons[2].mouseOverButtonImage = al_load_bitmap("Resources/Desplegable/mouseOverRotateMenu.png")) {
							if (gui->menuButtons[3].buttonImage = al_load_bitmap("Resources/Desplegable/SetValueMenu.png")) {
								if (gui->menuButtons[3].mouseOverButtonImage = al_load_bitmap("Resources/Desplegable/mouseOverSetValueMenu.png")) {
									for (i = 0; i < MENUSIZE; i++) {
										gui->menuButtons[i].buttonPos.x = 0;
										gui->menuButtons[i].buttonPos.y = 0;
									}
									return TRUE;
								}
								else { printf("Failed to load mouseOverSetValueMenu.png\n"); }
							}
							else { printf("Failed to load SetValueMenu.png\n"); }
						}
						else { printf("Failed to load mouseOverRotateMenu.png\n"); }
					}
					else { printf("Failed to load RotateMenu.png\n"); }
				}
				else { printf("Failed to load mouseOverMoveMenu.png\n"); }
			}
			else { printf("Failed to load MoveMenu.png\n"); }
		}
		else { printf("Failed to load mouseOverDeleteMenu.png\n"); }
	}
	else { printf("Failed to load DeleteMenu.png\n"); }

	return FALSE;
}
//Update
void ProgramCore::updateScreen(ALL* allegro, GUIElements* gui, pos mouse, enum ModeEnum modeEnum) {
	int i = 0;
	al_set_target_backbuffer(allegro->display);
	al_clear_to_color(al_map_rgb(WHITE));
	if (grid) { makeGrid(); }
	al_draw_bitmap(allegro->downBar, 0, SCREEN_Y - al_get_bitmap_height(allegro->downBar), 0);
	//al_draw_bitmap(allegro->fondo, 0, 0, 0);
	updateResistors(gui, allegro->font);
	updateAllButtons(gui, mouse);
	updateModes(gui, mouse, modeEnum);
	al_draw_textf(allegro->font, al_map_rgb(BLACK), SCREEN_X - 20, allegro->screenHeight - 20, ALLEGRO_ALIGN_RIGHT, "X:%d; Y:%d", mouse.x, mouse.y);
	updateTextMode(allegro->font, 20, allegro->screenHeight - 20, modeEnum);
	al_flip_display();
}
void ProgramCore::updateAllButtons(GUIElements* gui, pos mouse) {
	updateButton(gui->resistorButton, mouse);
	updateButton(gui->wireButton, mouse);
	updateButton(gui->gndButton, mouse);
	updateButton(gui->vccButton, mouse);
	if (updateCalculButton()) { updateButton(gui->runCalcul, mouse); }
}
void ProgramCore::updateButton(Button button, pos mouse) {
	if (checkButton(button, mouse)) {
		al_draw_bitmap(button.mouseOverButtonImage, button.buttonPos.x, button.buttonPos.y, 0);
	}
	else {
		al_draw_bitmap(button.buttonImage, button.buttonPos.x, button.buttonPos.y, 0);
	}
}
void ProgramCore::updateModes(GUIElements* gui, pos mouse, enum ModeEnum modeEnum) {
	int i = 0;
	if (modeEnum == RESISTORPLACE) { //Draw a resistor that follows the mouse
		if (gui->resistorAngle == 0) {
			al_draw_bitmap(gui->resistorImage, mouse.x, mouse.y - al_get_bitmap_height(gui->resistorImage) / 2, 0);
		}
		else {
			al_draw_rotated_bitmap(gui->resistorImage, al_get_bitmap_width(gui->resistorImage) / 2, al_get_bitmap_width(gui->resistorImage) / 2, mouse.x - al_get_bitmap_height(gui->resistorImage), mouse.y + al_get_bitmap_width(gui->resistorImage) / 2, gui->resistorAngle, 0);
		}
	}
	else if (modeEnum == GNDPLACE) {
		al_draw_bitmap(gui->gndImage, mouse.x - al_get_bitmap_width(gui->gndImage) / 2, mouse.y, 0);
	}
	else if (modeEnum == VCCPLACE) {
		al_draw_bitmap(gui->vccImage, mouse.x - al_get_bitmap_width(gui->vccImage) / 2, mouse.y - al_get_bitmap_height(gui->vccImage), 0);
	}
	else if (modeEnum == RIGHTCLICK) { //If I made right click I have to update the menu over the mouse
		for (i = 0; i < MENUSIZE; i++) {
			updateButton(gui->menuButtons[i], mouse);
		}
	}
	else if (modeEnum == WIREPLACE) {
		al_draw_line(mouse.x - DELTA, mouse.y, mouse.x + DELTA, mouse.y, al_map_rgb(BLACK), 1);
		al_draw_line(mouse.x , mouse.y - DELTA, mouse.x, mouse.y + DELTA, al_map_rgb(BLACK), 1);
		if (selectedResIndex != -1) {
			pos resTime = resistorArray[selectedResIndex].getCoords();
			if (resStart == UPPERPART) { draw_line(mouse.x, mouse.y, resTime.x, resTime.y, al_map_rgb(LINECOLOUR), LINEWIDTH, diagonally); }
			else if (resStart == LOWERPART) {
				if (resistorArray[selectedResIndex].getHoriz()) { draw_line(mouse.x, mouse.y, resTime.x + al_get_bitmap_width(gui->resistorImage), resTime.y, al_map_rgb(LINECOLOUR), LINEWIDTH, diagonally); }
				else { draw_line(mouse.x, mouse.y, resTime.x, resTime.y + al_get_bitmap_width(gui->resistorImage), al_map_rgb(LINECOLOUR), LINEWIDTH, diagonally); }
			}
		}
		else if (resStart == NODEVCC) {
			draw_line(vcc.getCorrds().x + al_get_bitmap_width(gui->vccImage) / 2, vcc.getCorrds().y + al_get_bitmap_height(gui->vccImage), mouse.x, mouse.y, al_map_rgb(LINECOLOUR), LINEWIDTH, diagonally);
		}
		else if (resStart == NODEGND) {
			draw_line(gnd.getCorrds().x + al_get_bitmap_width(gui->gndImage) / 2, gnd.getCorrds().y, mouse.x, mouse.y, al_map_rgb(LINECOLOUR), LINEWIDTH, diagonally);
		}
	}
}
void ProgramCore::updateResistors(GUIElements* gui, ALLEGRO_FONT *font) {
	if (!resistorArray.empty()) {
		for (int i = 0; i < resistorArray.size(); i++) {
			resistorArray[i].updateResistor(gui->resistorImage, resistorArray, font, diagonally);
		}
	}
	//UpdateNodes
	vcc.updateNode(resistorArray, gui->resistorImage, diagonally);
	gnd.updateNode(resistorArray, gui->resistorImage, diagonally);
}
void ProgramCore::updateTextMode(ALLEGRO_FONT *font, int x, int y, enum ModeEnum modeEnum) {
	switch (modeEnum) {
	case NORMAL:
		al_draw_text(font, al_map_rgb(BLACK), x, y, ALLEGRO_ALIGN_LEFT, "Resistor Calculator Beta 1.0");
		break;
	case MOVEMODE:
		al_draw_text(font, al_map_rgb(BLACK), x, y, ALLEGRO_ALIGN_LEFT, "Move your Resistor");
		break;
	case RIGHTCLICK:
		al_draw_text(font, al_map_rgb(BLACK), x, y, ALLEGRO_ALIGN_LEFT, "Select Option");
		break;
	case RESISTORPLACE:
		al_draw_text(font, al_map_rgb(BLACK), x, y, ALLEGRO_ALIGN_LEFT, "Place Resistor");
		break;
	case WIREPLACE:
		al_draw_text(font, al_map_rgb(BLACK), x, y, ALLEGRO_ALIGN_LEFT, "Wire Mode");
		break;
	case GNDPLACE:
		al_draw_text(font, al_map_rgb(BLACK), x, y, ALLEGRO_ALIGN_LEFT, "Place GND");
		break;
	case VCCPLACE:
		al_draw_text(font, al_map_rgb(BLACK), x, y, ALLEGRO_ALIGN_LEFT, "Place VCC");
		break;
	}
}
bool ProgramCore::updateCalculButton() {
	int index = gnd.getIndex();
	bool ready = false;
	if (index != -1) {
		while (resistorArray[index].getFather() != -1) {
			index = resistorArray[index].getFather();
		}
		if (vcc.getIndex() == index) { ready = true; }
	}
	if (ready) {
		for (int i = 0; i < resistorArray.size(); i++) {
			if (resistorArray[i].getSon() == -1 && i != gnd.getIndex()) {
				if (resistorArray[i].getStepBro() == -1 || resistorArray[i].getFather() == -1) {
					if (vcc.getIndex() != i) {
						ready = false;
						return ready; //No need to keep looking, I know the result.
					}
				}
			}
		}
	}
	return ready;
}
void ProgramCore::makeGrid() {
	for (int i = 1; i < SCREEN_X / MULTIPLE; i++) {
		al_draw_line(i * MULTIPLE, 0, i * MULTIPLE, SCREEN_Y, al_map_rgb(GRAY), 1);
	}
	for (int j = 1; j < SCREEN_Y / MULTIPLE; j++) {
		al_draw_line(0, j * MULTIPLE, SCREEN_X, j * MULTIPLE, al_map_rgb(GRAY), 1);
	}
}
// Mouse Functions
BOOL ProgramCore::checkButton(Button button, pos mouse) {
	int mouseOverButton = FALSE;
	if ((mouse.x > button.buttonPos.x) && (mouse.x < button.buttonPos.x + al_get_bitmap_width(button.buttonImage))) {
		if ((mouse.y > button.buttonPos.y) && (mouse.y < button.buttonPos.y + al_get_bitmap_height(button.buttonImage))) {
			mouseOverButton = TRUE;
		}
		else { mouseOverButton = FALSE; }
	}
	else { mouseOverButton = FALSE; }
	return mouseOverButton;
}
BOOL ProgramCore::click(ALL* allegro, pos mouse, GUIElements* gui, ProgramElements* elements) {
	if (elements->modeEnum == NORMAL) {
		if (checkButton(gui->resistorButton, mouse)) { elements->modeEnum = RESISTORPLACE;	}
		else if (checkButton(gui->wireButton, mouse)) { elements->modeEnum = WIREPLACE; }
		else if (checkButton(gui->gndButton, mouse)) { elements->modeEnum = GNDPLACE; }
		else if (checkButton(gui->vccButton, mouse)) { elements->modeEnum = VCCPLACE; }
		if (updateCalculButton() && checkButton(gui->runCalcul, mouse)) { startCalculation(allegro, gui, mouse, elements->modeEnum); }
	}
	else if (elements->modeEnum == RESISTORPLACE) {
		Resistor res = Resistor(false, mouse.x, mouse.y, stepMode);
		if (gui->resistorAngle == 0) { res.rotate(); }
		resistorArray.push_back(res);
		//elements->modeEnum = NORMAL;
	}
	else if (elements->modeEnum == WIREPLACE) {
		wired(mouse, gui, elements);
	}
	else if (elements->modeEnum == VCCPLACE) { 
		vcc.setCoords(mouse.x - al_get_bitmap_width(gui->vccImage) / 2, mouse.y - al_get_bitmap_height(gui->vccImage));
		vcc.setIndex(-1);
		elements->modeEnum = NORMAL;
	}
	else if (elements->modeEnum == GNDPLACE) { 
		gnd.setCoords(mouse.x - al_get_bitmap_width(gui->gndImage) / 2, mouse.y); 
		gnd.setIndex(-1);
		elements->modeEnum = NORMAL;
	}
	else if (elements->modeEnum == RIGHTCLICK) {
		elements->modeEnum = NORMAL;
		int i = 0;
		for (i = 0; i < MENUSIZE; i++) {
			if (checkButton(gui->menuButtons[i], mouse)) {
				switch (i) {
				case 0:	//Delete
					deleteResistor(selectedResIndex);
					selectedResIndex = -1;
					break;
				case 1:	//Move
					elements->modeEnum = MOVEMODE;
					backupPos = resistorArray[selectedResIndex].getCoords();
					break;
				case 2: //Rotate
					resistorArray[selectedResIndex].rotate();
					selectedResIndex = -1;
					break;
				case 3:	//Set Value
					updateScreen(allegro, gui, mouse, elements->modeEnum);
					resistorArray[selectedResIndex].setValue(setValue(allegro->font));
					break;
				}
			}
		}
		//elements->modeEnum = NORMAL;
	}
	else if (elements->modeEnum == MOVEMODE) {
		resistorArray[selectedResIndex].moveResistor(mouse.x, mouse.y, stepMode);
		elements->modeEnum = NORMAL;
		selectedResIndex = -1;
	}
	return true;
}
void ProgramCore::rightClick(ProgramElements* elements, GUIElements* gui) {
	if (elements->modeEnum == NORMAL) {
		for (int j = 0; j < resistorArray.size(); j++) {
			if (resistorArray[j].mouseOverRes(gui->resistorImage, elements->mouse) != NOTOVER) {
				selectedResIndex = j;
				int i = 0;
				for (i = 0; i < MENUSIZE; i++) {
					gui->menuButtons[i].buttonPos.x = elements->mouse.x;
					gui->menuButtons[i].buttonPos.y = elements->mouse.y + i * al_get_bitmap_height(gui->menuButtons[i].buttonImage);
				}
				elements->modeEnum = RIGHTCLICK;
			}
		}
	}
	else if (elements->modeEnum == RESISTORPLACE) {
		selectedResIndex = -1;
		resStart = NOTOVER;
		elements->modeEnum = NORMAL;
	}
	else if (elements->modeEnum == MOVEMODE) {
		resistorArray[selectedResIndex].moveResistor(backupPos.x, backupPos.y, stepMode);
		backupPos.x = 0;
		backupPos.y = 0;
		selectedResIndex = -1;
		elements->modeEnum = NORMAL;
	}
	else { 
		selectedResIndex = -1;
		resStart = NOTOVER;
		elements->modeEnum = NORMAL; 
	}
} 

// Wiring Part
void ProgramCore::wired(pos mouse, GUIElements* gui, ProgramElements* elements) {
	// This function is used wile conecting resistors with each other.
	resistorWire(mouse, gui);
	nodeWire(mouse, elements->modeEnum);
}
void ProgramCore::nodeWire(pos mouse, ModeEnum &modeEnum) {
	if (vcc.wireNode(mouse, selectedResIndex, resStart)) { modeEnum = NORMAL; }
	if (gnd.wireNode(mouse, selectedResIndex, resStart)) { modeEnum = NORMAL; }
}
void ProgramCore::resistorWire(pos mouse, GUIElements* gui) {
	for (int i = 0; i < resistorArray.size(); i++) {
		UpperLowerEnum upperLowerEnum = resistorArray[i].mouseOverRes(gui->resistorImage, mouse); // Save the place of the resistor
		if (upperLowerEnum != NOTOVER) {	//If it was over something lets start... (this can't be NODEVCC or NODEGND)
			if (resStart == NOTOVER) { //If it's the firs of the 2 resistors save it.
				resStart = upperLowerEnum;
				selectedResIndex = i;
			}
			else {
				/* *****************************************************************************************
				*	Options:
				*		ResStart:
				*			1. NODEVCC: Do nothing to the new one, just set the new index to vcc
				*			2. NODEGND: Idem vcc but with gnd.
				*			3. LOWERPART:
				*				3.1: UPPERPART:	Set father / Son
				*				3.2: LOWERPART: Set Step Bros
				*			4. UPPERPART:
				*				4.1: UPPERPART:	SET BROTHERS
				*				4.2: LOWERPART: Set father / Son backward
				****************************************************************************************** */  
				if (resStart == NODEVCC) { vcc.setIndex(i); }
				else if (resStart == NODEGND) { gnd.setIndex(i); }
				else if (resStart == LOWERPART) {
					if (upperLowerEnum == UPPERPART) { setFatherSon(resistorArray, selectedResIndex, i); }
					else if (upperLowerEnum == LOWERPART) { setStepBros(resistorArray, selectedResIndex, i); }
					else { cout << "Should never reach here" << endl; }
				}
				else if (resStart == UPPERPART) {
					if (upperLowerEnum == LOWERPART) { setFatherSon(resistorArray, i, selectedResIndex); }
					else if (upperLowerEnum == UPPERPART) { setBros(resistorArray, selectedResIndex, i); }
					else { cout << "Should never reach here" << endl; }
				}
				else { cout << "Error, resStart wasn't Lower nor Upper" << endl; } //Normally it should never get here.
				if (vcc.getIndex() != -1) { if (resistorArray[vcc.getIndex()].getFather() != -1) { vcc.setIndex(-1); } }
				if (gnd.getIndex() != -1) { if (resistorArray[gnd.getIndex()].getSon() != -1) { gnd.setIndex(-1); } }
				//End of wiring
				resStart = NOTOVER;
				selectedResIndex = -1;
				//elements->modeEnum = NORMAL;
			}
		}
	}
}
void ProgramCore::setFatherSon(vector<Resistor> &resistorArray, int father, int son) {
	if (resistorArray[son].getFather() != -1) { //It it has a father already, leave it.
		int last = resistorArray[son].getFather();
		if (resistorArray[last].getSon() == son) { resistorArray[last].deleteSon(); }
		else if (resistorArray[last].getBrother() == son) { resistorArray[last].deleteBrother(); }
	}
	if (resistorArray[father].getSon() != -1) {	resistorArray[resistorArray[father].getSon()].setFather(-1); } //If the father had a son leave it.
	// Now the real stuf.
	resistorArray[father].setSon(son);
	resistorArray[son].setFather(father);
}
void ProgramCore::setStepBros(vector<Resistor> &resistorArray, int bro1, int bro2) {
	int save = bro1;
	int iter = save;
	if (resistorArray[iter].getStepBro() != -1) {
		while (resistorArray[iter].getStepBro() != save) {
			if (resistorArray[iter].getStepBro() == bro2) { return; }
			else { iter = resistorArray[iter].getStepBro(); }
		}
	}
	//if (resistorArray[bro1].getStepBro() == bro2) { return; }
	// This make a circle of stepbros, Infinite loop
	int tempBro1 = resistorArray[bro1].getStepBro();
	int tempBro2 = resistorArray[bro2].getStepBro();
	if (tempBro1 == -1) { resistorArray[bro2].setStepBro(bro1); }
	else { resistorArray[bro2].setStepBro(tempBro1); }
	if (tempBro2 == -1) { resistorArray[bro1].setStepBro(bro2); }
	else { resistorArray[bro1].setStepBro(tempBro2); }
}
void ProgramCore::setBros(vector<Resistor> &resistorArray, int bro1, int bro2) {
	//If both brothers have a father then error
	if (checkForRealFather(resistorArray, bro1) && checkForRealFather(resistorArray, bro2)) {
		cout << "Invalid wiring, at least one brother must have no father" << endl;
		return;
	}
	//Gives prority to bro1 normally bro1 will be father.
	else if (checkForRealFather(resistorArray, bro1)) { //If it has a father then this will have brother and the other the father
		while (resistorArray[bro1].getBrother() != -1) { 
			bro1 = resistorArray[bro1].getBrother(); 
			// For the way setBros work, this shouold never be true. But just in case...
			if (checkForRealFather(resistorArray, bro1)) { cout << "Invalid wiring, the program will explode once hit on calcule" << endl; return; }
		}	//Makes sure it has no brother
		resistorArray[bro2].setFather(bro1);
		resistorArray[bro1].setBrother(bro2);
	}
	else if (checkForRealFather(resistorArray, bro2)) { //If it has a father then this will have brother and the other the father
		while (resistorArray[bro2].getBrother() != -1) { 
			bro2 = resistorArray[bro2].getBrother(); 
			// For the way setBros work, this shouold never be true. But just in case...
			if (checkForRealFather(resistorArray, bro2)) { cout << "Invalid wiring, the program will explode once hit on calcule" << endl; return; }
		}
		resistorArray[bro2].setBrother(bro1);
		resistorArray[bro1].setFather(bro2);
	}
	// If both have no father
	else {
		while (resistorArray[bro1].getBrother() != -1) { bro1 = resistorArray[bro1].getBrother(); }	//Makes sure it has no brother
		if (bro1 != bro2) {
			resistorArray[bro1].setBrother(bro2);
			resistorArray[bro2].setFather(bro1);
		}
	}

}
bool ProgramCore::checkForRealFather(vector<Resistor> &resistorArray, int index) {
	//As father can be both father or brother, this returns true if the father was a father
	if (resistorArray[index].getFather() == -1) { return false; } //This is preventive coding, It should be outside
	if (resistorArray[resistorArray[index].getFather()].getSon() == index) { return true; }
	else { return false; }
}

// Deletion Process
void ProgramCore::deleteResistor(int indexToDelete) {
	deletePointersOfandFrom(indexToDelete);
	reorder(indexToDelete);
	resistorArray.erase(resistorArray.begin() + indexToDelete);
}
void ProgramCore::reorder(int indexToDelete) {
	/* Reorder Its previous the deletion of a resistor. 
	If I delete a resistor the vector will now have a size lower, so all pointers of index higher than the index deleted will have to be reduced in one.
	This function takes care of that.
	It changes all the pointers of other resistors in order to face the deletion of a resistor in vector and have no problem.
	*/
	if (gnd.getIndex() > indexToDelete) { gnd.decreseIndex(); }
	if (vcc.getIndex() > indexToDelete) { vcc.decreseIndex(); }
	for (int i = 0; i < resistorArray.size(); i++) {
		if (resistorArray[i].getBrother() > indexToDelete) { resistorArray[i].decreseBrother(); }
		if (resistorArray[i].getFather() > indexToDelete) { resistorArray[i].decreseFather(); }
		if (resistorArray[i].getSon() > indexToDelete) { resistorArray[i].decreseSon(); }
		if (resistorArray[i].getStepBro() > indexToDelete) { resistorArray[i].decreseStepBro(); }
	}
}
void ProgramCore::deletePointersOfandFrom(int indexToDelete) {
	/* This function receives the index of the resistor to delete and eliminates all pointers to that resistor and from that resistor to have no problems. */
	Resistor resistorToDelete = resistorArray[indexToDelete];
	if (resistorToDelete.getFather() != -1) { //IT has a father?
		if (resistorArray[resistorToDelete.getFather()].getSon() == indexToDelete) {	//It's his son?
			resistorArray[resistorToDelete.getFather()].deleteSon();
		}
		else if (resistorArray[resistorToDelete.getFather()].getBrother() == indexToDelete) {	//Or it's his brother?
			resistorArray[resistorToDelete.getFather()].deleteBrother();
		}
		else {	//It must be father or son... So this option should never run.
			cout << "Error, unrecognized child or brother" << endl; //It should never get here
		}
	}
	if (resistorToDelete.getSon() != -1) { //Take care of your son
		resistorArray[resistorToDelete.getSon()].deleteFather();
	}
	if (resistorToDelete.getBrother() != -1) { //Take care of your brother
		resistorArray[resistorToDelete.getBrother()].deleteFather();
	}
	deleteStepBro(indexToDelete);
	if (gnd.getIndex() == indexToDelete) { gnd.setIndex(-1); } //Does GND or VCC target the resistor?
	if (vcc.getIndex() == indexToDelete) { vcc.setIndex(-1); }
}
void ProgramCore::deleteStepBro(int index) {
	if (resistorArray[index].getStepBro() == -1) { return; }
	int byPass1 = resistorArray[index].getStepBro();	//A quien apunte index
	int byPass2 = index;	//Quien lo apunta a index
	while (resistorArray[byPass2].getStepBro() != index ) {
		byPass2 = resistorArray[byPass2].getStepBro();
	}
	if (byPass1 == byPass2) {
		resistorArray[byPass2].setStepBro(-1);
		return;
	}
	resistorArray[byPass2].setStepBro(byPass1);
	resistorArray[index].setStepBro(-1);
}

// Calculus Functions
double ProgramCore::calculus(int index, ALL* allegro, GUIElements* gui, pos mouse, enum ModeEnum modeEnum) {
	if (resistorArray[index].getStepBro() != -1) {		//Has a stepBro
		if (resistorArray[index].getBrother() != -1 && readyForParallel(resistorArray[index].getBrother(), index)) {
			double brotherValue = calculus(resistorArray[index].getBrother(), allegro, gui, mouse, modeEnum); //Here I have faith that the return will have the same stepbro that bro
			//Parallel Simple
			resistorArray[index].setValue(parallel(resistorArray[index].getValue(), brotherValue));
			takeCareOfHim(index, resistorArray[index].getBrother(), allegro, gui, mouse, modeEnum);
		}
		else if (resistorArray[index].getBrother() == -1) { 
			return resistorArray[index].getValue(); 
		}
		else {
			double brotherValue = calculus(resistorArray[index].getBrother(), allegro, gui, mouse, modeEnum); //Here I have faith that the return will have the same stepbro that bro
			//Parallel Simple
			resistorArray[index].setValue(parallel(resistorArray[index].getValue(), brotherValue));
			takeCareOfHim(index, resistorArray[index].getBrother(), allegro, gui, mouse, modeEnum);
		}
	}
	else if (resistorArray[index].getBrother() != -1) {
		double sonValue = calculus(resistorArray[index].getSon(), allegro, gui, mouse, modeEnum);
		resistorArray[index].setValue(serie(resistorArray[index].getValue(), sonValue));
		takeCareOfHim(index, resistorArray[index].getSon(), allegro, gui, mouse, modeEnum);
		calculus(index, allegro, gui, mouse, modeEnum);
		//double brotherValue = calculus(resistorArray[index].getBrother(), allegro, gui, mouse, modeEnum); 
		////Here I have faith that the return will have the same stepbro that bro
		////Parallel Simple
		//resistorArray[index].setValue(parallel(resistorArray[index].getValue(), brotherValue));
		//takeCareOfHim(index, resistorArray[index].getBrother(), allegro, gui, mouse, modeEnum);
	}
	if (resistorArray[index].getSon() != -1) {
		double sonValue = calculus(resistorArray[index].getSon(), allegro, gui, mouse, modeEnum);
		// Now Series
		resistorArray[index].setValue(serie(resistorArray[index].getValue(), sonValue));
		takeCareOfHim(index, resistorArray[index].getSon(), allegro, gui, mouse, modeEnum);
	}
	return resistorArray[index].getValue();
}
void ProgramCore::deleteEvidence(int survivor, int toDelete) {
	//GND
	if (gnd.getIndex() == toDelete) { gnd.setIndex(survivor); }
	//Pass Brother
	if (resistorArray[toDelete].getBrother() != -1) {
		resistorArray[survivor].setBrother(resistorArray[toDelete].getBrother());	//Pass Brother
		resistorArray[resistorArray[survivor].getBrother()].setFather(survivor);	//Tell the brother who his new father is.
		resistorArray[toDelete].setBrother(-1);
	}

	//Pass StepBro

	if (resistorArray[toDelete].getStepBro() != -1) {
		setStepBros(resistorArray, survivor, toDelete);
		//deleteStepBro(toDelete);
	}
	//Pass Son
	if (resistorArray[toDelete].getSon() != -1) { 
		resistorArray[survivor].setSon(resistorArray[toDelete].getSon());
		resistorArray[resistorArray[survivor].getSon()].setFather(survivor);
		resistorArray[toDelete].setSon(-1);
	}
}
void ProgramCore::takeCareOfHim(int survivor, int toDelete, ALL* allegro, GUIElements* gui, pos mouse, enum ModeEnum modeEnum) {
	deleteEvidence(survivor, toDelete);
	deleteResistor(toDelete);
	updateScreen(allegro, gui, mouse, modeEnum);
	Sleep(TIMEPAUSE);
}
double ProgramCore::parallel(double res1, double res2) {
	return (res1 * res2) / serie(res1, res2);
}
double ProgramCore::serie(double res1, double res2) {
	return res1 + res2;
}
bool ProgramCore::startCalculation(ALL* allegro, GUIElements* gui, pos mouse, enum ModeEnum modeEnum) {
	double ans = calculus(vcc.getIndex(), allegro, gui, mouse, modeEnum); //If I got here I already checked vcc points the correct one and that I have a limit.
	resistorArray[vcc.getIndex()].setFather(-1);
	resistorArray[vcc.getIndex()].setSon(-1);
	resistorArray[vcc.getIndex()].setBrother(-1);
	resistorArray[vcc.getIndex()].setStepBro(-1);
	return true;
}
bool ProgramCore::readyForParallel(int res1, int res2) {
	int equalTo = resistorArray[res1].getBrother();
	if (equalTo == -1) { equalTo = resistorArray[res2].getBrother(); }
	if (equalTo == -1) { cout << "Not even a brother to make the loop" << endl; return false; }
	int i = resistorArray[equalTo].getFather();
	int compare = i;
	i = resistorArray[compare].getStepBro();
	while (i != compare) {
		if (i == equalTo) { return true; }
		i = resistorArray[i].getStepBro();
	}
	return false;
}
</file>

<file path="programCore.h">
#ifndef PROGCORE_H_INCLUDED
#define PROGCORE_H_INCLUDED	

#include "allegro.h"
#include "def.h"
#include "Resistor.h"
#include "Node.h"

#define MENUSIZE 4

enum ModeEnum { NORMAL, MOVEMODE, RIGHTCLICK,
	RESISTORPLACE, WIREPLACE, GNDPLACE, VCCPLACE 
};

typedef struct {
	pos mouse;
	int redraw;					// It tells the event handler if it is time to redraw the screen or not.
	int stillRunning;
	enum ModeEnum modeEnum;	
} ProgramElements;

typedef struct {
	ALLEGRO_BITMAP* buttonImage;
	ALLEGRO_BITMAP* mouseOverButtonImage;
	pos buttonPos;
} Button;

typedef struct {
	//BUTTONS
	Button resistorButton;
	Button wireButton;
	Button gndButton;
	Button vccButton;
	Button runCalcul;
	//Images
	ALLEGRO_BITMAP* resistorImage;
	float resistorAngle;
	ALLEGRO_BITMAP* gndImage;
	ALLEGRO_BITMAP* vccImage;
	//Menu
	Button menuButtons[MENUSIZE];
} GUIElements;

void destroyButton(Button* button);
void destroyGuiElements(GUIElements* guiElements);

class ProgramCore {
public:
	ProgramCore(GUIElements* gui);
	~ProgramCore();
	BOOL eventHandler(ALL* allegro, ProgramElements* elements, GUIElements* gui);
private:
	// Initializers
	BOOL initializeGUIElements(GUIElements* gui);
	BOOL initializeMenu(GUIElements* gui);
	// Update Functions
	void updateButton(Button button, pos mouse);
	void updateScreen(ALL* allegro, GUIElements* gui, pos mouse, enum ModeEnum modeEnum);
	void updateModes(GUIElements* gui, pos mouse, enum ModeEnum modeEnum);
	void updateAllButtons(GUIElements* gui, pos mouse);
	void updateResistors(GUIElements* gui, ALLEGRO_FONT *font);
	void updateTextMode(ALLEGRO_FONT *font, int x, int y, enum ModeEnum modeEnum);
	bool updateCalculButton();
	void makeGrid();
	// Mouse Buttons
	BOOL checkButton(Button button, pos mouse);
	BOOL click(ALL* allegro, pos mouse, GUIElements* gui, ProgramElements* elements);
	void rightClick(ProgramElements* elements, GUIElements* gui);
	// Main Calculation
	double calculus(int index, ALL* allegro, GUIElements* gui, pos mouse, enum ModeEnum modeEnum);
	void deleteEvidence(int survivor, int toDelete);
	void takeCareOfHim(int survivor, int toDelete, ALL* allegro, GUIElements* gui, pos mouse, enum ModeEnum modeEnum);
	double parallel(double res1, double res2);
	double serie(double res1, double res2);
	bool readyForParallel(int res1, int res2);
	bool startCalculation(ALL* allegro, GUIElements* gui, pos mouse, enum ModeEnum modeEnum);
	// Resistor Manipulation
	void wired(pos mouse, GUIElements* gui, ProgramElements* elements);
	void nodeWire(pos mouse, ModeEnum &modeEnum);
	void resistorWire(pos mouse, GUIElements* gui);
	void setFatherSon(vector<Resistor> &resistorArray, int father, int son);
	void setStepBros(vector<Resistor> &resistorArray, int bro1, int bro2);
	void setBros(vector<Resistor> &resistorArray, int bro1, int bro2);
	bool checkForRealFather(vector<Resistor> &resistorArray, int index);
	//Deletion Process
	void deleteResistor(int indexToDelete);
	void reorder(int indexToDelete);
	void deletePointersOfandFrom(int indexToDelete);
	void deleteStepBro(int index);
	
	// ------------ Variables -------------------
	vector<Resistor> resistorArray;
	Node vcc;
	Node gnd;
	int selectedResIndex;
	bool grid;
	bool stepMode;
	bool diagonally;
	pos backupPos;
	UpperLowerEnum resStart;
};

#endif
</file>

<file path="README.md">
# ResistorCalculator
Final Project of "Programacion", ITBA 2016. The program lets you make a circuit of resistors and it calculates the Thevenin

[Watch YouTube video](https://www.youtube.com/watch?v=30qZcaUGGkQ)
</file>

<file path="Resistor.cpp">
#include "Resistor.h"


Resistor::Resistor(bool vertical, int x, int y, bool stepMode) {
	value = 1000;
	this->horizontal = vertical;
	if (stepMode) {
		rPos.x = roundUp(x);
		rPos.y = roundUp(y);
	}
	else {
		rPos.x = x;
		rPos.y = y;
	}
	ptr2brother = -1;
	ptr2father = -1;
	ptr2son = -1;
	ptr2stepBro = -1;
}
void Resistor::updateResistor(ALLEGRO_BITMAP* resistorImage, vector<Resistor> &resistorArray, ALLEGRO_FONT *font, bool diagonally) {
	if (horizontal) {
		al_draw_bitmap(resistorImage, rPos.x, rPos.y - al_get_bitmap_height(resistorImage) / 2, 0);
		al_draw_textf(font, al_map_rgb(BLACK), rPos.x + al_get_bitmap_width(resistorImage) / 2, rPos.y - al_get_bitmap_height(resistorImage) / 2, ALLEGRO_ALIGN_CENTER, "%.0f Ohm", value);
	}
	else {
		al_draw_rotated_bitmap(resistorImage, al_get_bitmap_width(resistorImage) / 2, al_get_bitmap_width(resistorImage) / 2, rPos.x - al_get_bitmap_height(resistorImage), rPos.y + al_get_bitmap_width(resistorImage) / 2, PI / 2, 0);
		al_draw_textf(font, al_map_rgb(BLACK), rPos.x + 10, rPos.y + 20, ALLEGRO_ALIGN_LEFT, "%.0f Ohm", value);
	}
	//Draw lines.
	if (ptr2son != -1 ) { 
		if (ptr2son < resistorArray.size()) {	//Normally this should always be true. But just in case, to know where it exploded
			pos sonPos = resistorArray[ptr2son].getCoords();
			if (horizontal) {
				draw_line(rPos.x + al_get_bitmap_width(resistorImage), rPos.y, sonPos.x, sonPos.y, al_map_rgb(LINECOLOUR), LINEWIDTH, diagonally);
			}
			else {
				draw_line(rPos.x, rPos.y + al_get_bitmap_width(resistorImage), sonPos.x, sonPos.y, al_map_rgb(LINECOLOUR), LINEWIDTH, diagonally);
			}
		}
		else { cout << "Son of a resistor was out of bounds" << endl; }
	}
	if (ptr2brother != -1) {
		if (ptr2brother < resistorArray.size()) {
			pos broPos = resistorArray[ptr2brother].getCoords();
			draw_line(rPos.x, rPos.y, broPos.x, broPos.y, al_map_rgb(LINECOLOUR), LINEWIDTH, diagonally);
		}
		else { cout << "Brother out of bounds" << endl; }
	}
	if (ptr2stepBro != -1) {
		if (ptr2stepBro < resistorArray.size()) {
			pos broPos = resistorArray[ptr2stepBro].getCoords();
			bool broHorizontal = resistorArray[ptr2stepBro].getHoriz();
			if (horizontal) {
				if (broHorizontal) { draw_line(rPos.x + al_get_bitmap_width(resistorImage), rPos.y, broPos.x + al_get_bitmap_width(resistorImage), broPos.y, al_map_rgb(LINECOLOUR), LINEWIDTH, diagonally); }
				else { draw_line_inverted(rPos.x + al_get_bitmap_width(resistorImage), rPos.y, broPos.x, broPos.y + al_get_bitmap_width(resistorImage), al_map_rgb(LINECOLOUR), LINEWIDTH, diagonally); }
			}
			else {
				if (broHorizontal) { draw_line_inverted(rPos.x, rPos.y + al_get_bitmap_width(resistorImage), broPos.x + al_get_bitmap_width(resistorImage), broPos.y, al_map_rgb(LINECOLOUR), LINEWIDTH, diagonally); }
				else { draw_line_inverted(rPos.x, rPos.y + al_get_bitmap_width(resistorImage), broPos.x,  broPos.y + al_get_bitmap_width(resistorImage), al_map_rgb(LINECOLOUR), LINEWIDTH, diagonally); }
			}
		}
		else { cout << "StepBro out of bounds" << endl; }
	}
}
void Resistor::moveResistor(int x, int y, bool stepMode) {
	if (stepMode) {
		rPos.x = roundUp(x);
		rPos.y = roundUp(y);
	}
	else {
		rPos.x = x;
		rPos.y = y;
	}
}
UpperLowerEnum Resistor::mouseOverRes(ALLEGRO_BITMAP* resistorImage, pos mouse) {
	UpperLowerEnum ans = NOTOVER;
	if (!horizontal) {
		if ((mouse.x < rPos.x + al_get_bitmap_height(resistorImage) / 2) && (mouse.x > rPos.x - al_get_bitmap_height(resistorImage) / 2)) {
			if ((mouse.y > rPos.y) && (mouse.y < rPos.y + al_get_bitmap_width(resistorImage) / 2)) { //The upper Part
				ans = UPPERPART;
			}
			else if ((mouse.y >= rPos.y + al_get_bitmap_width(resistorImage) / 2) && (mouse.y < rPos.y + al_get_bitmap_width(resistorImage))) {
				ans = LOWERPART;
			}
		}
	}
	else {
		if ((mouse.y > rPos.y - al_get_bitmap_height(resistorImage) / 2) && (mouse.y < rPos.y + al_get_bitmap_height(resistorImage) / 2)) {
			if ((mouse.x > rPos.x) && (mouse.x < rPos.x + al_get_bitmap_width(resistorImage) / 2)) {
				ans = UPPERPART;
			}
			else if ((mouse.x >= rPos.x + al_get_bitmap_width(resistorImage) / 2) && (mouse.x < rPos.x + al_get_bitmap_width(resistorImage))) {
				ans = LOWERPART;
			}
		}
	}
	return ans;
}
int Resistor::roundUp(int numToRound) {
	if (MULTIPLE == 0) {
		return numToRound;
	}

	int roundDown = ((int)(numToRound) / MULTIPLE) * MULTIPLE;
	int roundUp = roundDown + MULTIPLE;
	int roundCalc = roundUp;
	return (roundCalc);
}
</file>

<file path="Resistor.h">
#ifndef RESISTOR_H_INCLUDED
#define RESISTOR_H_INCLUDED

#include "def.h"
#include "allegro.h"

class Resistor {
public:
	Resistor(bool Vertical, int x, int y, bool stepMode);
	void updateResistor(ALLEGRO_BITMAP* resistorImage, vector<Resistor> &resistorArray, ALLEGRO_FONT *font, bool diagonally);
	UpperLowerEnum mouseOverRes(ALLEGRO_BITMAP* resistorImage, pos mouse);
	//Seters
	void setValue(double value) { this->value = value; }
	void moveResistor(int x, int y, bool stepMode);
	void rotate() { horizontal = !horizontal; }
		//Pointers
	void setFather(int index) { ptr2father = index; }
	void setSon(int index) { ptr2son = index; }
	void setStepBro(int index) { ptr2stepBro = index; }
	void setBrother(int index) { ptr2brother = index; }
	void deleteFather() { setFather(-1); }
	void deleteSon() { setSon(-1); }
	void deleteBrother() { setBrother(-1); }
	void deleteStepBro() { setStepBro(-1); }
	void decreseFather() { ptr2father = ptr2father - 1; }
	void decreseSon() { ptr2son = ptr2son - 1; }
	void decreseBrother() { ptr2brother = ptr2brother - 1; }
	void decreseStepBro() { ptr2stepBro = ptr2stepBro - 1; }
	//Getters
	double getValue() { return value; }
	pos getCoords() { return rPos; }
	bool getHoriz() { return horizontal; }
		//Pointers
	int getFather() { return ptr2father; }
	int getBrother() { return ptr2brother; }
	int getSon() { return ptr2son; }
	int getStepBro() { return ptr2stepBro; }
	int roundUp(int numToRound);
private:
	double value;
	pos rPos;
	bool horizontal;
	//Pointers
	int ptr2father;
	int ptr2brother;
	int ptr2son;
	int ptr2stepBro;
};

#endif
</file>

<file path="setValue.cpp">
#include "setValue.h"

/*solo toma datos si apretas un numero,a las letras o otras cosas las ignora.
Para salir de la funcion y que me devuelva el valor de la resistencia apretar ENTER.
Para borrar usar la letra BACKSPACE*/

double setValue(ALLEGRO_FONT* font)
{
	ALG allegroData = { NULL, NULL, NULL, NULL, };
	ALG* allg = &allegroData;
	double ValRes;
	
	init(allg,font);
	ValRes = SearchEV(allg,font);
	
	destroy(allg);

	return ValRes;
}

int init(ALG* allg, ALLEGRO_FONT* font)
{
	if (!al_init()) {
		fprintf(stderr, "failed to initialize allegro!\n");
		return -1;
	}

	if (!al_install_keyboard()) {
		fprintf(stderr, "failed to initialize the keyboard!\n");
		return -1;
	}

	allg->timer2 = al_create_timer(1.0 / FPS);
	if (!allg->timer2) {
		fprintf(stderr, "failed to create timer!\n");
		return -1;
	}

	allg->display2 = al_create_display(SCREEN_W, SCREEN_H);
	if (!allg->display2) {
		fprintf(stderr, "failed to create display!\n");
		al_destroy_timer(allg->timer2);
		return -1;
	}


	al_set_window_title(allg->display2, "Set Value");

	al_init_font_addon();


	al_clear_to_color(al_map_rgb(255, 0, 255));

	al_set_target_bitmap(al_get_backbuffer(allg->display2));

	allg->event_queue2 = al_create_event_queue();
	if (!allg->event_queue2) {
		fprintf(stderr, "failed to create event_queue!\n");

		al_destroy_display(allg->display2);
		al_destroy_timer(allg->timer2);
		return -1;
	}

	al_register_event_source(allg->event_queue2, al_get_display_event_source(allg->display2));

	al_register_event_source(allg->event_queue2, al_get_timer_event_source(allg->timer2));

	al_register_event_source(allg->event_queue2, al_get_keyboard_event_source());

	al_clear_to_color(al_map_rgb(0, 0, 0));

	al_draw_text(font, al_map_rgb(255, 255, 255), 150 / 2, 30, ALLEGRO_ALIGN_CENTRE, "value:");

	al_flip_display();

	al_start_timer(allg->timer2);

	return 0;
}


double SearchEV(ALG* allg, ALLEGRO_FONT* font)
{
	int i = 0;
	bool key[11] = { false, false, false, false , false , false , false , false , false , false };
	bool redraw = true;
	bool doexit = false;
	double fnumber;
	char number[30];
	char *p2number;
	p2number = number;


	while (!doexit)
	{
		ALLEGRO_EVENT ev2;
		al_wait_for_event(allg->event_queue2, &ev2);

		if (ev2.type == ALLEGRO_EVENT_TIMER) {

			if (key[KEY_0] && i < 20) {
				*(p2number + i) = '0';
				*(p2number + i + 1) = '\0';
				i++;
			}

			if (key[KEY_1] && i < 20) {
				*(p2number + i) = '1';
				*(p2number + i + 1) = '\0';
				i++;
			}

			if (key[KEY_2] && i < 20) {
				*(p2number + i) = '2';
				*(p2number + i + 1) = '\0';
				i++;
			}

			if (key[KEY_3] && i < 20) {
				*(p2number + i) = '3';
				*(p2number + i + 1) = '\0';
				i++;
			}
			if (key[KEY_4] && i < 20) {
				*(p2number + i) = '4';
				*(p2number + i + 1) = '\0';
				i++;
			}
			if (key[KEY_5] && i < 20) {
				*(p2number + i) = '5';
				*(p2number + i + 1) = '\0';
				i++;
			}
			if (key[KEY_6] && i < 20) {
				*(p2number + i) = '6';
				*(p2number + i + 1) = '\0';
				i++;
			}
			if (key[KEY_7] && i < 20) {
				*(p2number + i) = '7';
				*(p2number + i + 1) = '\0';
				i++;
			}
			if (key[KEY_8] && i < 20) {
				*(p2number + i) = '8';
				*(p2number + i + 1) = '\0';
				i++;
			}
			if (key[KEY_9] && i < 20) {
				*(p2number + i) = '9';
				*(p2number + i + 1) = '\0';
				i++;
			}
			if (key[KEY_BACKSPACE] && i >0) {

				*(p2number + i - 1) = '\0';
				i--;
			}





			redraw = true;
		}
		else if (ev2.type == ALLEGRO_EVENT_DISPLAY_CLOSE) {
			break;
		}
		else if (ev2.type == ALLEGRO_EVENT_KEY_DOWN) {
			switch (ev2.keyboard.keycode) {

			case ALLEGRO_KEY_0:
				key[KEY_0] = true;
				break;
			case ALLEGRO_KEY_1:
				key[KEY_1] = true;
				break;

			case ALLEGRO_KEY_2:
				key[KEY_2] = true;
				break;

			case ALLEGRO_KEY_3:
				key[KEY_3] = true;
				break;

			case ALLEGRO_KEY_4:
				key[KEY_4] = true;
				break;

			case ALLEGRO_KEY_5:
				key[KEY_5] = true;
				break;

			case ALLEGRO_KEY_6:
				key[KEY_6] = true;
				break;

			case ALLEGRO_KEY_7:
				key[KEY_7] = true;
				break;

			case ALLEGRO_KEY_8:
				key[KEY_8] = true;
				break;

			case ALLEGRO_KEY_9:
				key[KEY_9] = true;
				break;
			case ALLEGRO_KEY_BACKSPACE:
				key[KEY_BACKSPACE] = true;
				break;
			}
		}
		else if (ev2.type == ALLEGRO_EVENT_KEY_UP) {
			switch (ev2.keyboard.keycode) {
			case ALLEGRO_KEY_0:
				key[KEY_0] = false;
				break;

			case ALLEGRO_KEY_1:
				key[KEY_1] = false;
				break;

			case ALLEGRO_KEY_2:
				key[KEY_2] = false;
				break;

			case ALLEGRO_KEY_3:
				key[KEY_3] = false;
				break;

			case ALLEGRO_KEY_4:
				key[KEY_4] = false;
				break;

			case ALLEGRO_KEY_5:
				key[KEY_5] = false;
				break;

			case ALLEGRO_KEY_6:
				key[KEY_6] = false;
				break;

			case ALLEGRO_KEY_7:
				key[KEY_7] = false;
				break;

			case ALLEGRO_KEY_8:
				key[KEY_8] = false;
				break;

			case ALLEGRO_KEY_9:
				key[KEY_9] = false;
				break;

			case ALLEGRO_KEY_BACKSPACE:
				key[KEY_BACKSPACE] = false;
				break;

			case ALLEGRO_KEY_ENTER:
				doexit = true;
				break;
			}
		}

		if (redraw && al_is_event_queue_empty(allg->event_queue2)) {
			redraw = false;

			al_clear_to_color(al_map_rgb(WHITE));

			al_draw_filled_rectangle(55, 10, 290, 40, al_map_rgb(GRAY));

			al_draw_text(font, al_map_rgb(BLACK), 10, SCREEN_MIDDLE_H, ALLEGRO_ALIGN_LEFT, "Value:");

			al_draw_text(font, al_map_rgb(WHITE), 60, SCREEN_MIDDLE_H, ALLEGRO_ALIGN_LEFT, number);

			al_flip_display();
		}

		fnumber = atof(number);
	}
	return fnumber;
}

int destroy(ALG* allg)
{
	al_destroy_timer(allg->timer2);
	al_destroy_display(allg->display2);
	al_destroy_event_queue(allg->event_queue2);
	return 0;
}
</file>

<file path="setValue.h">
#include "allegro.h"
#include "def.h"

#define SCREEN_W 300
#define SCREEN_H 50

#define SCREEN_MIDDLE_H 20

typedef struct {
	ALLEGRO_DISPLAY *display2;
	ALLEGRO_EVENT_QUEUE *event_queue2;
	ALLEGRO_TIMER *timer2;
	
}ALG;

double setValue(ALLEGRO_FONT* font);
int init(ALG* allg, ALLEGRO_FONT* font);
double SearchEV(ALG* allg, ALLEGRO_FONT* font);
int destroy(ALG* allg);

const float FPS = 10;

enum MYKEYS {
	KEY_0, KEY_1, KEY_2, KEY_3, KEY_4, KEY_5, KEY_6, KEY_7, KEY_8, KEY_9, KEY_BACKSPACE
};
</file>

</files>
